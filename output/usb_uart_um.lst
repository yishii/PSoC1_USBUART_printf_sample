0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0001) ; Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0002) ;
                                   (0003) ;@Id: boot.tpl#682 @
                                   (0004) ;=============================================================================
                                   (0005) ;  FILENAME:   boot.asm
                                   (0006) ;  VERSION:    4.16
                                   (0007) ;  DATE:       6 October 2005
                                   (0008) ;
                                   (0009) ;  DESCRIPTION:
                                   (0010) ;  M8C Boot Code for CY8C24x90 microcontroller devices.
                                   (0011) ;
                                   (0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0013) ;
                                   (0014) ; NOTES:
                                   (0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0016) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0017) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                   (0020) ; are not accidentally modified.
                                   (0021) ;
                                   (0022) ;=============================================================================
                                   (0023) 
                                   (0024) include ".\lib\GlobalParams.inc"
                                   (0025) include "m8c.inc"
                                   (0026) include "m8ssc.inc"
                                   (0027) include "memory.inc"
                                   (0028) 
                                   (0029) ;--------------------------------------
                                   (0030) ; Export Declarations
                                   (0031) ;--------------------------------------
                                   (0032) 
                                   (0033) export __Start
                                   (0034) export __bss_start
                                   (0035) export __data_start
                                   (0036) export __idata_start
                                   (0037) export __func_lit_start
                                   (0038) export __text_start
                                   (0039) export  _bGetPowerSetting
                                   (0040) export   bGetPowerSetting
                                   (0041) 
                                   (0042) 
                                   (0043) ;--------------------------------------
                                   (0044) ; Optimization flags
                                   (0045) ;--------------------------------------
                                   (0046) ;
                                   (0047) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0048) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0049) ; this file.
                                   (0050) 
                                   (0051) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0052) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0053) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0054) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0055) ;
                                   (0056) C_LANGUAGE_SUPPORT:              equ 1
                                   (0057) 
                                   (0058) 
                                   (0059) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0060) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0061) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0062) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0063) ; bytes on the stack which are otherwise required for the return address. If
                                   (0064) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0065) ; release, the C compiler automatically places an infinite loop at the end
                                   (0066) ; of main, rather than a return instruction.)
                                   (0067) ;
                                   (0068) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0069) 
                                   (0070) 
                                   (0071) ;-----------------------------------------------------------------------------
                                   (0072) ; Interrupt Vector Table
                                   (0073) ;-----------------------------------------------------------------------------
                                   (0074) ;
                                   (0075) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0076) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0077) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0078) ; vector jump targets are modified automatically according to the user
                                   (0079) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0080) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0081) ; configuration files. If you need to hard code a vector, update the
                                   (0082) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0083) ; of this file.
                                   (0084) ;-----------------------------------------------------------------------------
                                   (0085) 
                                   (0086)     AREA TOP (ROM, ABS, CON)
                                   (0087) 
                                   (0088)     org   0                        ;Reset Interrupt Vector
                                   (0089)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0090) 
                                   (0091)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                (0092)     halt                           ;Stop execution if power falls too low
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0093) 
                                   (0094)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0095)     // call	void_handler
0008: 7E       RETI                (0096)     reti
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0097) 
                                   (0098)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                   (0099)     // call	void_handler
000C: 7E       RETI                (0100)     reti
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
0010: 30       HALT  
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
0014: 30       HALT  
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0101) 
                                   (0102)     org   18h                      ;VC3 Interrupt Vector
                                   (0103)     // call	void_handler
0018: 7E       RETI                (0104)     reti
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0105) 
                                   (0106)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0107)     // call	void_handler
001C: 7E       RETI                (0108)     reti
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0109) 
                                   (0110)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0111)     // call	void_handler
0020: 7E       RETI                (0112)     reti
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0113) 
                                   (0114)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0115)     // call	void_handler
0024: 7E       RETI                (0116)     reti
0025: 30       HALT  
0026: 30       HALT  
0027: 30       HALT  
                                   (0117) 
                                   (0118)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0119)     // call	void_handler
0028: 7E       RETI                (0120)     reti
0029: 30       HALT  
002A: 30       HALT  
002B: 30       HALT  
                                   (0121) 
                                   (0122)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0123)     // call	void_handler
002C: 7E       RETI                (0124)     reti
002D: 30       HALT  
002E: 30       HALT  
002F: 30       HALT  
0030: 30       HALT  
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
0034: 30       HALT  
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
0038: 30       HALT  
0039: 30       HALT  
003A: 30       HALT  
003B: 30       HALT  
003C: 30       HALT  
003D: 30       HALT  
003E: 30       HALT  
003F: 30       HALT  
                                   (0125) 
                                   (0126)     org   40h                      ;USB Reset Interrupt Vector
0040: 7D 1C 7F LJMP  _USBUART_RESET_ISR(0127)     ljmp	_USBUART_RESET_ISR
0043: 7E       RETI                (0128)     reti
                                   (0129) 
                                   (0130)     org   44h                      ;USB SOF Interrupt Vector
0044: 7D 1C AE LJMP  _USBUART_SOF_ISR(0131)     ljmp	_USBUART_SOF_ISR
0047: 7E       RETI                (0132)     reti
                                   (0133) 
                                   (0134)     org   48h                      ;USB EP0 Interrupt Vector
0048: 7D 06 70 LJMP  0x0670        (0135)     ljmp	_USBUART_EP0_ISR
004B: 7E       RETI                (0136)     reti
                                   (0137) 
                                   (0138)     org   4Ch                      ;USB EP1 Interrupt Vector
004C: 7D 1C 6F LJMP  USBUART_EP1_ISR(0139)     ljmp	_USBUART_EP1_ISR
004F: 7E       RETI                (0140)     reti
                                   (0141) 
                                   (0142)     org   50h                      ;USB EP2 Interrupt Vector
0050: 7D 1C 73 LJMP  _USBUART_EP2_ISR(0143)     ljmp	_USBUART_EP2_ISR
0053: 7E       RETI                (0144)     reti
                                   (0145) 
                                   (0146)     org   54h                      ;USB EP3 Interrupt Vector
0054: 7D 1C 77 LJMP  USBUART_EP3_ISR(0147)     ljmp	_USBUART_EP3_ISR
0057: 7E       RETI                (0148)     reti
                                   (0149) 
                                   (0150)     org   58h                      ;USB EP4 Interrupt Vector
0058: 7D 1C 7B LJMP  USBUART_EP4_ISR(0151)     ljmp	_USBUART_EP4_ISR
005B: 7E       RETI                (0152)     reti
                                   (0153) 
                                   (0154)     org   5Ch                      ;USB Wakeup Interrupt Vector
005C: 7D 1C AF LJMP  _USBUART_WAKEUP_ISR(0155)     ljmp	_USBUART_WAKEUP_ISR
005F: 7E       RETI                (0156)     reti
                                   (0157) 
                                   (0158)     org   60h                      ;PSoC I2C Interrupt Vector
                                   (0159)     // call	void_handler
0060: 7E       RETI                (0160)     reti
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0161) 
                                   (0162)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0163)     // call	void_handler
0064: 7E       RETI                (0164)     reti
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0165) 
                                   (0166) ;-----------------------------------------------------------------------------
                                   (0167) ;  Start of Execution.
                                   (0168) ;-----------------------------------------------------------------------------
                                   (0169) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0170) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0171) ;
                                   (0172)     org 68h
                                   (0173) __Start:
                                   (0174) 
                                   (0175)     ; initialize values for voltage stabilization, if required,
                                   (0176)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0177)     ; least for now. 
                                   (0178)     ;
0068: 71 10    OR    F,16          (0179)     M8C_SetBank1
006A: 62 E3 07 MOV   REG[227],7    (0180)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,239         (0181)     M8C_SetBank0
                                   (0182) 
                                   (0183)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
006F: 50 20    MOV   A,32          (0184)     mov   A, 20h
0071: 28       ROMX                (0185)     romx
                                   (0186)     ; %45%20%46%46% End workaround
                                   (0187) 	
                                   (0188) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0189)     M8C_EnableWatchDog
                                   (0190) ENDIF
                                   (0191) 
0072: 41 FE FB AND   REG[254],251  (0192)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0193) 
                                   (0194)     ;---------------------------
                                   (0195)     ; Set up the Temporary stack
                                   (0196)     ;---------------------------
                                   (0197)     ; A temporary stack is set up for the SSC instructions.
                                   (0198)     ; The real stack start will be assigned later.
                                   (0199)     ;
                                   (0200) _stack_start:          equ 80h
0075: 50 80    MOV   A,128         (0201)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A          (0202)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0203) 
                                   (0204)     ;------------------------
                                   (0205)     ; Set Power-related Trim 
                                   (0206)     ;------------------------
                                   (0207) 
                                   (0208) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                   (0209) 
                                   (0210)   IF ( AGND_BYPASS )
                                   (0211)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0212)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0213)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0214)     ; value using the proper trim values.
                                   (0215)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0216)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0217)   ENDIF
                                   (0218) ELSE
                                   (0219) 	; 3.3V operation trim codes
                                   (0220) 	; Set the IMO and Bandgap trims for 3v operation
                                   (0221)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                   (0222) 	
                                   (0223) 	; Set the IMO Gain Trim for 3v operation
                                   (0224) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                   (0225) 
                                   (0226) ENDIF ; 3.3 Volt Operation
                                   (0227) 
0078: 55 F8 00 MOV   [248],0       (0228)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007B: 55 F9 00 MOV   [249],0       (0229)     mov  [bSSC_KEYSP], 0
                                   (0230) 				
                                   (0231)     ;---------------------------------------
                                   (0232)     ; Initialize Crystal Oscillator and PLL
                                   (0233)     ;---------------------------------------
                                   (0234) 
                                   (0235)     ; Either no ECO, or waiting for stable clock is to be done in main
007E: 71 10    OR    F,16          (0236)     M8C_SetBank1
0080: 62 E0 02 MOV   REG[224],2    (0237)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0083: 70 EF    AND   F,239         (0238)     M8C_SetBank0
0085: 62 E3 38 MOV   REG[227],56   (0239)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0240) 
                                   (0241)     ;---------------------------------------------
                                   (0242)     ; Enter the Large Memory Model, if applicable
                                   (0243)     ;---------------------------------------------
                                   (0244) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0088: 62 D1 03 MOV   REG[209],3    (0245)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
008B: 50 00    MOV   A,0           (0246)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
008D: 4E       SWAP  SP,A          (0247)     swap  A, SP
008E: 62 D3 03 MOV   REG[211],3    (0248)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
0091: 62 D0 00 MOV   REG[208],0    (0249)     RAM_SETPAGE_CUR 0
0094: 62 D5 00 MOV   REG[213],0    (0250)     RAM_SETPAGE_MVW 0
0097: 62 D4 00 MOV   REG[212],0    (0251)     RAM_SETPAGE_MVR 0
                                   (0252) 
                                   (0253)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
009A: 71 C0    OR    F,192         (0254)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0255)   ELSE
                                   (0256)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0257)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0258) ELSE
                                   (0259)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                   (0260)     swap  SP, A
                                   (0261) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0262) 
                                   (0263)     ;------------------------
                                   (0264)     ; Close CT leakage path.
                                   (0265)     ;------------------------
009C: 62 71 05 MOV   REG[113],5    (0266)     mov   reg[ACB00CR0], 05h
009F: 62 75 05 MOV   REG[117],5    (0267)     mov   reg[ACB01CR0], 05h
                                   (0268) 
                                   (0269)     ;-------------------------
                                   (0270)     ; Load Base Configuration
                                   (0271)     ;-------------------------
                                   (0272)     ; Load global parameter settings and load the user modules in the
                                   (0273)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0274)     ; to minimize start up time; (2) We may still need to play with the
                                   (0275)     ; Sleep Timer.
                                   (0276)     ;
00A2: 7C 03 AF LCALL 0x03AF        (0277)     lcall LoadConfigInit
00A5: 71 10    OR    F,16          (0278) 	M8C_SetBank1
00A7: 41 E7 3F AND   REG[231],63   (0279) 	and  reg[DEC_CR1], 0x3F
00AA: 43 E7 80 OR    REG[231],128  (0280) 	or   reg[DEC_CR1], 0x80
00AD: 70 EF    AND   F,239         (0281) 	M8C_SetBank0
                                   (0282)     ;-----------------------------------
                                   (0283)     ; Initialize C Run-Time Environment
                                   (0284)     ;-----------------------------------
                                   (0285) IF ( C_LANGUAGE_SUPPORT )
                                   (0286) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                   (0287)     mov  A,0                           ; clear the 'bss' segment to zero
                                   (0288)     mov  [__r0],<__bss_start
                                   (0289) BssLoop:
                                   (0290)     cmp  [__r0],<__bss_end
                                   (0291)     jz   BssDone
                                   (0292)     mvi  [__r0],A
                                   (0293)     jmp  BssLoop
                                   (0294) BssDone:
                                   (0295)     mov  A,>__idata_start              ; copy idata to data segment
                                   (0296)     mov  X,<__idata_start
                                   (0297)     mov  [__r0],<__data_start
                                   (0298) IDataLoop:
                                   (0299)     cmp  [__r0],<__data_end
                                   (0300)     jz   C_RTE_Done
                                   (0301)     push A
                                   (0302)     romx
                                   (0303)     mvi  [__r0],A
                                   (0304)     pop  A
                                   (0305)     inc  X
                                   (0306)     adc  A,0
                                   (0307)     jmp  IDataLoop
                                   (0308) 
                                   (0309) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0310) 
                                   (0311) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00AF: 62 D0 00 MOV   REG[208],0    (0312)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0313)                                        ; to use the Virtual Register page.
                                   (0314) 
                                   (0315)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0316)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0317)     ; text segment and may have been relocated by the Code Compressor.
                                   (0318)     ;
00B2: 50 01    MOV   A,1           (0319)     mov   A, >__pXIData                ; Get the address of the flash
00B4: 57 D5    MOV   X,213         (0320)     mov   X, <__pXIData                ;   pointer to the xidata area.
00B6: 08       PUSH  A             (0321)     push  A
00B7: 28       ROMX                (0322)     romx                               ; get the MSB of xidata's address
00B8: 53 64    MOV   [__r0],A      (0323)     mov   [__r0], A
00BA: 18       POP   A             (0324)     pop   A
00BB: 75       INC   X             (0325)     inc   X
00BC: 09 00    ADC   A,0           (0326)     adc   A, 0
00BE: 28       ROMX                (0327)     romx                               ; get the LSB of xidata's address
00BF: 4B       SWAP  A,X           (0328)     swap  A, X
00C0: 51 64    MOV   A,[100]       (0329)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0330)                                        ;   XIData structure list in flash
00C2: 80 04    JMP   0x00C7        (0331)     jmp   .AccessStruct
                                   (0332) 
                                   (0333)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0334)     ; values of C variables. Each structure contains 3 member elements.
                                   (0335)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0336)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0337)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0338)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0339)     ; value in the second member element, an unsigned byte:
                                   (0340)     ; (1) If the value of the second element is non-zero, it represents
                                   (0341)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0342)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0343)     ; the bytes are copied to the block of RAM.
                                   (0344)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0345)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0346)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0347) 
                                   (0348) .AccessNextStructLoop:
00C4: 75       INC   X             (0349)     inc   X                            ; pXIData++
00C5: 09 00    ADC   A,0           (0350)     adc   A, 0
                                   (0351) .AccessStruct:                         ; Entry point for first block
                                   (0352)     ;
                                   (0353)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0354)     ;
00C7: 62 E3 00 MOV   REG[227],0    (0355)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CA: 08       PUSH  A             (0356)     push  A
00CB: 28       ROMX                (0357)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00CC: 60 D5    MOV   REG[213],A    (0358)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00CE: 74       INC   A             (0359)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00CF: A0 4B    JZ    0x011B        (0360)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D1: 18       POP   A             (0361)     pop   A                            ; restore pXIData to [A,X]
00D2: 75       INC   X             (0362)     inc   X                            ; pXIData++
00D3: 09 00    ADC   A,0           (0363)     adc   A, 0
00D5: 08       PUSH  A             (0364)     push  A
00D6: 28       ROMX                (0365)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00D7: 53 64    MOV   [__r0],A      (0366)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00D9: 18       POP   A             (0367)     pop   A                            ; restore pXIData to [A,X]
00DA: 75       INC   X             (0368)     inc   X                            ; pXIData++ (point to size)
00DB: 09 00    ADC   A,0           (0369)     adc   A, 0
00DD: 08       PUSH  A             (0370)     push  A
00DE: 28       ROMX                (0371)     romx                               ; Get the size (CPU.A <- *pXIData)
00DF: A0 1C    JZ    0x00FC        (0372)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E1: 53 63    MOV   [__r1],A      (0373)     mov   [__r1], A                    ;             else downcount in __r1
00E3: 18       POP   A             (0374)     pop   A                            ; restore pXIData to [A,X]
                                   (0375) 
                                   (0376) .CopyNextByteLoop:
                                   (0377)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0378)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0379)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0380)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0381)     ;
00E4: 75       INC   X             (0382)     inc   X                            ; pXIData++ (point to next data byte)
00E5: 09 00    ADC   A,0           (0383)     adc   A, 0
00E7: 08       PUSH  A             (0384)     push  A
00E8: 28       ROMX                (0385)     romx                               ; Get the data value (CPU.A <- *pXIData)
00E9: 3F 64    MVI   [__r0],A      (0386)     mvi   [__r0], A                    ; Transfer the data to RAM
00EB: 47 64 FF TST   [100],255     (0387)     tst   [__r0], 0xff                 ; Check for page crossing
00EE: B0 06    JNZ   0x00F5        (0388)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F0: 5D D5    MOV   A,REG[213]    (0389)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F2: 74       INC   A             (0390)     inc   A
00F3: 60 D5    MOV   REG[213],A    (0391)     mov   reg[ MVW_PP], A
                                   (0392) .CopyLoopTail:
00F5: 18       POP   A             (0393)     pop   A                            ; restore pXIData to [A,X]
00F6: 7A 63    DEC   [__r1]        (0394)     dec   [__r1]                       ; End of this array in flash?
00F8: BF EB    JNZ   0x00E4        (0395)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FA: 8F C9    JMP   0x00C4        (0396)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0397) 
                                   (0398) .ClearRAMBlockToZero:
00FC: 18       POP   A             (0399)     pop   A                            ; restore pXIData to [A,X]
00FD: 75       INC   X             (0400)     inc   X                            ; pXIData++ (point to next data byte)
00FE: 09 00    ADC   A,0           (0401)     adc   A, 0
0100: 08       PUSH  A             (0402)     push  A
0101: 28       ROMX                (0403)     romx                               ; Get the run length (CPU.A <- *pXIData)
0102: 53 63    MOV   [__r1],A      (0404)     mov   [__r1], A                    ; Initialize downcounter
0104: 50 00    MOV   A,0           (0405)     mov   A, 0                         ; Initialize source data
                                   (0406) 
                                   (0407) .ClearRAMBlockLoop:
                                   (0408)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0409)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0410)     ;
0106: 3F 64    MVI   [__r0],A      (0411)     mvi   [__r0], A                    ; Clear a byte
0108: 47 64 FF TST   [100],255     (0412)     tst   [__r0], 0xff                 ; Check for page crossing
010B: B0 08    JNZ   0x0114        (0413)     jnz   .ClearLoopTail               ;   No crossing, keep going
010D: 5D D5    MOV   A,REG[213]    (0414)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
010F: 74       INC   A             (0415)     inc   A
0110: 60 D5    MOV   REG[213],A    (0416)     mov   reg[ MVW_PP], A
0112: 50 00    MOV   A,0           (0417)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0418) .ClearLoopTail:
0114: 7A 63    DEC   [__r1]        (0419)     dec   [__r1]                       ; Was this the last byte?
0116: BF EF    JNZ   0x0106        (0420)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0118: 18       POP   A             (0421)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0119: 8F AA    JMP   0x00C4        (0422)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0423) 
                                   (0424) .C_RTE_WrapUp:
011B: 18       POP   A             (0425)     pop   A                            ; balance stack
                                   (0426) 
                                   (0427) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                   (0428) 
                                   (0429) C_RTE_Done:
                                   (0430) 
                                   (0431) ENDIF ; C_LANGUAGE_SUPPORT
                                   (0432) 
                                   (0433) 
                                   (0434)     ;-------------------------------
                                   (0435)     ; Set Power-On Reset (POR) Level
                                   (0436)     ;-------------------------------
011C: 71 10    OR    F,16          (0437)     M8C_SetBank1
                                   (0438) 
                                   (0439) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                   (0440)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                   (0441) ELSE										   ; 5V Operation
                                   (0442)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                   (0443)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
                                   (0444)   ELSE ; 24HMz                                 ;
011E: 43 E3 20 OR    REG[227],32   (0445)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                   (0446)   ENDIF ; 24MHz
                                   (0447) ENDIF ; 3.3V Operation
                                   (0448) 
0121: 70 EF    AND   F,239         (0449)     M8C_SetBank0
                                   (0450) 
                                   (0451)     ;----------------------------
                                   (0452)     ; Wrap up and invoke "main"
                                   (0453)     ;----------------------------
                                   (0454) 
                                   (0455)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                   (0456)     ; no interrupts should be enabled now, so may as well clear the register.
                                   (0457)     ;
0123: 62 E0 00 MOV   REG[224],0    (0458)     mov  reg[INT_MSK0],0
                                   (0459) 
                                   (0460)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                   (0461)     ;
0126: 71 10    OR    F,16          (0462)     M8C_SetBank1
0128: 62 E0 03 MOV   REG[224],3    (0463)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012B: 70 EF    AND   F,239         (0464)     M8C_SetBank0
                                   (0465) 
                                   (0466)     ; Global Interrupt are NOT enabled, this should be done in main().
                                   (0467)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                   (0468)     ; Global Interrupts should be enabled as soon as possible in main().
                                   (0469)     ;
012D: 62 E2 00 MOV   REG[226],0    (0470)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                   (0471)                                    ; have been set during the boot process.
                                   (0472) IF ENABLE_LJMP_TO_MAIN
                                   (0473)     ljmp  _main                    ; goto main (no return)
                                   (0474) ELSE
0130: 7C 0E 38 LCALL _main         (0475)     lcall _main                    ; call main
                                   (0476) .Exit:
0133: 8F FF    JMP   0x0133        (0477)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                   (0478) ENDIF
                                   (0479) 
                                   (0480)     ;---------------------------------
                                   (0481)     ; Library Access to Global Parms
                                   (0482)     ;---------------------------------
                                   (0483)     ;
                                   (0484)  bGetPowerSetting:
                                   (0485) _bGetPowerSetting:
                                   (0486)     ; Returns value of POWER_SETTING in the A register.
                                   (0487)     ; No inputs. No Side Effects.
                                   (0488)     ;
0135: 50 10    MOV   A,16          (0489)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
0137: 7F       RET                 (0490)     ret
0138: 30       HALT  
0139: 30       HALT  
013A: 30       HALT  
013B: 30       HALT  
013C: 30       HALT  
013D: 30       HALT  
013E: 30       HALT  
013F: 30       HALT  
0140: 30       HALT  
0141: 30       HALT  
0142: 30       HALT  
0143: 30       HALT  
0144: 30       HALT  
0145: 30       HALT  
0146: 30       HALT  
0147: 30       HALT  
0148: 30       HALT  
0149: 30       HALT  
014A: 30       HALT  
014B: 30       HALT  
014C: 30       HALT  
014D: 30       HALT  
014E: 30       HALT  
014F: 30       HALT  
0150: 30       HALT  
0151: 30       HALT  
0152: 30       HALT  
0153: 30       HALT  
0154: 30       HALT  
0155: 30       HALT  
0156: 30       HALT  
0157: 30       HALT  
0158: 30       HALT  
0159: 30       HALT  
015A: 30       HALT  
015B: 30       HALT  
015C: 30       HALT  
015D: 30       HALT  
015E: 30       HALT  
015F: 30       HALT  
0160: 30       HALT  
0161: 30       HALT  
0162: 30       HALT  
0163: 30       HALT  
0164: 30       HALT  
0165: 30       HALT  
0166: 30       HALT  
0167: 30       HALT  
0168: 30       HALT  
0169: 30       HALT  
016A: 30       HALT  
016B: 30       HALT  
016C: 30       HALT  
016D: 30       HALT  
016E: 30       HALT  
016F: 30       HALT  
0170: 30       HALT  
0171: 30       HALT  
0172: 30       HALT  
0173: 30       HALT  
0174: 30       HALT  
0175: 30       HALT  
0176: 30       HALT  
0177: 30       HALT  
0178: 30       HALT  
0179: 30       HALT  
017A: 30       HALT  
017B: 30       HALT  
017C: 30       HALT  
017D: 30       HALT  
017E: 30       HALT  
017F: 30       HALT  
0180: 30       HALT  
0181: 30       HALT  
0182: 30       HALT  
0183: 30       HALT  
0184: 30       HALT  
0185: 30       HALT  
0186: 30       HALT  
0187: 30       HALT  
0188: 30       HALT  
0189: 30       HALT  
018A: 30       HALT  
018B: 30       HALT  
018C: 30       HALT  
018D: 30       HALT  
018E: 30       HALT  
018F: 30       HALT  
0190: 30       HALT  
0191: 30       HALT  
0192: 30       HALT  
0193: 30       HALT  
0194: 30       HALT  
0195: 30       HALT  
0196: 30       HALT  
0197: 30       HALT  
0198: 30       HALT  
0199: 30       HALT  
019A: 30       HALT  
019B: 30       HALT  
019C: 30       HALT  
019D: 30       HALT  
019E: 30       HALT  
019F: 30       HALT  
01A0: 48 65 6C TST   [X+101],108
01A3: 6C 6F    RLC   [X+111]
01A5: 00       SWI   
01A6: 69 20    ASR   [X+32]
01A8: 3D 20 25 CMP   [X+32],37
01AB: 64       ASL   A
01AC: 28       ROMX  
01AD: 48 65 78 TST   [X+101],120
01B0: 3A 25    CMP   A,[37]
01B2: 58 29    MOV   X,[41]
01B4: 28       ROMX  
01B5: 52 4F    MOV   A,[X+79]
01B7: 4D 3A    SWAP  X,[58]
01B9: 25 53    AND   [X+83],A
01BB: 29 28    OR    A,40
01BD: 52 41    MOV   A,[X+65]
01BF: 4D 3A    SWAP  X,[58]
01C1: 25 73    AND   [X+115],A
01C3: 29 20    OR    A,32
01C5: 25 63    AND   [X+99],A
01C7: 25 63    AND   [X+99],A
01C9: 25 63    AND   [X+99],A
01CB: 0A 0D    ADC   A,[13]
01CD: 00       SWI   
01CE: 52 20    MOV   A,[X+32]
01D0: 41 20 4D AND   REG[32],77
01D3: 21 00    AND   A,0
01D5: 1D 73    SBB   [X+115],A
01D7: 0E E7 01 ADC   [231],1
01DA: 01 DE    ADD   A,222
01DC: 01 FC    ADD   A,252
01DE: 01 00    ADD   A,0
01E0: 00       SWI   
01E1: 00       SWI   
01E2: 00       SWI   
01E3: 80 80    JMP   0x0264
01E5: 00       SWI   
01E6: 7F       RET   
01E7: 00       SWI   
01E8: 00       SWI   
01E9: 00       SWI   
01EA: 00       SWI   
01EB: 01 00    ADD   A,0
01ED: 00       SWI   
01EE: 00       SWI   
01EF: 00       SWI   
01F0: 00       SWI   
01F1: 00       SWI   
01F2: 00       SWI   
01F3: DE 00    JNC   0xFFF4
01F5: 00       SWI   
01F6: 00       SWI   
01F7: 00       SWI   
01F8: 00       SWI   
01F9: 00       SWI   
01FA: 00       SWI   
01FB: DE 00    JNC   0xFFFC
01FD: 00       SWI   
01FE: 00       SWI   
01FF: 43 08 FE OR    REG[8],254
0202: 00       SWI   
0203: 00       SWI   
0204: DE 00    JNC   0x0005
0206: 00       SWI   
0207: 00       SWI   
0208: 12 08    SUB   A,[8]
020A: EC 00    JACC  0xFE0B
020C: 00       SWI   
020D: DE 71    JNC   0x007F

FILE: lib\psocconfigtbl.asm
                                   (0001) ; Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0002) ;
                                   (0003) include "m8c.inc"
                                   (0004) ;  Personalization tables 
                                   (0005) export LoadConfigTBL_usb_uart_um
                                   (0006) AREA psoc_config(rom, rel)
                                   (0007) LoadConfigTBL_usb_uart_um:
                                   (0008) ;  Ordered Global Register values
020F: 10       PUSH  X             (0009) 	M8C_SetBank1
0210: 62 00 00 MOV   REG[0],0      (0010) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
0213: 62 01 FF MOV   REG[1],255    (0011) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
0216: 70 EF    AND   F,239         (0012) 	M8C_SetBank0
0218: 62 03 FF MOV   REG[3],255    (0013) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
021B: 62 02 00 MOV   REG[2],0      (0014) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
021E: 71 10    OR    F,16          (0015) 	M8C_SetBank1
0220: 62 02 00 MOV   REG[2],0      (0016) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
0223: 62 03 00 MOV   REG[3],0      (0017) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
0226: 70 EF    AND   F,239         (0018) 	M8C_SetBank0
0228: 62 01 00 MOV   REG[1],0      (0019) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
022B: 71 10    OR    F,16          (0020) 	M8C_SetBank1
022D: 62 04 00 MOV   REG[4],0      (0021) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
0230: 62 05 FF MOV   REG[5],255    (0022) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
0233: 70 EF    AND   F,239         (0023) 	M8C_SetBank0
0235: 62 07 FF MOV   REG[7],255    (0024) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
0238: 62 06 00 MOV   REG[6],0      (0025) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
023B: 71 10    OR    F,16          (0026) 	M8C_SetBank1
023D: 62 06 00 MOV   REG[6],0      (0027) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
0240: 62 07 00 MOV   REG[7],0      (0028) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
0243: 70 EF    AND   F,239         (0029) 	M8C_SetBank0
0245: 62 05 00 MOV   REG[5],0      (0030) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
0248: 71 10    OR    F,16          (0031) 	M8C_SetBank1
024A: 62 08 00 MOV   REG[8],0      (0032) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
024D: 62 09 FF MOV   REG[9],255    (0033) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
0250: 70 EF    AND   F,239         (0034) 	M8C_SetBank0
0252: 62 0B FF MOV   REG[11],255   (0035) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
0255: 62 0A 00 MOV   REG[10],0     (0036) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
0258: 71 10    OR    F,16          (0037) 	M8C_SetBank1
025A: 62 0A 00 MOV   REG[10],0     (0038) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
025D: 62 0B 00 MOV   REG[11],0     (0039) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
0260: 70 EF    AND   F,239         (0040) 	M8C_SetBank0
0262: 62 09 00 MOV   REG[9],0      (0041) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
0265: 71 10    OR    F,16          (0042) 	M8C_SetBank1
0267: 62 0C 00 MOV   REG[12],0     (0043) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
026A: 62 0D FF MOV   REG[13],255   (0044) 	mov	reg[0dh], ffh		; Port_3_DriveMode_1 register (PRT3DM1)
026D: 70 EF    AND   F,239         (0045) 	M8C_SetBank0
026F: 62 0F FF MOV   REG[15],255   (0046) 	mov	reg[0fh], ffh		; Port_3_DriveMode_2 register (PRT3DM2)
0272: 62 0E 00 MOV   REG[14],0     (0047) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0275: 71 10    OR    F,16          (0048) 	M8C_SetBank1
0277: 62 0E 00 MOV   REG[14],0     (0049) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
027A: 62 0F 00 MOV   REG[15],0     (0050) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
027D: 70 EF    AND   F,239         (0051) 	M8C_SetBank0
027F: 62 0D 00 MOV   REG[13],0     (0052) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0282: 71 10    OR    F,16          (0053) 	M8C_SetBank1
0284: 62 10 00 MOV   REG[16],0     (0054) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0287: 62 11 FF MOV   REG[17],255   (0055) 	mov	reg[11h], ffh		; Port_4_DriveMode_1 register (PRT4DM1)
028A: 70 EF    AND   F,239         (0056) 	M8C_SetBank0
028C: 62 13 FF MOV   REG[19],255   (0057) 	mov	reg[13h], ffh		; Port_4_DriveMode_2 register (PRT4DM2)
028F: 62 12 00 MOV   REG[18],0     (0058) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0292: 71 10    OR    F,16          (0059) 	M8C_SetBank1
0294: 62 12 00 MOV   REG[18],0     (0060) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0297: 62 13 00 MOV   REG[19],0     (0061) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
029A: 70 EF    AND   F,239         (0062) 	M8C_SetBank0
029C: 62 11 00 MOV   REG[17],0     (0063) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
029F: 71 10    OR    F,16          (0064) 	M8C_SetBank1
02A1: 62 14 00 MOV   REG[20],0     (0065) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
02A4: 62 15 FF MOV   REG[21],255   (0066) 	mov	reg[15h], ffh		; Port_5_DriveMode_1 register (PRT5DM1)
02A7: 70 EF    AND   F,239         (0067) 	M8C_SetBank0
02A9: 62 17 FF MOV   REG[23],255   (0068) 	mov	reg[17h], ffh		; Port_5_DriveMode_2 register (PRT5DM2)
02AC: 62 16 00 MOV   REG[22],0     (0069) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
02AF: 71 10    OR    F,16          (0070) 	M8C_SetBank1
02B1: 62 16 00 MOV   REG[22],0     (0071) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
02B4: 62 17 00 MOV   REG[23],0     (0072) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
02B7: 70 EF    AND   F,239         (0073) 	M8C_SetBank0
02B9: 62 15 00 MOV   REG[21],0     (0074) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
02BC: 71 10    OR    F,16          (0075) 	M8C_SetBank1
02BE: 62 1C 00 MOV   REG[28],0     (0076) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
02C1: 62 1D 81 MOV   REG[29],129   (0077) 	mov	reg[1dh], 81h		; Port_7_DriveMode_1 register (PRT7DM1)
02C4: 70 EF    AND   F,239         (0078) 	M8C_SetBank0
02C6: 62 1F 81 MOV   REG[31],129   (0079) 	mov	reg[1fh], 81h		; Port_7_DriveMode_2 register (PRT7DM2)
02C9: 62 1E 00 MOV   REG[30],0     (0080) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
02CC: 71 10    OR    F,16          (0081) 	M8C_SetBank1
02CE: 62 1E 00 MOV   REG[30],0     (0082) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
02D1: 62 1F 00 MOV   REG[31],0     (0083) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
02D4: 70 EF    AND   F,239         (0084) 	M8C_SetBank0
02D6: 62 1D 00 MOV   REG[29],0     (0085) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
02D9: 70 EF    AND   F,239         (0086) 	M8C_SetBank0
                                   (0087) ;  Global Register values
02DB: 62 60 09 MOV   REG[96],9     (0088) 	mov	reg[60h], 09h		; AnalogColumnInputSelect register (AMX_IN)
02DE: 62 66 00 MOV   REG[102],0    (0089) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
02E1: 62 61 00 MOV   REG[97],0     (0090) 	mov	reg[61h], 00h		; AnalogMuxBusConfig register (AMUXCFG)
02E4: 62 63 05 MOV   REG[99],5     (0091) 	mov	reg[63h], 05h		; AnalogReferenceControl register (ARF_CR)
02E7: 62 65 00 MOV   REG[101],0    (0092) 	mov	reg[65h], 00h		; AnalogSyncControl register (ASY_CR)
02EA: 62 FD 00 MOV   REG[253],0    (0093) 	mov	reg[fdh], 00h		; DAC_Data register (DAC_D)
02ED: 62 E6 00 MOV   REG[230],0    (0094) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
02F0: 62 E7 00 MOV   REG[231],0    (0095) 	mov	reg[e7h], 00h		; DecimatorControl_1 register (DEC_CR1)
02F3: 62 56 00 MOV   REG[86],0     (0096) 	mov	reg[56h], 00h		; Endpoint0Control register (EP0_CR)
02F6: 62 57 00 MOV   REG[87],0     (0097) 	mov	reg[57h], 00h		; Endpoint0Count register (EP0_CNT)
02F9: 62 58 00 MOV   REG[88],0     (0098) 	mov	reg[58h], 00h		; Endpoint0Data0 register (EP0_DR0)
02FC: 62 59 00 MOV   REG[89],0     (0099) 	mov	reg[59h], 00h		; Endpoint0Data1 register (EP0_DR1)
02FF: 62 5A 00 MOV   REG[90],0     (0100) 	mov	reg[5ah], 00h		; Endpoint0Data2 register (EP0_DR2)
0302: 62 5B 00 MOV   REG[91],0     (0101) 	mov	reg[5bh], 00h		; Endpoint0Data3 register (EP0_DR3)
0305: 62 5C 00 MOV   REG[92],0     (0102) 	mov	reg[5ch], 00h		; Endpoint0Data4 register (EP0_DR4)
0308: 62 5D 00 MOV   REG[93],0     (0103) 	mov	reg[5dh], 00h		; Endpoint0Data5 register (EP0_DR5)
030B: 62 5E 00 MOV   REG[94],0     (0104) 	mov	reg[5eh], 00h		; Endpoint0Data6 register (EP0_DR6)
030E: 62 5F 00 MOV   REG[95],0     (0105) 	mov	reg[5fh], 00h		; Endpoint0Data7 register (EP0_DR7)
0311: 62 4F 00 MOV   REG[79],0     (0106) 	mov	reg[4fh], 00h		; Endpoint1Count0 register (EP1_CNT)
0314: 62 4E 00 MOV   REG[78],0     (0107) 	mov	reg[4eh], 00h		; Endpoint1Count1 register (EP1_CNT1)
0317: 62 51 00 MOV   REG[81],0     (0108) 	mov	reg[51h], 00h		; Endpoint2Count0 register (EP2_CNT)
031A: 62 50 00 MOV   REG[80],0     (0109) 	mov	reg[50h], 00h		; Endpoint2Count1 register (EP2_CNT1)
031D: 62 53 00 MOV   REG[83],0     (0110) 	mov	reg[53h], 00h		; Endpoint3Count0 register (EP3_CNT)
0320: 62 52 00 MOV   REG[82],0     (0111) 	mov	reg[52h], 00h		; Endpoint3Count1 register (EP3_CNT1)
0323: 62 55 00 MOV   REG[85],0     (0112) 	mov	reg[55h], 00h		; Endpoint4Count0 register (EP4_CNT)
0326: 62 54 00 MOV   REG[84],0     (0113) 	mov	reg[54h], 00h		; Endpoint4Count1 register (EP4_CNT1)
0329: 62 D6 00 MOV   REG[214],0    (0114) 	mov	reg[d6h], 00h		; I2CConfig register (I2CCFG)
032C: 62 B0 00 MOV   REG[176],0    (0115) 	mov	reg[b0h], 00h		; Row_0_InputMux register (RDI0RI)
032F: 62 B1 00 MOV   REG[177],0    (0116) 	mov	reg[b1h], 00h		; Row_0_InputSync register (RDI0SYN)
0332: 62 B2 00 MOV   REG[178],0    (0117) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
0335: 62 B3 33 MOV   REG[179],51   (0118) 	mov	reg[b3h], 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
0338: 62 B4 33 MOV   REG[180],51   (0119) 	mov	reg[b4h], 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
033B: 62 B5 00 MOV   REG[181],0    (0120) 	mov	reg[b5h], 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
033E: 62 B6 00 MOV   REG[182],0    (0121) 	mov	reg[b6h], 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
0341: 62 4A 00 MOV   REG[74],0     (0122) 	mov	reg[4ah], 00h		; USBControl_0 register (USB_CR0)
0344: 62 4B 00 MOV   REG[75],0     (0123) 	mov	reg[4bh], 00h		; USBIOControl_0 register (USBIO_CR0)
0347: 62 4C 00 MOV   REG[76],0     (0124) 	mov	reg[4ch], 00h		; USBIOControl_1 register (USBIO_CR1)
                                   (0125) ;  Instance name USBUART, User Module USBUART
034A: 71 10    OR    F,16          (0126) 	M8C_SetBank1
                                   (0127) ;  Global Register values
034C: 62 61 00 MOV   REG[97],0     (0128) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
034F: 62 69 00 MOV   REG[105],0    (0129) 	mov	reg[69h], 00h		; AnalogClockSelect2 register (CLK_CR2)
0352: 62 60 00 MOV   REG[96],0     (0130) 	mov	reg[60h], 00h		; AnalogColumnClockSelect register (CLK_CR0)
0355: 62 62 00 MOV   REG[98],0     (0131) 	mov	reg[62h], 00h		; AnalogIOControl_0 register (ABF_CR0)
0358: 62 67 33 MOV   REG[103],51   (0132) 	mov	reg[67h], 33h		; AnalogLUTControl0 register (ALT_CR0)
035B: 62 68 00 MOV   REG[104],0    (0133) 	mov	reg[68h], 00h		; AnalogLUTControl1 register (ALT_CR1)
035E: 62 63 00 MOV   REG[99],0     (0134) 	mov	reg[63h], 00h		; AnalogModulatorControl_0 register (AMD_CR0)
0361: 62 66 00 MOV   REG[102],0    (0135) 	mov	reg[66h], 00h		; AnalogModulatorControl_1 register (AMD_CR1)
0364: 62 64 00 MOV   REG[100],0    (0136) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
0367: 62 64 00 MOV   REG[100],0    (0137) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn1 register (CMP_GO_EN1)
036A: 62 FD 80 MOV   REG[253],128  (0138) 	mov	reg[fdh], 80h		; DAC_Control register (DAC_CR)
036D: 62 C4 00 MOV   REG[196],0    (0139) 	mov	reg[c4h], 00h		; Endpoint1Control register (EP1_CR)
0370: 62 C5 00 MOV   REG[197],0    (0140) 	mov	reg[c5h], 00h		; Endpoint2Control register (EP2_CR)
0373: 62 C6 00 MOV   REG[198],0    (0141) 	mov	reg[c6h], 00h		; Endpoint3Control register (EP3_CR)
0376: 62 C7 00 MOV   REG[199],0    (0142) 	mov	reg[c7h], 00h		; Endpoint4Control register (EP4_CR)
0379: 62 D1 00 MOV   REG[209],0    (0143) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
037C: 62 D3 00 MOV   REG[211],0    (0144) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
037F: 62 D0 00 MOV   REG[208],0    (0145) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
0382: 62 D2 00 MOV   REG[210],0    (0146) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
0385: 62 E1 FF MOV   REG[225],255  (0147) 	mov	reg[e1h], ffh		; OscillatorControl_1 register (OSC_CR1)
0388: 62 E2 00 MOV   REG[226],0    (0148) 	mov	reg[e2h], 00h		; OscillatorControl_2 register (OSC_CR2)
038B: 62 DF FF MOV   REG[223],255  (0149) 	mov	reg[dfh], ffh		; OscillatorControl_3 register (OSC_CR3)
038E: 62 DE 02 MOV   REG[222],2    (0150) 	mov	reg[deh], 02h		; OscillatorControl_4 register (OSC_CR4)
0391: 62 DD 00 MOV   REG[221],0    (0151) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
0394: 62 D8 00 MOV   REG[216],0    (0152) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
0397: 62 D9 00 MOV   REG[217],0    (0153) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
039A: 62 DA 00 MOV   REG[218],0    (0154) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
039D: 62 DB 00 MOV   REG[219],0    (0155) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
03A0: 62 EC 00 MOV   REG[236],0    (0156) 	mov	reg[ech], 00h		; Port_4_MUXBusCtrl register (MUX_CR4)
03A3: 62 ED 00 MOV   REG[237],0    (0157) 	mov	reg[edh], 00h		; Port_5_MUXBusCtrl register (MUX_CR5)
03A6: 62 E7 00 MOV   REG[231],0    (0158) 	mov	reg[e7h], 00h		; Type2Decimator_Control register (DEC_CR2)
03A9: 62 C1 00 MOV   REG[193],0    (0159) 	mov	reg[c1h], 00h		; USBControl_1 register (USB_CR1)
                                   (0160) ;  Instance name USBUART, User Module USBUART
03AC: 70 EF    AND   F,239         (0161) 	M8C_SetBank0
03AE: 7F       RET                 (0162) 	ret

FILE: lib\psocconfig.asm
                                   (0001) ; Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0002) ;
                                   (0003) ;==========================================================================
                                   (0004) ;  PSoCConfig.asm
                                   (0005) ;  @PSOC_VERSION
                                   (0006) ;
                                   (0007) ;  Version: 0.85
                                   (0008) ;  Revised: June 22, 2004
                                   (0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;
                                   (0011) ;  This file is generated by the Device Editor on Application Generation.
                                   (0012) ;  It contains code which loads the configuration data table generated in
                                   (0013) ;  the file PSoCConfigTBL.asm
                                   (0014) ;
                                   (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0016) ;  Edits to this file will not be preserved.
                                   (0017) ;==========================================================================
                                   (0018) ;
                                   (0019) include "m8c.inc"
                                   (0020) include "memory.inc"
                                   (0021) include "GlobalParams.inc"
                                   (0022) 
                                   (0023) export LoadConfigInit
                                   (0024) export _LoadConfigInit
                                   (0025) export LoadConfig_usb_uart_um
                                   (0026) export _LoadConfig_usb_uart_um
                                   (0027) 
                                   (0028) export NO_SHADOW
                                   (0029) export _NO_SHADOW
                                   (0030) 
                                   (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0033) 
                                   (0034) AREA psoc_config(rom, rel)
                                   (0035) 
                                   (0036) 
                                   (0037) ;---------------------------------------------------------------------------
                                   (0038) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0039) ;                  parameters handled by boot code, like CPU speed). This
                                   (0040) ;                  function can be called from user code, but typically it
                                   (0041) ;                  is only called from boot.
                                   (0042) ;
                                   (0043) ;       INPUTS: None.
                                   (0044) ;      RETURNS: Nothing.
                                   (0045) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0046) ;               In the large memory model currently only the page
                                   (0047) ;               pointer registers listed below are modified.  This does
                                   (0048) ;               not guarantee that in future implementations of this
                                   (0049) ;               function other page pointer registers will not be
                                   (0050) ;               modified.
                                   (0051) ;          
                                   (0052) ;               Page Pointer Registers Modified: 
                                   (0053) ;               CUR_PP
                                   (0054) ;
                                   (0055) _LoadConfigInit:
                                   (0056)  LoadConfigInit:
                                   (0057)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0058)     
03AF: 7C 03 B3 LCALL 0x03B3        (0059) 	lcall	LoadConfig_usb_uart_um
                                   (0060) 
                                   (0061) 
                                   (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
03B2: 7F       RET                 (0063)     ret
                                   (0064) 
                                   (0065) ;---------------------------------------------------------------------------
                                   (0066) ; Load Configuration usb_uart_um
                                   (0067) ;
                                   (0068) ;    Load configuration registers for usb_uart_um.
                                   (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0070) ;
                                   (0071) ;       INPUTS: None.
                                   (0072) ;      RETURNS: Nothing.
                                   (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0074) ;               modified as may the Page Pointer registers!
                                   (0075) ;               In the large memory model currently only the page
                                   (0076) ;               pointer registers listed below are modified.  This does
                                   (0077) ;               not guarantee that in future implementations of this
                                   (0078) ;               function other page pointer registers will not be
                                   (0079) ;               modified.
                                   (0080) ;          
                                   (0081) ;               Page Pointer Registers Modified: 
                                   (0082) ;               CUR_PP
                                   (0083) ;
                                   (0084) _LoadConfig_usb_uart_um:
                                   (0085)  LoadConfig_usb_uart_um:
                                   (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
03B3: 7C 02 0E LCALL 0x020E        (0087)     lcall   LoadConfigTBL_usb_uart_um            ; Call load config table routine
                                   (0088) 
                                   (0089) 
03B6: 70 EF    AND   F,239         (0090)     M8C_SetBank0                    ; Force return to bank 0
                                   (0091)     RAM_EPILOGUE RAM_USE_CLASS_4
03B8: 7F       RET                 (0092)     ret
03B9: 01 02    ADD   A,2
03BB: 04 08    ADD   [8],A
03BD: 10       PUSH  X

FILE: lib\usbuart_std.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USBUART_std.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/10/20 at 16:08:45
                                   (0005) ;;  Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices.
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "USBUART_macros.inc"
                                   (0025) include "USBUART.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ;  Constant Data Allocation
                                   (0029) ;-----------------------------------------------
                                   (0030) AREA UserModules (ROM, REL)
                                   (0031) EXPORT USBUART_USB_EP_BIT_LOOKUP
                                   (0032) .LITERAL
                                   (0033) USBUART_USB_EP_BIT_LOOKUP:  ;
                                   (0034)     DB     01H                       ; EP0
                                   (0035)     DB     02H                       ; EP1
                                   (0036)     DB     04H                       ; EP2
                                   (0037)     DB     08H                       ; EP3
                                   (0038)     DB     010H                      ; EP4
                                   (0039) .ENDLITERAL
                                   (0040) 
                                   (0041) ;-----------------------------------------------------------------------------
                                   (0042) ;  FUNCTION NAME: USBUART_Not_Supported
                                   (0043) ;
                                   (0044) ;  DESCRIPTION:
                                   (0045) ;
                                   (0046) ;-----------------------------------------------------------------------------
                                   (0047) ;
                                   (0048) ;  ARGUMENTS:
                                   (0049) ;
                                   (0050) ;  RETURNS:
                                   (0051) ;
                                   (0052) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0053) ;
                                   (0054) ;  THEORY of OPERATION or PROCEDURE:
                                   (0055) ;
                                   (0056) ;-----------------------------------------------------------------------------
                                   (0057) 
                                   (0058) ; d2h_std_dev
                                   (0059) IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                                   (0060) export  USBUART_CB_d2h_std_dev_00
                                   (0061) USBUART_CB_d2h_std_dev_00:
                                   (0062) ENDIF
                                   (0063) IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                                   (0064) export  USBUART_CB_d2h_std_dev_01
                                   (0065) USBUART_CB_d2h_std_dev_01:
                                   (0066) ENDIF
                                   (0067) IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                                   (0068) export  USBUART_CB_d2h_std_dev_02
                                   (0069) USBUART_CB_d2h_std_dev_02:
                                   (0070) ENDIF
                                   (0071) IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                                   (0072) export  USBUART_CB_d2h_std_dev_03
                                   (0073) USBUART_CB_d2h_std_dev_03:
                                   (0074) ENDIF
                                   (0075) IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                                   (0076) export  USBUART_CB_d2h_std_dev_04
                                   (0077) USBUART_CB_d2h_std_dev_04:
                                   (0078) ENDIF
                                   (0079) IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                                   (0080) export  USBUART_CB_d2h_std_dev_05
                                   (0081) USBUART_CB_d2h_std_dev_05:
                                   (0082) ENDIF
                                   (0083) IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                                   (0084) export  USBUART_CB_d2h_std_dev_06
                                   (0085) USBUART_CB_d2h_std_dev_06:
                                   (0086) ENDIF
                                   (0087) IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                                   (0088) export  USBUART_CB_d2h_std_dev_07
                                   (0089) USBUART_CB_d2h_std_dev_07:
                                   (0090) ENDIF
                                   (0091) IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                                   (0092) export  USBUART_CB_d2h_std_dev_08
                                   (0093) USBUART_CB_d2h_std_dev_08:
                                   (0094) ENDIF
                                   (0095) 
                                   (0096) ; h2d_std_dev
                                   (0097) IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                                   (0098) export  USBUART_CB_h2d_std_dev_00
                                   (0099) USBUART_CB_h2d_std_dev_00:
                                   (0100) ENDIF
                                   (0101) IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                                   (0102) export  USBUART_CB_h2d_std_dev_01
                                   (0103) USBUART_CB_h2d_std_dev_01:
                                   (0104) ENDIF
                                   (0105) IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                                   (0106) export  USBUART_CB_h2d_std_dev_02
                                   (0107) USBUART_CB_h2d_std_dev_02:
                                   (0108) ENDIF
                                   (0109) IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                                   (0110) export  USBUART_CB_h2d_std_dev_03
                                   (0111) USBUART_CB_h2d_std_dev_03:
                                   (0112) ENDIF
                                   (0113) IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                                   (0114) export  USBUART_CB_h2d_std_dev_04
                                   (0115) USBUART_CB_h2d_std_dev_04:
                                   (0116) ENDIF
                                   (0117) IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                                   (0118) export  USBUART_CB_h2d_std_dev_05
                                   (0119) USBUART_CB_h2d_std_dev_05:
                                   (0120) ENDIF
                                   (0121) IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                                   (0122) export  USBUART_CB_h2d_std_dev_06
                                   (0123) USBUART_CB_h2d_std_dev_06:
                                   (0124) ENDIF
                                   (0125) IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                                   (0126) export  USBUART_CB_h2d_std_dev_07
                                   (0127) USBUART_CB_h2d_std_dev_07:
                                   (0128) ENDIF
                                   (0129) IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                                   (0130) export  USBUART_CB_h2d_std_dev_08
                                   (0131) USBUART_CB_h2d_std_dev_08:
                                   (0132) ENDIF
                                   (0133) IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                                   (0134) export  USBUART_CB_h2d_std_dev_09
                                   (0135) USBUART_CB_h2d_std_dev_09:
                                   (0136) ENDIF
                                   (0137) 
                                   (0138) ; d2h_std_ifc
                                   (0139) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                                   (0140) export  USBUART_CB_d2h_std_ifc_00
                                   (0141) USBUART_CB_d2h_std_ifc_00:
                                   (0142) ENDIF
                                   (0143) IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                                   (0144) export  USBUART_CB_d2h_std_ifc_01
                                   (0145) USBUART_CB_d2h_std_ifc_01:
                                   (0146) ENDIF
                                   (0147) IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                                   (0148) export  USBUART_CB_d2h_std_ifc_02
                                   (0149) USBUART_CB_d2h_std_ifc_02:
                                   (0150) ENDIF
                                   (0151) IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                                   (0152) export  USBUART_CB_d2h_std_ifc_03
                                   (0153) USBUART_CB_d2h_std_ifc_03:
                                   (0154) ENDIF
                                   (0155) IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                                   (0156) export  USBUART_CB_d2h_std_ifc_04
                                   (0157) USBUART_CB_d2h_std_ifc_04:
                                   (0158) ENDIF
                                   (0159) IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                                   (0160) export  USBUART_CB_d2h_std_ifc_05
                                   (0161) USBUART_CB_d2h_std_ifc_05:
                                   (0162) ENDIF
                                   (0163) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                                   (0164) export  USBUART_CB_d2h_std_ifc_06
                                   (0165) USBUART_CB_d2h_std_ifc_06:
                                   (0166) ENDIF
                                   (0167) IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                                   (0168) export  USBUART_CB_d2h_std_ifc_07
                                   (0169) USBUART_CB_d2h_std_ifc_07:
                                   (0170) ENDIF
                                   (0171) IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                                   (0172) export  USBUART_CB_d2h_std_ifc_08
                                   (0173) USBUART_CB_d2h_std_ifc_08:
                                   (0174) ENDIF
                                   (0175) IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                                   (0176) export  USBUART_CB_d2h_std_ifc_09
                                   (0177) USBUART_CB_d2h_std_ifc_09:
                                   (0178) ENDIF
                                   (0179) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                                   (0180) export  USBUART_CB_d2h_std_ifc_10
                                   (0181) USBUART_CB_d2h_std_ifc_10:
                                   (0182) ENDIF
                                   (0183) 
                                   (0184) ; d2h_std_ifc
                                   (0185) IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                                   (0186) export  USBUART_CB_h2d_std_ifc_00
                                   (0187) USBUART_CB_h2d_std_ifc_00:
                                   (0188) ENDIF
                                   (0189) 
                                   (0190) ; d2h_std_ep
                                   (0191) IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                                   (0192) export  USBUART_CB_d2h_std_ep_00
                                   (0193) USBUART_CB_d2h_std_ep_00:
                                   (0194) ENDIF
                                   (0195) 
                                   (0196) ; h2d_std_ep
                                   (0197) IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                                   (0198) export  USBUART_CB_h2d_std_ep_00
                                   (0199) USBUART_CB_h2d_std_ep_00:
                                   (0200) ENDIF
                                   (0201) IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                                   (0202) export  USBUART_CB_h2d_std_ep_01
                                   (0203) USBUART_CB_h2d_std_ep_01:
                                   (0204) ENDIF
                                   (0205) IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                                   (0206) export  USBUART_CB_h2d_std_ep_02
                                   (0207) USBUART_CB_h2d_std_ep_02:
                                   (0208) ENDIF
                                   (0209) IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                                   (0210) export  USBUART_CB_h2d_std_ep_03
                                   (0211) USBUART_CB_h2d_std_ep_03:
                                   (0212) ENDIF
                                   (0213) 
                                   (0214) export  USBUART_Not_Supported
                                   (0215) export _USBUART_Not_Supported
                                   (0216) USBUART_Not_Supported:
                                   (0217) _USBUART_Not_Supported:
03BE: 50 00    MOV   A,0           (0218)    MOV    A, 0                         ; Count 0
03C0: 57 03    MOV   X,3           (0219)    MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
03C2: 7D 06 8B LJMP  0x068B        (0220)    LJMP   USBUART_EP0_UPD_MODE_EXIT
03C5: 00       SWI   
03C6: 01 00    ADD   A,0
03C8: 02 00    ADD   A,[0]
03CA: 0C 00    ADC   [0],A
03CC: 00       SWI   
03CD: DE 55    JNC   0x0223
                                   (0221) ;-----------------------------------------------------------------------------
                                   (0222) ;  FUNCTION NAME: USBUART_CB_d2h_std_dev_00
                                   (0223) ;
                                   (0224) ;  DESCRIPTION:   Get Device Status
                                   (0225) ;
                                   (0226) ;****************************************************************
                                   (0227) ; STANDARD DEVICE IN REQUEST: Get_Device_Status
                                   (0228) ;****************************************************************
                                   (0229) ;
                                   (0230) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h     
                                   (0231) ; bRequest       : GET_STATUS                     = 00h    
                                   (0232) ; wValue         : RESERVED                       = 0000h  
                                   (0233) ; wIndex         : RESERVED                       = 0000h
                                   (0234) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
                                   (0235) ; 
                                   (0236) ; The GET_DEVICE_STATUS request returns the current device status.
                                   (0237) ;
                                   (0238) ;****************************************************************
                                   (0239) ;-----------------------------------------------------------------------------
                                   (0240) ;
                                   (0241) ;  ARGUMENTS:
                                   (0242) ;
                                   (0243) ;  RETURNS:
                                   (0244) ;
                                   (0245) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0246) ;
                                   (0247) ;  THEORY of OPERATION or PROCEDURE:
                                   (0248) ;
                                   (0249) ;-----------------------------------------------------------------------------
                                   (0250) IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                                   (0251) .LITERAL
                                   (0252) GetStatusTransferDescrTable:
                                   (0253)     TD_START_TABLE 1                   ; One entry
                                   (0254)     TD_ENTRY    USB_DS_RAM, 2, USBUART_TransferBuffer, NULL_PTR  ; Intermediate Buffer
                                   (0255) .ENDLITERAL
                                   (0256) export  USBUART_CB_d2h_std_dev_00
                                   (0257) USBUART_CB_d2h_std_dev_00:
03CF: 23 00    AND   A,[X+0]       (0258)     MOV     [USBUART_t2], 0            ; Use the UM temp var--Selector
                                   (0259) 
03D1: 55 0D 00 MOV   [13],0        (0260)     MOV     [USBUART_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
03D4: 5F 0C 02 MOV   [12],[2]      (0261)     MOV     [USBUART_TransferBuffer], [USBUART_DeviceStatus]
                                   (0262) 
03D7: 50 03    MOV   A,3           (0263)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
03D9: 57 C5    MOV   X,197         (0264)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
03DB: 82 8E    JMP   0x066A        (0265)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0266) ENDIF
                                   (0267) ;-----------------------------------------------------------------------------
                                   (0268) ; FUNCTION NAME: USBUART_CB_d2h_std_dev_06
                                   (0269) ;
                                   (0270) ; DESCRIPTION:   Get Device Descriptor
                                   (0271) ;
                                   (0272) ;****************************************************************
                                   (0273) ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                                   (0274) ;****************************************************************
                                   (0275) ;
                                   (0276) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                   (0277) ; bRequest       : GET_DESCRIPTOR                 = 06h    
                                   (0278) ; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh  
                                   (0279) ; wIndex         : ZERO or LANG_ID                = xxxxh
                                   (0280) ; wLength        : SIZEOF_DESCRIPTOR              = --xxh  
                                   (0281) ; 
                                   (0282) ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if 
                                   (0283) ; the descriptor exists. 
                                   (0284) ; 
                                   (0285) ; The upper byte of wValue contains the descriptor type and 
                                   (0286) ; the lower byte contains the descriptor index. wIndex 
                                   (0287) ; contains either 0000h or the Language ID. wLength contains 
                                   (0288) ; the descriptor length. The actual descriptor information is 
                                   (0289) ; transferred in subsequent data packets. 
                                   (0290) ;
                                   (0291) ;****************************************************************
                                   (0292) ;
                                   (0293) ;-----------------------------------------------------------------------------
                                   (0294) ;
                                   (0295) ;  ARGUMENTS:
                                   (0296) ;
                                   (0297) ;  RETURNS:
                                   (0298) ;
                                   (0299) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0300) ;
                                   (0301) ;  THEORY of OPERATION or PROCEDURE:
                                   (0302) ;
                                   (0303) ;-----------------------------------------------------------------------------
                                   (0304) IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                                   (0305) export  USBUART_CB_d2h_std_dev_06
                                   (0306) USBUART_CB_d2h_std_dev_06:
                                   (0307) ;-----------------------------------------------------------------------------
                                   (0308) ; Dispatch to the proper handler
                                   (0309) ;-----------------------------------------------------------------------------
03DD: 5D 5B    MOV   A,REG[91]     (0310)     MOV     A, REG[USBUART_EP0DATA+wValueHi] ; Get the descriptor type
03DF: 64       ASL   A             (0311)     ASL     A                          ; Make it into a offset
03E0: 39 08    CMP   A,8           (0312)     CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
03E2: DF DB    JNC   0x03BE        (0313)     JNC     USBUART_Not_Supported
                                   (0314) 
03E4: E0 01    JACC  0x03E6        (0315)     JACC    GET_DESCR_DISPATCH
                                   (0316) 
                                   (0317) GET_DESCR_DISPATCH:
03E6: 8F D7    JMP   0x03BE        (0318)     JMP     USBUART_Not_Supported      ; Invalid
03E8: 80 28    JMP   0x0411        (0319)     JMP     USBUART_SendDeviceDescr    ; Device Descriptor
03EA: 80 03    JMP   0x03EE        (0320)     JMP     USBUART_SendConfigDescr    ; Configuration Descriptor
                                   (0321) IF  USBUART_bNumStringDescrs           ; Number of String Descriptor defined with the Wizard
03EC: 80 34    JMP   0x0421        (0322)     JMP     USBUART_SendStringDescr    ; String Descriptor
                                   (0323) ELSE
                                   (0324)     JMP     USBUART_Not_Supported      ; Not supported if we don't have
                                   (0325)                                             ; any String Descriptor
                                   (0326) ENDIF
                                   (0327) 
                                   (0328) GET_DESCR_DISPATCH_END:
                                   (0329) GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)     
                                   (0330) ;-----------------------------------------------------------------------------
                                   (0331) ; Configuration Descriptor Handler
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) USBUART_SendConfigDescr:
03EE: 94 60    CALL  0x0850        (0334)     CALL    USBUART_GET_DEVICE_TABLE_ENTRY
03F0: 4B       SWAP  A,X           (0335)     SWAP    A, X
03F1: 01 02    ADD   A,2           (0336)     ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
03F3: 4B       SWAP  A,X           (0337)     SWAP    A, X
03F4: 09 00    ADC   A,0           (0338)     ADC     A, 0                       ; Don't forget the carry
03F6: 55 23 24 MOV   [35],36       (0339)     MOV    [USBUART_t2], USBUART_t1    ; Set up the destination  
03F9: 94 44    CALL  0x083F        (0340)     CALL    USBUART_GETWORD            ; Get the pointer
                                   (0341)     
03FB: 51 24    MOV   A,[36]        (0342)     MOV     A, [USBUART_t1]            ; Pointer MSB
03FD: 58 25    MOV   X,[37]        (0343)     MOV     X, [USBUART_t1+1]          ; Pointer LSB
                                   (0344)     
03FF: 08       PUSH  A             (0345)     PUSH    A                          ; Save the MSB
                                   (0346)     
0400: 5D 5A    MOV   A,REG[90]     (0347)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the descriptor index
0402: 53 23    MOV   [35],A        (0348)     MOV     [USBUART_t2], A            ; Use the UM temp var--Selector
0404: 18       POP   A             (0349)     POP     A                          ; Need the MSB for the range check
0405: 08       PUSH  A             (0350)     PUSH    A                          ; Save the MSB for after the range check
0406: 28       ROMX                (0351)     ROMX                               ; First entry is the table size (only a byte)
0407: 3A 23    CMP   A,[35]        (0352)     CMP     A, [USBUART_t2]            ; Range check
0409: D0 04    JNC   0x040E        (0353)     JNC     .range_ok
                                   (0354)     
040B: 18       POP   A             (0355)     POP     A                          ; Fix the stack
040C: 8F B1    JMP   0x03BE        (0356)     JMP    USBUART_Not_Supported
                                   (0357) 
                                   (0358) .range_ok:
040E: 18       POP   A             (0359)     POP     A                          ; Get the MSB back
040F: 82 5A    JMP   0x066A        (0360)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0361) ;-----------------------------------------------------------------------------
                                   (0362) ; Device Descriptor Handler
                                   (0363) ;-----------------------------------------------------------------------------
                                   (0364) USBUART_SendDeviceDescr:
0411: 5F 23 00 MOV   [35],[0]      (0365)     MOV     [USBUART_t2], [USBUART_bCurrentDevice]  ; Use the UM temp var--Selector
0414: 50 02    MOV   A,2           (0366)     MOV     A,>USBUART_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
0416: 57 05    MOV   X,5           (0367)     MOV     X,<USBUART_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
0418: 28       ROMX                (0368)     ROMX                               ; First entry is the table size (only a byte)
0419: 3A 23    CMP   A,[35]        (0369)     CMP     A, [USBUART_t2]            ; Range check
041B: CF A2    JC    0x03BE        (0370)     JC      USBUART_Not_Supported
                                   (0371) 
041D: 50 02    MOV   A,2           (0372)     MOV     A,>USBUART_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
                                   (0373) 
041F: 82 4A    JMP   0x066A        (0374)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0375) ;-----------------------------------------------------------------------------
                                   (0376) ; String Descriptor Handler
                                   (0377) ;-----------------------------------------------------------------------------
                                   (0378) IF  USBUART_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
                                   (0379) USBUART_SendStringDescr:
0421: 5D 5A    MOV   A,REG[90]     (0380)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the descriptor index
0423: 53 23    MOV   [35],A        (0381)     MOV     [USBUART_t2], A            ; Use the UM temp var--Selector
                                   (0382) 
0425: 50 09    MOV   A,9           (0383)     MOV     A,>USBUART_StringTable     ; Get the ROM Address MSB
0427: 57 41    MOV   X,65          (0384)     MOV     X,<USBUART_StringTable     ; Get the ROM Address LSB
0429: 28       ROMX                (0385)     ROMX                               ; First entry is the table size (only a byte)
042A: 3A 23    CMP   A,[35]        (0386)     CMP     A, [USBUART_t2]            ; Range check
042C: CF 91    JC    0x03BE        (0387)     JC      USBUART_Not_Supported
                                   (0388) 
042E: 50 09    MOV   A,9           (0389)     MOV     A,>USBUART_StringTable     ; Get the ROM Address MSB
                                   (0390) 
0430: 82 39    JMP   0x066A        (0391)     JMP     USBUART_GetTableEntry_Local_Std
0432: 00       SWI   
0433: 01 00    ADD   A,0
0435: 01 00    ADD   A,0
0437: 01 00    ADD   A,0
0439: 00       SWI   
043A: DE 55    JNC   0x0290
                                   (0392) ENDIF
                                   (0393) ENDIF
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;  FUNCTION NAME: USBUART_CB_d2h_std_dev_08
                                   (0396) ;
                                   (0397) ;  DESCRIPTION:   Get Device Configuration
                                   (0398) ;
                                   (0399) ;****************************************************************
                                   (0400) ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                                   (0401) ;****************************************************************
                                   (0402) ;
                                   (0403) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                   (0404) ; bRequest       : GET_CONFIGURATION              = 08h    
                                   (0405) ; wValue         : RESERVED                       = 0000h  
                                   (0406) ; wIndex         : RESERVED                       = 0000h
                                   (0407) ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h  
                                   (0408) ; 
                                   (0409) ; The GET_DEVICE_CONFIGURATION request returns the currently 
                                   (0410) ; selected device configuration number. 
                                   (0411) ;
                                   (0412) ; request_value and request_index contain 0000h. request_length 
                                   (0413) ; contains 0001h and the one-byte configuration number is returned 
                                   (0414) ; in a separate data transfer.
                                   (0415) ;
                                   (0416) ;-----------------------------------------------------------------------------
                                   (0417) ;
                                   (0418) ;  ARGUMENTS:
                                   (0419) ;
                                   (0420) ;  RETURNS:
                                   (0421) ;
                                   (0422) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0423) ;
                                   (0424) ;  THEORY of OPERATION or PROCEDURE:
                                   (0425) ;
                                   (0426) ;-----------------------------------------------------------------------------
                                   (0427) IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
                                   (0428) .LITERAL
                                   (0429) GetConfigTransferDescrTable:
                                   (0430)     TD_START_TABLE  1                  ; One entry
                                   (0431)     TD_ENTRY    USB_DS_RAM, 1, USBUART_Configuration, NULL_PTR  ; Current configuration
                                   (0432) .ENDLITERAL
                                   (0433) export  USBUART_CB_d2h_std_dev_08
                                   (0434) USBUART_CB_d2h_std_dev_08:
043C: 23 00    AND   A,[X+0]       (0435)     MOV     [USBUART_t2], 0            ; Use the UM temp var--Selector
043E: 50 04    MOV   A,4           (0436)     MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
0440: 57 32    MOV   X,50          (0437)     MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
0442: 82 27    JMP   0x066A        (0438)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0439) ENDIF
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: USBUART_CB_h2d_std_dev_01
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:   Clear Device Feature
                                   (0444) ;
                                   (0445) ;****************************************************************
                                   (0446) ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                                   (0447) ;****************************************************************
                                   (0448) ;
                                   (0449) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0450) ; bRequest       : CLEAR_FEATURE                  = 01h    
                                   (0451) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                   (0452) ; wIndex         : RESERVED                       = 0000h
                                   (0453) ; wLength        : RESERVED                       = 0000h  
                                   (0454) ; 
                                   (0455) ; The CLEAR_DEVICE_FEATURE request disables a particular feature 
                                   (0456) ; for a device. The only feature supported for a device is the 
                                   (0457) ; REMOTE_WAKEUP feature.
                                   (0458) ; 
                                   (0459) ;****************************************************************
                                   (0460) ;-----------------------------------------------------------------------------
                                   (0461) ;
                                   (0462) ;  ARGUMENTS:
                                   (0463) ;
                                   (0464) ;  RETURNS:
                                   (0465) ;
                                   (0466) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0467) ;
                                   (0468) ;  THEORY of OPERATION or PROCEDURE:
                                   (0469) ;
                                   (0470) ;-----------------------------------------------------------------------------
                                   (0471) IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                                   (0472) export  USBUART_CB_h2d_std_dev_01
                                   (0473) USBUART_CB_h2d_std_dev_01:
0444: 5D 5A    MOV   A,REG[90]     (0474)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the Feature Selector
                                   (0475)                                        ; Check against valid features
                                   (0476)                                        ;  for device recipient
0446: 39 01    CMP   A,1           (0477)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
0448: BF 75    JNZ   0x03BE        (0478)     JNZ     USBUART_Not_Supported      ;      
044A: 26 02 FD AND   [2],253       (0479)     AND     [USBUART_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
044D: 82 1F    JMP   0x066D        (0480)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
                                   (0481) ENDIF
                                   (0482) ;-----------------------------------------------------------------------------
                                   (0483) ;  FUNCTION NAME: USBUART_CB_h2d_std_dev_03
                                   (0484) ;
                                   (0485) ;  DESCRIPTION:   Set Device Feature
                                   (0486) ;
                                   (0487) ;****************************************************************
                                   (0488) ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                                   (0489) ;****************************************************************
                                   (0490) ;
                                   (0491) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0492) ; bRequest       : SET_FEATURE                    = 03h    
                                   (0493) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                   (0494) ; wIndex         : RESERVED                       = 0000h
                                   (0495) ; wLength        : RESERVED                       = 0000h  
                                   (0496) ; 
                                   (0497) ; The SET_DEVICE_FEATURE request enables a particular feature
                                   (0498) ; on a device. The only feature supported for a device is the 
                                   (0499) ; REMOTE_WAKEUP feature.
                                   (0500) ;
                                   (0501) ;****************************************************************
                                   (0502) ;-----------------------------------------------------------------------------
                                   (0503) ;
                                   (0504) ;  ARGUMENTS:
                                   (0505) ;
                                   (0506) ;  RETURNS:
                                   (0507) ;
                                   (0508) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0509) ;
                                   (0510) ;  THEORY of OPERATION or PROCEDURE:
                                   (0511) ;
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                                   (0514) export  USBUART_CB_h2d_std_dev_03
                                   (0515) USBUART_CB_h2d_std_dev_03:
044F: 5D 5A    MOV   A,REG[90]     (0516)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the Feature Selector
                                   (0517)                                        ; Check against valid features
                                   (0518)                                        ;  for device recipient
0451: 39 01    CMP   A,1           (0519)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
0453: A0 07    JZ    0x045B        (0520)     JZ      .remote_wakeup
                                   (0521) 
0455: 39 02    CMP   A,2           (0522)     CMP     A, USB_TEST_MODE           ; Test Mode 
0457: A0 08    JZ    0x0460        (0523)     JZ      .test_mode
                                   (0524) ; Flow here for any other selector is invalid for device recipient
0459: 8F 64    JMP   0x03BE        (0525)     JMP     USBUART_Not_Supported
                                   (0526) ; Jump here to enable remote wake up
                                   (0527) .remote_wakeup:
045B: 2E 02 02 OR    [2],2         (0528)     OR      [USBUART_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
045E: 80 03    JMP   0x0462        (0529)     JMP     .finish
                                   (0530) ; Jump here to enable test mode
                                   (0531) .test_mode:
0460: 8F 5D    JMP   0x03BE        (0532)     JMP     USBUART_Not_Supported
                                   (0533) .finish:
0462: 82 0A    JMP   0x066D        (0534)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
                                   (0535) ENDIF
                                   (0536) ;-----------------------------------------------------------------------------
                                   (0537) ;  FUNCTION NAME: USBUART_CB_h2d_std_dev_05
                                   (0538) ;
                                   (0539) ;  DESCRIPTION:   Set Device Address
                                   (0540) ;
                                   (0541) ;****************************************************************
                                   (0542) ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                                   (0543) ;****************************************************************
                                   (0544) ;
                                   (0545) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0546) ; bRequest       : SET_ADDRESS                    = 05h    
                                   (0547) ; wValue         : DEVICE_ADDRESS                 = 00xxh  
                                   (0548) ; wIndex         : RESERVED                       = 0000h
                                   (0549) ; wLength        : RESERVED                       = 0000h  
                                   (0550) ; 
                                   (0551) ; The SET_DEVICE_ADDRESS request sets the USB device address
                                   (0552) ; for all future USB accesses. 
                                   (0553) ;
                                   (0554) ;****************************************************************
                                   (0555) ;
                                   (0556) ;-----------------------------------------------------------------------------
                                   (0557) ;
                                   (0558) ;  ARGUMENTS:
                                   (0559) ;
                                   (0560) ;  RETURNS:
                                   (0561) ;
                                   (0562) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0563) ;
                                   (0564) ;  THEORY of OPERATION or PROCEDURE:
                                   (0565) ;
                                   (0566) ;-----------------------------------------------------------------------------
                                   (0567) 
                                   (0568) IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                                   (0569) export  USBUART_CB_h2d_std_dev_05
                                   (0570) USBUART_CB_h2d_std_dev_05:
                                   (0571)       
0464: 55 22 01 MOV   [34],1        (0572)     MOV     [USBUART_fDataPending], USB_ADDRESS_CHANGE_PENDING       
0467: 5D 5A    MOV   A,REG[90]     (0573)     MOV     A, REG[USBUART_EP0DATA+wValueLo]       
0469: 53 0C    MOV   [12],A        (0574)     MOV     [USBUART_TransferBuffer],A       
                                   (0575)                                                    
046B: 82 01    JMP   0x066D        (0576)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
                                   (0577) ENDIF
                                   (0578) 
                                   (0579) 
                                   (0580) ;-----------------------------------------------------------------------------
                                   (0581) ;  FUNCTION NAME: USBUART_CB_h2d_std_dev_09
                                   (0582) ;
                                   (0583) ;  DESCRIPTION:   Set Configuration
                                   (0584) ;
                                   (0585) ;****************************************************************
                                   (0586) ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                                   (0587) ;****************************************************************
                                   (0588) ;
                                   (0589) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                   (0590) ; bRequest       : SET_CONFIGURATION              = 09h    
                                   (0591) ; wValue         : CONFIGURATION_VALUE            = --xxh  
                                   (0592) ; wIndex         : RESERVED                       = 0000h
                                   (0593) ; wLength        : RESERVED                       = 0000h  
                                   (0594) ; 
                                   (0595) ; The SET_DEVICE_CONFIGURATION request selects a device 
                                   (0596) ; configuration to be activated as the current configuration. 
                                   (0597) ;
                                   (0598) ;****************************************************************
                                   (0599) ;-----------------------------------------------------------------------------
                                   (0600) ;
                                   (0601) ;  ARGUMENTS:
                                   (0602) ;
                                   (0603) ;  RETURNS:
                                   (0604) ;
                                   (0605) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0606) ;
                                   (0607) ;  THEORY of OPERATION or PROCEDURE:
                                   (0608) ;
                                   (0609) ;-----------------------------------------------------------------------------
                                   (0610) 
                                   (0611) IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                                   (0612) export  USBUART_CB_h2d_std_dev_09
                                   (0613) USBUART_CB_h2d_std_dev_09:
046D: 93 E1    CALL  0x0850        (0614)     CALL    USBUART_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
046F: 55 23 24 MOV   [35],36       (0615)     MOV     [USBUART_t2],USBUART_t1    ; Set the GETWORD destination 
0472: 93 CB    CALL  0x083F        (0616)     CALL    USBUART_GETWORD            ; Get the pointer to the CONFIG_LOOKUP table
                                   (0617)                                        ; ITempW has the address
0474: 5D 5A    MOV   A,REG[90]     (0618)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the configuration number
0476: 53 23    MOV   [35],A        (0619)     MOV     [USBUART_t2],A             ; Save it 
0478: 51 24    MOV   A,[36]        (0620)     MOV     A, [USBUART_t1]            ; Get the CONFIG_LOOKUP ROM Address MSB
047A: 58 25    MOV   X,[37]        (0621)     MOV     X, [USBUART_t1+1]          ; Get the CONFIG_LOOKUP ROM Address LSB
047C: 28       ROMX                (0622)     ROMX                               ; First entry is the table size (only a byte)
047D: 3A 23    CMP   A,[35]        (0623)     CMP     A, [USBUART_t2]            ; Range check
047F: CF 3E    JC    0x03BE        (0624)     JC      USBUART_Not_Supported
                                   (0625) 
                                   (0626) ; Refactored from the two loops below
0481: 5F 01 23 MOV   [1],[35]      (0627)     MOV     [USBUART_Configuration],[USBUART_t2]  ; Save the config number
                                   (0628) 
0484: 3C 23 00 CMP   [35],0        (0629)     CMP     [USBUART_t2], 0            ; Unconfigure?
0487: A0 25    JZ    0x04AD        (0630)     JZ      .unconfigure
                                   (0631) 
                                   (0632) ; Flow here to configure the endpoints
0489: 51 24    MOV   A,[36]        (0633)     MOV     A, [USBUART_t1]            ; Get the CONFIG_LOOKUP ROM Address MSB
048B: 58 25    MOV   X,[37]        (0634)     MOV     X, [USBUART_t1+1]          ; Get the CONFIG_LOOKUP ROM Address LSB
048D: 75       INC   X             (0635)     INC     X                          ; Point to the first table entry
048E: 09 00    ADC   A,0           (0636)     ADC     A, 0                       ;
0490: 55 23 24 MOV   [35],36       (0637)     MOV    [USBUART_t2], USBUART_t1    ; Set up the destination  
0493: 93 AA    CALL  0x083F        (0638)     CALL    USBUART_GETWORD            ; Get the pointer to the CONFIG_LOOKUP table
                                   (0639)                                        ; ITempW has the address
0495: 57 00    MOV   X,0           (0640)     MOV     X, 0                       ; Start the index at 0, but we INC first
                                   (0641) .configure_next:
0497: 75       INC   X             (0642)     INC     X                          ; Do the next one
0498: 10       PUSH  X             (0643)     PUSH    X                          ; Save the endpoint number
0499: 51 24    MOV   A,[36]        (0644)     MOV     A, [USBUART_t1]            ; Get the CONFIG_LOOKUP ROM Address MSB
049B: 58 25    MOV   X,[37]        (0645)     MOV     X, [USBUART_t1+1]          ; Get the CONFIG_LOOKUP ROM Address LSB
049D: 28       ROMX                (0646)     ROMX
049E: 76 25    INC   [37]          (0647)     INC     [USBUART_t1+1]             ; Point to the next 
04A0: 0E 24 00 ADC   [36],0        (0648)     ADC     [USBUART_t1], 0            ;
04A3: 20       POP   X             (0649)     POP     X
04A4: 90 B8    CALL  0x055E        (0650)     CALL    ConfigureEP                ; X contains the EP number
                                   (0651)                                        ; A contains the EP Direction
04A6: 5B       MOV   A,X           (0652)     MOV     A, X                       ; 
04A7: 39 04    CMP   A,4           (0653)     CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
04A9: BF ED    JNZ   0x0497        (0654)     JNZ     .configure_next            ; Do another one?
                                   (0655) ; Flow here when we are done
04AB: 80 10    JMP   0x04BC        (0656)     JMP     .done
                                   (0657) 
                                   (0658) ; Jump here to unconfigure the endpoints
                                   (0659) .unconfigure:
04AD: 71 10    OR    F,16          (0660)     M8C_SetBank1	; _EP1MODE is in Bank 1
04AF: 57 04    MOV   X,4           (0661)     MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
                                   (0662) .unconfigure_next:
04B1: 56 26 02 MOV   [X+38],2      (0663)     MOV     [X+USBUART_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
04B4: 63 C3 00 MOV   REG[X+195],0  (0664)     MOV     REG[X+USBUART_EP1MODE-1], USB_MODE_DISABLE ; Disable the endpoint
04B7: 79       DEC   X             (0665)     DEC     X                          ; One more down
04B8: BF F8    JNZ   0x04B1        (0666)     JNZ     .unconfigure_next          ; Don't unconfigure EP0
04BA: 70 EF    AND   F,239         (0667) 	M8C_SetBank0
                                   (0668) .done:
04BC: 81 B0    JMP   0x066D        (0669)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
04BE: 00       SWI   
04BF: 01 00    ADD   A,0
04C1: 02 00    ADD   A,[0]
04C3: 0C 00    ADC   [0],A
04C5: 00       SWI   
04C6: DE 55    JNC   0x031C
                                   (0670) ENDIF
                                   (0671) 
                                   (0672) 
                                   (0673) ;-----------------------------------------------------------------------------
                                   (0674) ;  FUNCTION NAME: USBUART_CB_d2h_std_ifc_00
                                   (0675) ;
                                   (0676) ;  DESCRIPTION:   Get Interface Status
                                   (0677) ;
                                   (0678) ;****************************************************************
                                   (0679) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                                   (0680) ;****************************************************************
                                   (0681) ;
                                   (0682) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h    
                                   (0683) ; bRequest       : GET_STATUS                     = 00h    
                                   (0684) ; wValue         : RESERVED                       = 0000h  
                                   (0685) ; wIndex         : INTERFACE                      = --xxh
                                   (0686) ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h  
                                   (0687) ; 
                                   (0688) ; The GET_INTERFACE_STATUS request returns status for the 
                                   (0689) ; specified interface.
                                   (0690) ;
                                   (0691) ;****************************************************************
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;
                                   (0696) ;  RETURNS:
                                   (0697) ;
                                   (0698) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0699) ;
                                   (0700) ;  THEORY of OPERATION or PROCEDURE:
                                   (0701) ;
                                   (0702) ;-----------------------------------------------------------------------------
                                   (0703) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
                                   (0704) .LITERAL
                                   (0705) GetInterfaceStatusTransferDescrTable:
                                   (0706)     TD_START_TABLE  1                  ; One entry
                                   (0707)     TD_ENTRY        USB_DS_RAM, 2, USBUART_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                   (0708) .ENDLITERAL
                                   (0709) export  USBUART_CB_d2h_std_ifc_00
                                   (0710) USBUART_CB_d2h_std_ifc_00:
                                   (0711) 
04C8: 0C 00    ADC   [0],A         (0712)     MOV     [USBUART_TransferBuffer], 0     ; Zero the transfer buffer
04CA: 55 0D 00 MOV   [13],0        (0713)     MOV     [USBUART_TransferBuffer+1], 0  ; 
                                   (0714) 
04CD: 55 23 00 MOV   [35],0        (0715)     MOV     [USBUART_t2], 0            ; Use the UM temp var--Selector
04D0: 50 04    MOV   A,4           (0716)     MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
04D2: 57 BE    MOV   X,190         (0717)     MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB
                                   (0718) 
04D4: 81 95    JMP   0x066A        (0719)     JMP     USBUART_GetTableEntry_Local_Std
04D6: 00       SWI   
04D7: 01 00    ADD   A,0
04D9: 01 00    ADD   A,0
04DB: 0C 00    ADC   [0],A
04DD: 00       SWI   
04DE: DE 5D    JNC   0x033C
                                   (0720) ENDIF
                                   (0721) ;-----------------------------------------------------------------------------
                                   (0722) ;  FUNCTION NAME: USBUART_CB_d2h_std_ifc_10
                                   (0723) ;
                                   (0724) ;  DESCRIPTION:   Get Interface
                                   (0725) ;
                                   (0726) ;****************************************************************
                                   (0727) ; STANDARD INTERFACE IN REQUEST: Get_Interface
                                   (0728) ;****************************************************************
                                   (0729) ;
                                   (0730) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                   (0731) ; bRequest       : GET_INTERFACE                  = 0Ah    
                                   (0732) ; wValue         : RESERVED                       = 0000h  
                                   (0733) ; wIndex         : INTERFACE                      = xxxxh
                                   (0734) ; wLength        : SIZEOF_GET_INTERFACE           = 0001h  
                                   (0735) ; 
                                   (0736) ; The GET_INTERFACE request returns the selected alternate 
                                   (0737) ; setting for the specified interface. 
                                   (0738) ;
                                   (0739) ;****************************************************************
                                   (0740) ;-----------------------------------------------------------------------------
                                   (0741) ;
                                   (0742) ;  ARGUMENTS:
                                   (0743) ;
                                   (0744) ;  RETURNS:
                                   (0745) ;
                                   (0746) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0747) ;
                                   (0748) ;  THEORY of OPERATION or PROCEDURE:
                                   (0749) ;
                                   (0750) ;-----------------------------------------------------------------------------
                                   (0751) 
                                   (0752) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
                                   (0753) .LITERAL
                                   (0754) GetInterfaceTransferDescrTable:
                                   (0755)     TD_START_TABLE  1                  ; One entry
                                   (0756)     TD_ENTRY        USB_DS_RAM, 1, USBUART_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                   (0757) .ENDLITERAL
                                   (0758) export  USBUART_CB_d2h_std_ifc_10
                                   (0759) USBUART_CB_d2h_std_ifc_10:
04E0: 5C       MOV   X,A           (0760)     MOV     A, REG[USBUART_EP0DATA+wIndexLo]  ; Get the interface number
04E1: 39 02    CMP   A,2           (0761)     CMP     A, 2                       ; Valid interface number? (UM Parameter: NumInterfaces)
04E3: DE DA    JNC   0x03BE        (0762)     JNC     USBUART_Not_Supported
                                   (0763) 
04E5: 5C       MOV   X,A           (0764)     MOV     X, A                       ; The interface number is the index into alternates settings table
                                   (0765) 
04E6: 52 03    MOV   A,[X+3]       (0766)     MOV     A, [X + USBUART_InterfaceSetting]  ; Save the current interface setting
04E8: 53 0C    MOV   [12],A        (0767)     MOV     [USBUART_TransferBuffer], A     ; into the transfer buffer
                                   (0768) 
04EA: 55 23 00 MOV   [35],0        (0769)     MOV     [USBUART_t2], 0            ; Use the UM temp var--Selector
04ED: 50 04    MOV   A,4           (0770)     MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
04EF: 57 D6    MOV   X,214         (0771)     MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB
                                   (0772) 
04F1: 81 78    JMP   0x066A        (0773)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0774) ENDIF
                                   (0775) 
                                   (0776) 
                                   (0777) ;-----------------------------------------------------------------------------
                                   (0778) ;  FUNCTION NAME: USBUART_CB_d2h_std_ep_00
                                   (0779) ;
                                   (0780) ;  DESCRIPTION:   Get Endpoint Status
                                   (0781) ;
                                   (0782) ;****************************************************************
                                   (0783) ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                                   (0784) ;****************************************************************
                                   (0785) ;
                                   (0786) ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h    
                                   (0787) ; bRequest       : GET_STATUS                     = 00h    
                                   (0788) ; wValue         : RESERVED                       = 0000h  
                                   (0789) ; wIndex         : ENDPOINT                       = 00xxh
                                   (0790) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
                                   (0791) ; 
                                   (0792) ; The GET_ENDPOINT_STATUS request returns status for the specified 
                                   (0793) ; endpoint.
                                   (0794) ;
                                   (0795) ;****************************************************************
                                   (0796) ;-----------------------------------------------------------------------------
                                   (0797) ;
                                   (0798) ;  ARGUMENTS:
                                   (0799) ;
                                   (0800) ;  RETURNS:
                                   (0801) ;
                                   (0802) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0803) ;
                                   (0804) ;  THEORY of OPERATION or PROCEDURE:
                                   (0805) ;
                                   (0806) ;-----------------------------------------------------------------------------
                                   (0807) IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                                   (0808) export  USBUART_CB_d2h_std_ep_00
                                   (0809) USBUART_CB_d2h_std_ep_00:
04F3: 5D 5C    MOV   A,REG[92]     (0810)     MOV     A, REG[USBUART_EP0DATA+wIndexLo]  ; Get the endpoint number
04F5: 21 7F    AND   A,127         (0811)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
04F7: 39 05    CMP   A,5           (0812)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
04F9: DE C4    JNC   0x03BE        (0813)     JNC     USBUART_Not_Supported
                                   (0814) 
04FB: 5C       MOV   X,A           (0815)     MOV     X, A                       ; The endpoint number is the index
                                   (0816) 
04FC: 55 23 00 MOV   [35],0        (0817)     MOV     [USBUART_t2], 0            ; Use the UM temp var--Selector
                                   (0818) 
04FF: 55 0D 00 MOV   [13],0        (0819)     MOV     [USBUART_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
0502: 52 05    MOV   A,[X+5]       (0820)     MOV     A, [X + USBUART_EndpointStatus]  ; Get the status
0504: 53 0C    MOV   [12],A        (0821)     MOV     [USBUART_TransferBuffer], A  ; Save it in the report
                                   (0822) 
0506: 50 03    MOV   A,3           (0823)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
0508: 57 C5    MOV   X,197         (0824)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
                                   (0825) 
050A: 81 5F    JMP   0x066A        (0826)     JMP     USBUART_GetTableEntry_Local_Std
                                   (0827) ENDIF
                                   (0828) 
                                   (0829) ;-----------------------------------------------------------------------------
                                   (0830) ;  FUNCTION NAME: USBUART_CB_h2d_std_ep_01
                                   (0831) ;
                                   (0832) ;  DESCRIPTION:   Clear Endpoint Feature
                                   (0833) ;
                                   (0834) ;****************************************************************
                                   (0835) ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                                   (0836) ;****************************************************************
                                   (0837) ;
                                   (0838) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                   (0839) ; bRequest       : CLEAR_FEATURE                  = 01h    
                                   (0840) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                   (0841) ; wIndex         : ENDPOINT                       = 00xxh
                                   (0842) ; wLength        : RESERVED                       = 0000h  
                                   (0843) ; 
                                   (0844) ; The CLEAR_ENDPOINT_FEATURE request disables a particular 
                                   (0845) ; feature for an endpoint. 
                                   (0846) ;
                                   (0847) ; The only feature supported for an endpoint is the EP_HALT 
                                   (0848) ; feature.
                                   (0849) ;
                                   (0850) ;****************************************************************
                                   (0851) ;-----------------------------------------------------------------------------
                                   (0852) ;
                                   (0853) ;  ARGUMENTS:
                                   (0854) ;
                                   (0855) ;  RETURNS:
                                   (0856) ;
                                   (0857) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0858) ;
                                   (0859) ;  THEORY of OPERATION or PROCEDURE:
                                   (0860) ;
                                   (0861) ;-----------------------------------------------------------------------------
                                   (0862) IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                                   (0863) export  USBUART_CB_h2d_std_ep_01
                                   (0864) USBUART_CB_h2d_std_ep_01:
050C: 5D 5A    MOV   A,REG[90]     (0865)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the feature selector
050E: 39 00    CMP   A,0           (0866)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0510: BE AD    JNZ   0x03BE        (0867)     JNZ     USBUART_Not_Supported
                                   (0868) 
0512: 5D 5C    MOV   A,REG[92]     (0869)     MOV     A, REG[USBUART_EP0DATA+wIndexLo]  ; Get the Endpoint number
0514: 21 7F    AND   A,127         (0870)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
0516: 39 00    CMP   A,0           (0871)     CMP     A, 0                       ; Since we can't halt the Control Endpoint
0518: A0 18    JZ    0x0531        (0872)     JZ      .done
                                   (0873) 
051A: 39 05    CMP   A,5           (0874)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
051C: DE A1    JNC   0x03BE        (0875)     JNC     USBUART_Not_Supported
                                   (0876) 
051E: 5C       MOV   X,A           (0877)     MOV     X, A                       ; Endpoint number is the index
051F: 27 05 FE AND   [X+5],254     (0878)     AND     [X+USBUART_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt
                                   (0879) 
0522: 49 5C 80 TST   REG[92],128   (0880)     TST     REG[USBUART_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
0525: 71 10    OR    F,16          (0881)     M8C_SetBank1	                      ; For EP1_MODE register
0527: B0 06    JNZ   0x052E        (0882)     JNZ     .in
                                   (0883) 
0529: 63 C3 08 MOV   REG[X+195],8  (0884)     MOV     REG[X + USBUART_EP1MODE - 1], USB_MODE_NAK_OUT  ; NAK the endpoint
052C: 80 04    JMP   0x0531        (0885)     JMP     .done    
                                   (0886) .in:
052E: 63 C3 0C MOV   REG[X+195],12 (0887)     MOV     REG[X + USBUART_EP1MODE - 1], USB_MODE_NAK_IN  ; NAK the endpoint
                                   (0888) .done:
0531: 70 EF    AND   F,239         (0889) 	M8C_SetBank0
0533: 81 39    JMP   0x066D        (0890)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
                                   (0891) ENDIF
                                   (0892) ;-----------------------------------------------------------------------------
                                   (0893) ;  FUNCTION NAME: USBUART_CB_h2d_std_ep_03
                                   (0894) ;
                                   (0895) ;  DESCRIPTION:   Set Endpoint Feature
                                   (0896) ;
                                   (0897) ;****************************************************************
                                   (0898) ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                                   (0899) ;****************************************************************
                                   (0900) ;
                                   (0901) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                   (0902) ; bRequest       : SET_FEATURE                    = 03h    
                                   (0903) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                   (0904) ; wIndex         : ENDPOINT                       = 00xxh
                                   (0905) ; wLength        : RESERVED                       = 0000h  
                                   (0906) ; 
                                   (0907) ; The SET_ENDPOINT_FEATURE request enables a particular feature
                                   (0908) ; for a specific endpoint. The only feature supported for an 
                                   (0909) ; endpoint is the EP_HALT feature.
                                   (0910) ; 
                                   (0911) ;****************************************************************
                                   (0912) ;-----------------------------------------------------------------------------
                                   (0913) ;
                                   (0914) ;  ARGUMENTS:
                                   (0915) ;
                                   (0916) ;  RETURNS:
                                   (0917) ;
                                   (0918) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0919) ;
                                   (0920) ;  THEORY of OPERATION or PROCEDURE:
                                   (0921) ;
                                   (0922) ;-----------------------------------------------------------------------------
                                   (0923) IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                                   (0924) export  USBUART_CB_h2d_std_ep_03
                                   (0925) USBUART_CB_h2d_std_ep_03:
0535: 5D 5A    MOV   A,REG[90]     (0926)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the feature selector
0537: 39 00    CMP   A,0           (0927)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0539: BE 84    JNZ   0x03BE        (0928)     JNZ     USBUART_Not_Supported
                                   (0929) 
053B: 5D 5C    MOV   A,REG[92]     (0930)     MOV     A, REG[USBUART_EP0DATA+wIndexLo]  ; Get the Endpoint number
053D: 21 7F    AND   A,127         (0931)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
053F: 39 00    CMP   A,0           (0932)     CMP     A, 0                       ; Never halt the Control Endpoint
0541: A0 18    JZ    0x055A        (0933)     JZ      .done
                                   (0934) 
0543: 39 05    CMP   A,5           (0935)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
0545: DE 78    JNC   0x03BE        (0936)     JNC     USBUART_Not_Supported
                                   (0937) 
0547: 5C       MOV   X,A           (0938)     MOV     X, A                       ; Endpoint number is the index
                                   (0939) 
0548: 2F 05 01 OR    [X+5],1       (0940)     OR      [X+USBUART_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
                                   (0941) 
054B: 49 5C 80 TST   REG[92],128   (0942)     TST     REG[USBUART_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
054E: 71 10    OR    F,16          (0943)     M8C_SetBank1	                      ; For EP1_MODE register
0550: B0 06    JNZ   0x0557        (0944)     JNZ     .in
                                   (0945) 
0552: 63 C3 89 MOV   REG[X+195],137(0946)     MOV     REG[X + USBUART_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
0555: 80 04    JMP   0x055A        (0947)     JMP     .done    
                                   (0948) .in:
0557: 63 C3 8D MOV   REG[X+195],141(0949)     MOV     REG[X + USBUART_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
                                   (0950) .done:        
055A: 70 EF    AND   F,239         (0951) 	M8C_SetBank0
055C: 81 10    JMP   0x066D        (0952)     JMP     USBUART_NoDataStageControlTransfer_Local_Std
                                   (0953) ENDIF
                                   (0954) ;-----------------------------------------------------------------------------
                                   (0955) ;  FUNCTION NAME: ConfigureEP
                                   (0956) ;
                                   (0957) ;  DESCRIPTION:   Configure an endpoint
                                   (0958) ;
                                   (0959) ;  ARGUMENTS:    A contains the endpoint direction
                                   (0960) ;                X contains the endpoint number
                                   (0961) ;
                                   (0962) ;  RETURNS:
                                   (0963) ;
                                   (0964) ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                                   (0965) ;
                                   (0966) ;  THEORY of OPERATION or PROCEDURE:
                                   (0967) ;
                                   (0968) ;-----------------------------------------------------------------------------
                                   (0969) ConfigureEP:
055E: 39 7F    CMP   A,127         (0970)     CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
0560: B0 02    JNZ   0x0563        (0971)     JNZ     .enable                    ; Only enable it if it is used
0562: 7F       RET                 (0972)     RET                                ; Quick exit if this endpoint is unused
                                   (0973) 
                                   (0974) ; Jump here to enable an endpoint
                                   (0975) .enable:
0563: 08       PUSH  A             (0976)     PUSH    A		                        ; Save the endpoint direction
0564: 5B       MOV   A,X           (0977)     MOV     A, X	                      ; We are using a JACC to dispatch to enable the interrupt
0565: 64       ASL   A             (0978)     ASL     A		                        ;  
0566: E0 01    JACC  0x0568        (0979)     JACC    .EP_INT_ENABLE             ;  
                                   (0980) 
                                   (0981) 
                                   (0982) .EP_INT_ENABLE:
0568: 80 09    JMP   0x0572        (0983)     JMP     .EP0IntEnable              ; Enable EP0
056A: 80 0C    JMP   0x0577        (0984)     JMP     .EP1IntEnable              ; Enable EP1
056C: 80 0F    JMP   0x057C        (0985)     JMP     .EP2IntEnable              ; Enable EP2
056E: 80 12    JMP   0x0581        (0986)     JMP     .EP3IntEnable              ; Enable EP3
0570: 80 15    JMP   0x0586        (0987)     JMP     .EP4IntEnable              ; Enable EP4
                                   (0988) 
                                   (0989) ; Jump here to enable EP0 Interrupts
                                   (0990) .EP0IntEnable:
0572: 43 DF 04 OR    REG[223],4    (0991)     M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP0_MASK
                                   (0992) ;    JMP   .exit2
0575: 80 15    JMP   0x058B        (0993)     JMP   .cont
                                   (0994) .EP1IntEnable:
0577: 43 DF 08 OR    REG[223],8    (0995)     M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP1_MASK
057A: 80 10    JMP   0x058B        (0996)     JMP   .cont
                                   (0997) .EP2IntEnable:
057C: 43 DF 10 OR    REG[223],16   (0998)     M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP2_MASK
057F: 80 0B    JMP   0x058B        (0999)     JMP   .cont
                                   (1000) .EP3IntEnable:
0581: 43 DF 20 OR    REG[223],32   (1001)     M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP3_MASK
0584: 80 06    JMP   0x058B        (1002)     JMP   .cont
                                   (1003) .EP4IntEnable:
0586: 43 DF 40 OR    REG[223],64   (1004)     M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP4_MASK  
0589: 80 01    JMP   0x058B        (1005) 	JMP   .cont
                                   (1006) 
                                   (1007) ; Jump or flow here to continue configuring the endpoint    
                                   (1008) ;.contEP0:
                                   (1009) ;    POP   A                           ; Get the endpoint direction back
                                   (1010) ;    AND   A, USB_DIR_IN               ; Is it an IN endpoint?
                                   (1011) ;    JNZ   .inEP0                      ; Jump on IN
                                   (1012) ; Flow here for an OUT Endpoint
                                   (1013) ;    MOV   [USBUART_TempMode], USB_MODE_NAK_OUT ; NAK the endpoint
                                   (1014) ;    JMP   .exit2
                                   (1015) ; Jump here for an IN Endpoint
                                   (1016) ;.inEP0:
                                   (1017) ;    MOV   [USBUART_TempMode], USB_MODE_NAK_IN ; NAK the endpoint
                                   (1018) ;	JMP   .exit2
                                   (1019) .cont:
058B: 5B       MOV   A,X           (1020)     MOV     A, X	                      ; Get the endpoint number from X
058C: FE 2B    INDEX 0x03B9        (1021)     INDEX   USBUART_USB_EP_BIT_LOOKUP	 ; Find bit position for endpoint
058E: 31 FF    XOR   A,255         (1022)     XOR     A, FFh
0590: 24 1D    AND   [29],A        (1023)     AND     [USBUART_EPDataToggle], A ; Clear the data toggle for this endpoint
                                   (1024) 
                                   (1025) ; if endpoint 0 set EP0MODE
                                   (1026) ; then exit
                                   (1027) ;    MOV     A, X	                     ; Get the endpoint number from X
                                   (1028) ;    CMP     A, EP0	                   ; Is this endpoint zero?
                                   (1029) ;    JNZ     .enable                   ; Only enable it if it is used
                                   (1030) 
0592: 71 10    OR    F,16          (1031)     M8C_SetBank1
0594: 18       POP   A             (1032)     POP   A                            ; Get the endpoint direction back
0595: 21 80    AND   A,128         (1033)     AND   A, USB_DIR_IN                ; Is it an IN endpoint?
0597: B0 09    JNZ   0x05A1        (1034)     JNZ   .in                          ; Jump on IN
                                   (1035) ; Flow here for an OUT Endpoint
0599: 63 C3 08 MOV   REG[X+195],8  (1036)     MOV   REG[X+USBUART_EP1MODE-1], USB_MODE_NAK_OUT ; NAK the endpoint
059C: 56 26 00 MOV   [X+38],0      (1037)     MOV   [X+USBUART_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
059F: 80 04    JMP   0x05A4        (1038)     JMP   .exit1
                                   (1039) ; Jump here for an IN Endpoint
                                   (1040) .in:
05A1: 63 C3 0C MOV   REG[X+195],12 (1041)     MOV   REG[X+USBUART_EP1MODE-1], USB_MODE_NAK_IN ; NAK the endpoint
                                   (1042) ; Jump or flow here to set the API event and exit    
                                   (1043) .exit1:
05A4: 70 EF    AND   F,239         (1044) 	M8C_SetBank0
                                   (1045) .exit2:
                                   (1046) ;    MOV   [X+USBUART_EPDataToggle], 0  ; Clear all EP data toggles?  Is this right?
05A6: 56 26 01 MOV   [X+38],1      (1047)     MOV   [X+USBUART_EndpointAPIStatus], EVENT_PENDING ; For the API
05A9: 7F       RET                 (1048)     RET
                                   (1049) 
                                   (1050) ;-----------------------------------------------------------------------------
                                   (1051) ;  USB 2nd Tier Dispatch Jump Tables for Standard Requests (based on bRequest)
                                   (1052) ;-----------------------------------------------------------------------------
                                   (1053) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                   (1054) ;
                                   (1055) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                   (1056) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                   (1057) ;
                                   (1058) ;-----------------------------------------------------------------------------
                                   (1059) ;
                                   (1060) ;  ARGUMENTS:
                                   (1061) ;
                                   (1062) ;  RETURNS:
                                   (1063) ;
                                   (1064) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (1065) ;
                                   (1066) ;  THEORY of OPERATION or PROCEDURE:
                                   (1067) ;
                                   (1068) ;-----------------------------------------------------------------------------
                                   (1069) USBUART_DT_d2h_std_dev:
                                   (1070) ;-----------------------------------------------------------------------------
                                   (1071) 
05AA: 8E 23    JMP   0x03CE        (1072)     jmp     USBUART_CB_d2h_std_dev_00
05AC: 8E 11    JMP   0x03BE        (1073)     jmp     USBUART_CB_d2h_std_dev_01
05AE: 8E 0F    JMP   0x03BE        (1074)     jmp     USBUART_CB_d2h_std_dev_02
05B0: 8E 0D    JMP   0x03BE        (1075)     jmp     USBUART_CB_d2h_std_dev_03
05B2: 8E 0B    JMP   0x03BE        (1076)     jmp     USBUART_CB_d2h_std_dev_04
05B4: 8E 09    JMP   0x03BE        (1077)     jmp     USBUART_CB_d2h_std_dev_05
05B6: 8E 26    JMP   0x03DD        (1078)     jmp     USBUART_CB_d2h_std_dev_06
05B8: 8E 05    JMP   0x03BE        (1079)     jmp     USBUART_CB_d2h_std_dev_07
05BA: 8E 80    JMP   0x043B        (1080)     jmp     USBUART_CB_d2h_std_dev_08
                                   (1081) 
                                   (1082) USBUART_DT_d2h_std_dev_End:
                                   (1083) USBUART_DT_d2h_std_dev_Size: equ (USBUART_DT_d2h_std_dev_End-USBUART_DT_d2h_std_dev) / 2
                                   (1084) USBUART_DT_d2h_std_dev_Dispatch::
05BC: 5D 59    MOV   A,REG[89]     (1085)     MOV    A, REG[USBUART_EP0DATA + bRequest]
05BE: 39 09    CMP   A,9
05C0: D0 04    JNC   0x05C5        (1086)     DISPATCHER USBUART_DT_d2h_std_dev, USBUART_DT_d2h_std_dev_Size, USBUART_Not_Supported 
05C2: 64       ASL   A
05C3: EF E6    JACC  0x05AA
05C5: 7D 03 BE LJMP  0x03BE
                                   (1087) 
                                   (1088) ;-----------------------------------------------------------------------------
                                   (1089) USBUART_DT_h2d_std_dev:
                                   (1090) ;-----------------------------------------------------------------------------
                                   (1091) 
05C8: 8D F5    JMP   0x03BE        (1092)     jmp     USBUART_CB_h2d_std_dev_00
05CA: 8E 79    JMP   0x0444        (1093)     jmp     USBUART_CB_h2d_std_dev_01
05CC: 8D F1    JMP   0x03BE        (1094)     jmp     USBUART_CB_h2d_std_dev_02
05CE: 8E 80    JMP   0x044F        (1095)     jmp     USBUART_CB_h2d_std_dev_03
05D0: 8D ED    JMP   0x03BE        (1096)     jmp     USBUART_CB_h2d_std_dev_04
05D2: 8E 91    JMP   0x0464        (1097)     jmp     USBUART_CB_h2d_std_dev_05
05D4: 8D E9    JMP   0x03BE        (1098)     jmp     USBUART_CB_h2d_std_dev_06
05D6: 8D E7    JMP   0x03BE        (1099)     jmp     USBUART_CB_h2d_std_dev_07
05D8: 8D E5    JMP   0x03BE        (1100)     jmp     USBUART_CB_h2d_std_dev_08
05DA: 8E 92    JMP   0x046D        (1101)     jmp     USBUART_CB_h2d_std_dev_09
                                   (1102) 
                                   (1103) USBUART_DT_h2d_std_dev_End:
                                   (1104) USBUART_DT_h2d_std_dev_Size: equ (USBUART_DT_h2d_std_dev_End-USBUART_DT_h2d_std_dev) / 2
                                   (1105) USBUART_DT_h2d_std_dev_Dispatch::
                                   (1106) 
05DC: 5D 59    MOV   A,REG[89]     (1107)     MOV     A, REG[USBUART_EP0DATA + bRequest]
05DE: 39 0A    CMP   A,10
05E0: D0 04    JNC   0x05E5        (1108)     DISPATCHER USBUART_DT_h2d_std_dev, USBUART_DT_h2d_std_dev_Size, USBUART_Not_Supported 
05E2: 64       ASL   A
05E3: EF E4    JACC  0x05C8
05E5: 7D 03 BE LJMP  0x03BE
                                   (1109) 
                                   (1110) 
                                   (1111) ;-----------------------------------------------------------------------------
                                   (1112) USBUART_DT_d2h_std_ifc:
                                   (1113) ;-----------------------------------------------------------------------------
                                   (1114) 
05E8: 8E DE    JMP   0x04C7        (1115)     jmp     USBUART_CB_d2h_std_ifc_00
05EA: 8D D3    JMP   0x03BE        (1116)     jmp     USBUART_CB_d2h_std_ifc_01
05EC: 8D D1    JMP   0x03BE        (1117)     jmp     USBUART_CB_d2h_std_ifc_02
05EE: 8D CF    JMP   0x03BE        (1118)     jmp     USBUART_CB_d2h_std_ifc_03
05F0: 8D CD    JMP   0x03BE        (1119)     jmp     USBUART_CB_d2h_std_ifc_04
05F2: 8D CB    JMP   0x03BE        (1120)     jmp     USBUART_CB_d2h_std_ifc_05
05F4: 8D C9    JMP   0x03BE        (1121)     jmp     USBUART_CB_d2h_std_ifc_06
05F6: 8D C7    JMP   0x03BE        (1122)     jmp     USBUART_CB_d2h_std_ifc_07
05F8: 8D C5    JMP   0x03BE        (1123)     jmp     USBUART_CB_d2h_std_ifc_08
05FA: 8D C3    JMP   0x03BE        (1124)     jmp     USBUART_CB_d2h_std_ifc_09
05FC: 8E E2    JMP   0x04DF        (1125)     jmp     USBUART_CB_d2h_std_ifc_10
                                   (1126) 
                                   (1127) USBUART_DT_d2h_std_ifc_End:
                                   (1128) USBUART_DT_d2h_std_ifc_Size: equ (USBUART_DT_d2h_std_ifc_End-USBUART_DT_d2h_std_ifc) / 2
                                   (1129) USBUART_DT_d2h_std_ifc_Dispatch::
05FE: 3C 01 00 CMP   [1],0         (1130)     CMP     [USBUART_Configuration], 0 ; Is the device configured?
0601: B0 03    JNZ   0x0605        (1131)     JNZ     .configured                ; Jump on configured
0603: 8D BA    JMP   0x03BE        (1132)     JMP    _USBUART_Not_Supported      ; Stall the request if not configured
                                   (1133) ; Jump here if the device is configured
                                   (1134) .configured:
0605: 5D 59    MOV   A,REG[89]     (1135)     MOV     A, REG[USBUART_EP0DATA + bRequest]
0607: 39 0B    CMP   A,11
0609: D0 04    JNC   0x060E        (1136)     DISPATCHER USBUART_DT_d2h_std_ifc, USBUART_DT_d2h_std_ifc_Size, USBUART_Not_Supported 
060B: 64       ASL   A
060C: EF DB    JACC  0x05E8
060E: 7D 03 BE LJMP  0x03BE
                                   (1137) 
                                   (1138) ;-----------------------------------------------------------------------------
                                   (1139) USBUART_DT_h2d_std_ifc:
                                   (1140) ;-----------------------------------------------------------------------------
                                   (1141) 
0611: 8D AC    JMP   0x03BE        (1142)     jmp     USBUART_CB_h2d_std_ifc_00
                                   (1143) 
                                   (1144) USBUART_DT_h2d_std_ifc_End:
                                   (1145) USBUART_DT_h2d_std_ifc_Size: equ (USBUART_DT_h2d_std_ifc_End-USBUART_DT_h2d_std_ifc) / 2
                                   (1146) USBUART_DT_h2d_std_ifc_Dispatch::
0613: 3C 01 00 CMP   [1],0         (1147)     CMP     [USBUART_Configuration], 0 ; Is the device configured?
0616: B0 03    JNZ   0x061A        (1148)     JNZ     .configured                ; Jump on configured
0618: 8D A5    JMP   0x03BE        (1149)     JMP    _USBUART_Not_Supported      ; Stall the request if not configured
                                   (1150) ; Jump here if the device is configured
                                   (1151) .configured:
061A: 5D 59    MOV   A,REG[89]     (1152)     MOV     A, REG[USBUART_EP0DATA + bRequest]
061C: 39 01    CMP   A,1
061E: D0 04    JNC   0x0623        (1153)     DISPATCHER USBUART_DT_h2d_std_ifc, USBUART_DT_h2d_std_ifc_Size, USBUART_Not_Supported 
0620: 64       ASL   A
0621: EF EF    JACC  0x0611
0623: 7D 03 BE LJMP  0x03BE
                                   (1154) 
                                   (1155) ;-----------------------------------------------------------------------------
                                   (1156) USBUART_DT_d2h_std_ep:
                                   (1157) ;-----------------------------------------------------------------------------
0626: 8E CC    JMP   0x04F3        (1158)     jmp     USBUART_CB_d2h_std_ep_00
                                   (1159) 
                                   (1160) USBUART_DT_d2h_std_ep_End:
                                   (1161) USBUART_DT_d2h_std_ep_Size: equ (USBUART_DT_d2h_std_ep_End-USBUART_DT_d2h_std_ep) / 2
                                   (1162) USBUART_DT_d2h_std_ep_Dispatch::
0628: 3C 01 00 CMP   [1],0         (1163)     CMP     [USBUART_Configuration], 0 ; Is the device configured?
062B: B0 0D    JNZ   0x0639        (1164)     JNZ     .configured                ; Jump on configured
                                   (1165) 
062D: 5D 5D    MOV   A,REG[93]     (1166)     MOV     A, REG[USBUART_EP0DATA + wIndexHi] ; Is the request for EP0?
062F: 53 23    MOV   [35],A        (1167)     MOV     [USBUART_t2], A            ; Use the UM temp var--Selector
0631: 5D 5C    MOV   A,REG[92]     (1168)     MOV     A, REG[USBUART_EP0DATA + wIndexLo] ;
0633: 2C 23    OR    [35],A        (1169)     OR      [USBUART_t2], A            ; Use the UM temp var--Selector
0635: A0 03    JZ    0x0639        (1170)     JZ      .ep0_request
                                   (1171) 
0637: 8D 86    JMP   0x03BE        (1172)     JMP    _USBUART_Not_Supported      ; Stall the request if not configured
                                   (1173) ; Jump here if the device is configured or EP0 request
                                   (1174) .configured:
                                   (1175) .ep0_request:
0639: 5D 59    MOV   A,REG[89]     (1176)     MOV     A, REG[USBUART_EP0DATA + bRequest]
063B: 39 01    CMP   A,1
063D: D0 04    JNC   0x0642        (1177)     DISPATCHER USBUART_DT_d2h_std_ep, USBUART_DT_d2h_std_ep_Size, USBUART_Not_Supported 
063F: 64       ASL   A
0640: EF E5    JACC  0x0626
0642: 7D 03 BE LJMP  0x03BE
                                   (1178) 
                                   (1179) 
                                   (1180) ;-----------------------------------------------------------------------------
                                   (1181) USBUART_DT_h2d_std_ep:
                                   (1182) ;-----------------------------------------------------------------------------
0645: 8D 78    JMP   0x03BE        (1183)     jmp     USBUART_CB_h2d_std_ep_00
0647: 8E C4    JMP   0x050C        (1184)     jmp     USBUART_CB_h2d_std_ep_01
0649: 8D 74    JMP   0x03BE        (1185)     jmp     USBUART_CB_h2d_std_ep_02
064B: 8E E9    JMP   0x0535        (1186)     jmp     USBUART_CB_h2d_std_ep_03
                                   (1187) 
                                   (1188) USBUART_DT_h2d_std_ep_End:
                                   (1189) USBUART_DT_h2d_std_ep_Size: equ (USBUART_DT_h2d_std_ep_End-USBUART_DT_h2d_std_ep) / 2
                                   (1190) USBUART_DT_h2d_std_ep_Dispatch::
064D: 3C 01 00 CMP   [1],0         (1191)     CMP     [USBUART_Configuration], 0 ; Is the device configured?
0650: B0 0D    JNZ   0x065E        (1192)     JNZ     .configured                ; Jump on configured
                                   (1193) 
0652: 5D 5D    MOV   A,REG[93]     (1194)     MOV     A, REG[USBUART_EP0DATA + wIndexHi] ; Is the request for EP0?
0654: 53 23    MOV   [35],A        (1195)     MOV     [USBUART_t2], A            ; Use the UM temp var--Selector
0656: 5D 5C    MOV   A,REG[92]     (1196)     MOV     A, REG[USBUART_EP0DATA + wIndexLo] ;
0658: 2C 23    OR    [35],A        (1197)     OR      [USBUART_t2], A            ; Use the UM temp var--Selector
065A: A0 03    JZ    0x065E        (1198)     JZ      .ep0_request
                                   (1199) 
065C: 8D 61    JMP   0x03BE        (1200)     JMP    _USBUART_Not_Supported      ; Stall the request if not configured
                                   (1201) ; Jump here if the device is configured or EP0 request
                                   (1202) .configured:
                                   (1203) .ep0_request:
065E: 5D 59    MOV   A,REG[89]     (1204)     MOV     A, REG[USBUART_EP0DATA + bRequest]
0660: 39 04    CMP   A,4
0662: D0 04    JNC   0x0667        (1205)     DISPATCHER USBUART_DT_h2d_std_ep, USBUART_DT_h2d_std_ep_Size, USBUART_Not_Supported 
0664: 64       ASL   A
0665: EF DF    JACC  0x0645
0667: 7D 03 BE LJMP  0x03BE
                                   (1206) 
                                   (1207) USBUART_GetTableEntry_Local_Std:
066A: 7D 08 0B LJMP  0x080B        (1208)     LJMP    USBUART_GetTableEntry
                                   (1209) 
                                   (1210) USBUART_NoDataStageControlTransfer_Local_Std:
066D: 7D 07 0D LJMP  0x070D        (1211)     LJMP    USBUART_NoDataStageControlTransfer

FILE: lib\usbuart_drv.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USBUART_drv.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/10/20 at 16:08:45
                                   (0005) ;;  Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USBUART control endpoint driver
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's
                                   (0015) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "USBUART_macros.inc"
                                   (0026) include "USBUART.inc"
                                   (0027) 
                                   (0028) ;-----------------------------------------------
                                   (0029) ;  Global Symbols
                                   (0030) ;-----------------------------------------------
                                   (0031) export _USBUART_EP0_ISR
                                   (0032) export  USBUART_InitControlRead
                                   (0033) export _USBUART_InitControlRead
                                   (0034) export  USBUART_InitControlWrite
                                   (0035) export _USBUART_InitControlWrite
                                   (0036) export  USBUART_InitNoDataStageControlTransfer
                                   (0037) export _USBUART_InitNoDataStageControlTransfer
                                   (0038) export  USBUART_NoDataStageControlTransfer
                                   (0039) 
                                   (0040) ;-----------------------------------------------
                                   (0041) ;  Macro Definitions
                                   (0042) ;-----------------------------------------------
                                   (0043) 
                                   (0044) ;-----------------------------------------------
                                   (0045) ;  Constant Definitions
                                   (0046) ;-----------------------------------------------
                                   (0047) 
                                   (0048) ;-----------------------------------------------
                                   (0049) ; Variable Allocation
                                   (0050) ;-----------------------------------------------
                                   (0051) AREA InterruptRAM (RAM,REL,CON)
                                   (0052) ;----------------------------------------------------------------------------
                                   (0053) ; Current Device
                                   (0054) ;----------------------------------------------------------------------------
                                   (0055) EXPORT USBUART_bCurrentDevice, _USBUART_bCurrentDevice
                                   (0056)  USBUART_bCurrentDevice:
                                   (0057) _USBUART_bCurrentDevice:                BLK   1    ;  Current Device
                                   (0058) ;----------------------------------------------------------------------------
                                   (0059) ; Current Configuration
                                   (0060) ;----------------------------------------------------------------------------
                                   (0061) EXPORT USBUART_Configuration, _USBUART_Configuration
                                   (0062)  USBUART_Configuration:
                                   (0063) _USBUART_Configuration:                 BLK   1    ;  Current Configuration
                                   (0064) ;----------------------------------------------------------------------------
                                   (0065) ; Current Device Status
                                   (0066) ;----------------------------------------------------------------------------
                                   (0067) EXPORT USBUART_DeviceStatus, _USBUART_DeviceStatus
                                   (0068)  USBUART_DeviceStatus:
                                   (0069) _USBUART_DeviceStatus:                  BLK   1    ;  Current Device Status
                                   (0070) ;----------------------------------------------------------------------------
                                   (0071) ; Interface Setting
                                   (0072) ;----------------------------------------------------------------------------
                                   (0073) EXPORT USBUART_InterfaceSetting, _USBUART_InterfaceSetting
                                   (0074)  USBUART_InterfaceSetting:
                                   (0075) _USBUART_InterfaceSetting:              BLK   2    ; Interface Setting
                                   (0076) ;----------------------------------------------------------------------------
                                   (0077) ; Endpoint Status--USB Status
                                   (0078) ;----------------------------------------------------------------------------
                                   (0079) EXPORT USBUART_EndpointStatus, _USBUART_EndpointStatus
                                   (0080)  USBUART_EndpointStatus:
                                   (0081) _USBUART_EndpointStatus:                BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                   (0082) ;----------------------------------------------------------------------------
                                   (0083) ; Last Packet Size
                                   (0084) ;----------------------------------------------------------------------------
                                   (0085) EXPORT USBUART_LastSize 
                                   (0086)  USBUART_LastSize:                      BLK   1    ; Last Packet Size
                                   (0087) ;----------------------------------------------------------------------------
                                   (0088) ; Control Transfer State Machine
                                   (0089) ; State values for Control Write
                                   (0090) ; State values for Control Read
                                   (0091) ;----------------------------------------------------------------------------
                                   (0092) EXPORT USBUART_TransferType 
                                   (0093)  USBUART_TransferType:                  BLK   1    ; Control Transfer State Machine
                                   (0094) ;----------------------------------------------------------------------------
                                   (0095) ; Control Transfer Intermediate Buffer--Shared among the requests
                                   (0096) ;----------------------------------------------------------------------------
                                   (0097) EXPORT USBUART_TransferBuffer 
                                   (0098)  USBUART_TransferBuffer:                BLK   8
                                   (0099) ;----------------------------------------------------------------------------
                                   (0100) ; Transfer Descriptor Data for Control Transfer
                                   (0101) ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
                                   (0102) ;----------------------------------------------------------------------------
                                   (0103) ; Control Transfer Data Source
                                   (0104) ;   USB_DS_ROM
                                   (0105) ;   USB_DS_RAM
                                   (0106) ;   USB_DS_RAM_AS_NEEDED
                                   (0107) ;----------------------------------------------------------------------------
                                   (0108) EXPORT USBUART_CurrentTD, _USBUART_CurrentTD
                                   (0109) _USBUART_CurrentTD:
                                   (0110)  USBUART_CurrentTD:
                                   (0111) EXPORT USBUART_DataSource, _USBUART_DataSource
                                   (0112) _USBUART_DataSource:
                                   (0113)  USBUART_DataSource:                    BLK   1
                                   (0114) ;----------------------------------------------------------------------------
                                   (0115) ; Control Transfer Data Size
                                   (0116) ;----------------------------------------------------------------------------
                                   (0117) EXPORT USBUART_TransferSize, _USBUART_TransferSize
                                   (0118) _USBUART_TransferSize:
                                   (0119)  USBUART_TransferSize:                  BLK   2
                                   (0120) ;----------------------------------------------------------------------------
                                   (0121) ; Control Transfer Data Pointer
                                   (0122) ;   Source for Control Read
                                   (0123) ;   Destination for Control Write
                                   (0124) ;----------------------------------------------------------------------------
                                   (0125) EXPORT USBUART_DataPtr, _USBUART_DataPtr
                                   (0126) _USBUART_DataPtr: 
                                   (0127)  USBUART_DataPtr:                       BLK   2
                                   (0128) ;----------------------------------------------------------------------------
                                   (0129) ; Transfer Completion Notification
                                   (0130) ;----------------------------------------------------------------------------
                                   (0131) EXPORT USBUART_StatusBlockPtr, _USBUART_StatusBlockPtr
                                   (0132) _USBUART_StatusBlockPtr: 
                                   (0133)  USBUART_StatusBlockPtr:                BLK   2
                                   (0134) 
                                   (0135) ;----------------------------------------------------------------------------
                                   (0136) ; Control Transfer _TransferByteCount (Actually transferred)
                                   (0137) ;----------------------------------------------------------------------------
                                   (0138)  USBUART_TransferByteCount:             BLK   2
                                   (0139) 
                                   (0140) ;----------------------------------------------------------------------------
                                   (0141) ; Control Endpoint Data toggle
                                   (0142) EXPORT USBUART_EPDataToggle, _USBUART_EPDataToggle
                                   (0143)  _USBUART_EPDataToggle:
                                   (0144)  USBUART_EPDataToggle:
                                   (0145)  USBUART_EP0DataToggle:                 BLK   USB_NUM_ENDPOINTS
                                   (0146) ;----------------------------------------------------------------------------
                                   (0147) ; Control Endpoint Data Pending Flag
                                   (0148) EXPORT USBUART_fDataPending
                                   (0149)  USBUART_fDataPending:                  BLK   1
                                   (0150) ;----------------------------------------------------------------------------
                                   (0151) ; Control Endpoint Data Pending Flag
                                   (0152) ;EXPORT USBUART_PendingData
                                   (0153) ;  USBUART_PendingData:                 BLK   1
                                   (0154) ;----------------------------------------------------------------------------
                                   (0155) ; Temporary Data registers
                                   (0156) EXPORT USBUART_t2, USBUART_t1, USBUART_t0
                                   (0157)  USBUART_t2:                            BLK   1    ; Temporary shared by the UM
                                   (0158)  USBUART_t1:                            BLK   1    ; Temporary shared by the UM
                                   (0159)  USBUART_t0:                            BLK   1    ; Temporary shared by the UM
                                   (0160) 
                                   (0161) ;EXPORT USBUART_IntState
                                   (0162) ; USBUART_IntState:                     BLK  1
                                   (0163) ;EXPORT USBUART_StackPointer
                                   (0164) ; USBUART_StackPointer:                 BLK  1
                                   (0165) ;EXPORT USBUART_TempMode
                                   (0166) ; USBUART_TempMode:                     BLK 1
                                   (0167) ;----------------------------------------------------------------------------
                                   (0168) ; Endpoint Transfer--API Status
                                   (0169) ;----------------------------------------------------------------------------
                                   (0170) EXPORT USBUART_EndpointAPIStatus, _USBUART_EndpointAPIStatus
                                   (0171)  USBUART_EndpointAPIStatus:
                                   (0172) _USBUART_EndpointAPIStatus:             BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                   (0173) 
                                   (0174) AREA UserModules (ROM, REL)
                                   (0175) ;-----------------------------------------------------------------------------
                                   (0176) ;  FUNCTION NAME: USBUART_EP0_ISR
                                   (0177) 
                                   (0178) ;
                                   (0179) ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                                   (0180) ;                 dispatches all SETUP, IN, and OUT transfers to the proper
                                   (0181) ;                 dispatch routines for all supported USB requests.
                                   (0182) ;
                                   (0183) ;-----------------------------------------------------------------------------
                                   (0184) ;
                                   (0185) ;  ARGUMENTS:   n/a
                                   (0186) ;
                                   (0187) ;  RETURNS:     n/a
                                   (0188) ;
                                   (0189) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0190) ;
                                   (0191) ;  THEORY of OPERATION or PROCEDURE:
                                   (0192) ;
                                   (0193) ;-----------------------------------------------------------------------------
                                   (0194)  USBUART_EP0_ISR:
                                   (0195) _USBUART_EP0_ISR:
0670: 08       PUSH  A             (0196)         push A
0671: 10       PUSH  X             (0197)         push X
0672: 5D D5    MOV   A,REG[213]
0674: 08       PUSH  A             (0198)     REG_PRESERVE MVW_PP
0675: 5D D4    MOV   A,REG[212]
0677: 08       PUSH  A             (0199)     REG_PRESERVE MVR_PP
                                   (0200) 
0678: 62 D5 00 MOV   REG[213],0    (0201)     RAM_SETPAGE_MVW 0
067B: 62 D4 00 MOV   REG[212],0    (0202)     RAM_SETPAGE_MVR 0
                                   (0203) 
                                   (0204)     ; Dispatch to setup/in/out handlers
067E: 5D 56    MOV   A,REG[86]     (0205)     MOV  A, reg[USBUART_EP0MODE]        ; Get the mode reg
                                   (0206) 
                                   (0207)     ; MSB is the SETUP bit, followed by IN, then OUT
0680: 64       ASL   A             (0208)     ASL  A                              ; Shift to the carry and jump if SETUP bit set
0681: C0 17    JC    0x0699        (0209)     JC   USBUART_EP0_Setup
                                   (0210) 
0683: 64       ASL   A             (0211)     ASL  A                              ; Shift to the carry and jump if IN bit set
0684: C0 34    JC    0x06B9        (0212)     JC   USBUART_EP0_IN
                                   (0213) 
0686: 64       ASL   A             (0214)     ASL  A                              ; Shift to the carry and jump if OUT bit set
0687: C0 3D    JC    0x06C5        (0215)     JC   USBUART_EP0_OUT
                                   (0216) 
0689: 82 5F    JMP   0x08E9        (0217)     JMP    USBUART_Not_Supported_Local_Drv
                                   (0218) 
                                   (0219) ; ISR Exit Point to update the mode register
                                   (0220) ;   mode and count have been pushed onto the stack
                                   (0221) EXPORT USBUART_EP0_UPD_MODE_EXIT
                                   (0222) USBUART_EP0_UPD_MODE_EXIT:
                                   (0223) 
068B: 60 57    MOV   REG[87],A     (0224)     MOV    REG[USBUART_EP0CNT], A      ; Update the count
068D: 5B       MOV   A,X           (0225)     MOV    A, X                        ; Get the new mode
068E: 60 56    MOV   REG[86],A     (0226)     MOV    REG[USBUART_EP0MODE], A     ; Update the node
0690: 18       POP   A
                                   (0227) 
                                   (0228) ; Common Exit Point
                                   (0229) USBUART_EP0_ISR_EXIT:
0691: 60 D4    MOV   REG[212],A    (0230)     REG_RESTORE MVR_PP
0693: 18       POP   A
0694: 60 D5    MOV   REG[213],A    (0231)     REG_RESTORE MVW_PP
0696: 20       POP   X             (0232)     POP  X                              ;
                                   (0233) ;       MOV  A, [USBUART_TempMode]
                                   (0234) ;       MOV  reg[USBUART_EP0MODE], A
0697: 18       POP   A             (0235)     POP  A                              ; Restore Context
0698: 7E       RETI                (0236)     RETI
                                   (0237) 
                                   (0238) 
                                   (0239) ;-----------------------------------------------------------------------------
                                   (0240) ;  FUNCTION NAME: USBUART_EP0_Setup
                                   (0241) ;
                                   (0242) ;  DESCRIPTION:   Dispatch a USB SETUP
                                   (0243) ;
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245)  USBUART_EP0_Setup:
                                   (0246) _USBUART_EP0_Setup:
                                   (0247) ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
0699: 08       PUSH  A             (0248)     PUSH    A                          ; Save the mode register
069A: 50 02    MOV   A,2           (0249)     MOV     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
069C: 91 DA    CALL  0x0878        (0250)     CALL    USBUART_UpdateStatusBlock
069E: 18       POP   A             (0251)     POP     A                          ; Restore the mode register
069F: 5D 57    MOV   A,REG[87]     (0252)     MOV    A, REG[USBUART_EP0CNT]            ; Get the count reg
06A1: 39 4A    CMP   A,74          (0253)     CMP    A, (USB_CNT_VALID | 0x0A)
06A3: A0 03    JZ    0x06A7        (0254)     JZ      .dispatch
                                   (0255) 
06A5: 82 43    JMP   0x08E9        (0256)     JMP    USBUART_Not_Supported_Local_Drv
                                   (0257) 
                                   (0258) 
                                   (0259) ;-----------------------------------------------------------------------------
                                   (0260) ; Jump here to dispatch the request
                                   (0261) ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
                                   (0262) ; 7,6,5,1,0 determine what the request is. Bits [2:4] are default to zero. The below code
                                   (0263) ; re-organizes [bmRequestType] to the following format:
                                   (0264) ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
                                   (0265) ; "re-organization", the firmware will jump to an appropriate table to handle the request.
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) .dispatch:
06A7: 5D 58    MOV   A,REG[88]     (0268)     MOV     A, REG[USBUART_EP0DATA+bmRequestType]   ; Get bmRequestType
06A9: 21 E3    AND   A,227         (0269)     AND     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
06AB: 08       PUSH  A             (0270)     PUSH    A                                ; store value on the stack
06AC: 67       ASR   A             (0271)     ASR     A                                ; move bits 7-6-5 into 4-3-2's place
06AD: 67       ASR   A             (0272)     ASR     A                                ; "asr" instruction shift all bits one place to the right.
06AE: 67       ASR   A             (0273)     ASR     A                                ; Bit7 remains the same.
06AF: 53 23    MOV   [35],A        (0274)     MOV     [USBUART_t2], A                  ; store shifted value
06B1: 18       POP   A             (0275)     POP     A                                ; get original value
06B2: 2A 23    OR    A,[35]        (0276)     OR      A, [USBUART_t2]                  ; or the two to get the 5-bit field
06B4: 21 1F    AND   A,31          (0277)     AND     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                   (0278)                                              ; Bit0 is loaded with a Zero. This results in multiplying
                                   (0279)                                              ; the accumulator by 2, and the reason to multiply it by 2
                                   (0280)                                              ; is that each "jmp" instruction in the tables is two bytes long.
                                   (0281) 
06B6: 7D 08 DF LJMP  0x08DF        (0282)     LJMP USBUART_bmRequestType_Dispatch
                                   (0283) 
                                   (0284) 
                                   (0285) ;-----------------------------------------------------------------------------
                                   (0286) ;  FUNCTION NAME: USBUART_EP0_IN
                                   (0287) ;
                                   (0288) ;  DESCRIPTION: Handles an IN request.  Depending on the state of the
                                   (0289) ;               enumeration sequence it decides what to do next
                                   (0290) ;
                                   (0291) ;-----------------------------------------------------------------------------
                                   (0292)  USBUART_EP0_IN:
                                   (0293) _USBUART_EP0_IN:
                                   (0294) 
06B9: 51 0B    MOV   A,[11]        (0295)     MOV  A, [USBUART_TransferType]
                                   (0296) ;    CALL USBUART_ControlInDispatch
                                   (0297) ;    JMP  USBUART_EP0_ISR_EXIT               ; And exit
                                   (0298) USBUART_ControlInDispatch:
06BB: E0 01    JACC  0x06BD        (0299)     JACC    USBUART_ControlInDispatchTable
                                   (0300) USBUART_ControlInDispatchTable:
06BD: 82 2B    JMP   0x08E9        (0301)     JMP     USBUART_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
06BF: 80 37    JMP   0x06F7        (0302)     JMP     USBUART_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
06C1: 80 AD    JMP   0x076F        (0303)     JMP     USBUART_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
06C3: 80 B8    JMP   0x077C        (0304)     JMP     USBUART_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0305) 
                                   (0306) 
                                   (0307) ;-----------------------------------------------------------------------------
                                   (0308) ;  FUNCTION NAME: USBUART_EP0_OUT
                                   (0309) ;
                                   (0310) ;  DESCRIPTION: HANDles an OUT request.  Depending on the state of the
                                   (0311) ;               enumeration sequence it decides what to do next
                                   (0312) ;
                                   (0313) ;-----------------------------------------------------------------------------
                                   (0314)  USBUART_EP0_OUT:
                                   (0315) _USBUART_EP0_OUT:
06C5: 51 0B    MOV   A,[11]        (0316)     MOV     A, [USBUART_TransferType]
06C7: E0 01    JACC  0x06C9        (0317)     JACC    USBUART_ControlOutDispatchTable
                                   (0318) USBUART_ControlOutDispatchTable:
06C9: 82 1F    JMP   0x08E9        (0319)     JMP     USBUART_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
06CB: 80 2D    JMP   0x06F9        (0320)     JMP     USBUART_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
06CD: 80 5E    JMP   0x072C        (0321)     JMP     USBUART_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
06CF: 80 C6    JMP   0x0796        (0322)     JMP     USBUART_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0323) 
                                   (0324) 
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: USBUART_InitControlRead
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
                                   (0329) ;                 not called.  It assumes a transfer descriptor has been loaded
                                   (0330) ;                 into the driver USBUART_CurrentTD data structure.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333)  USBUART_InitControlRead:
                                   (0334) _USBUART_InitControlRead:
06D1: 53 0A    MOV   [10],A        (0335)     MOV     [USBUART_LastSize], A      ; Save the packet size?
06D3: 91 B9    CALL  0x088E        (0336)     CALL    USBUART_InitializeStatusBlock
06D5: 55 0B 02 MOV   [11],2        (0337)     MOV     [USBUART_TransferType], USB_TRANS_STATE_CONTROL_READ
                                   (0338) 
                                   (0339)     ; Check the transfer size against the request size
06D8: 5D 5F    MOV   A,REG[95]     (0340)     MOV    A, REG[USBUART_EP0DATA+wLengthHi] ; MSB of wLength
06DA: 3A 15    CMP   A,[21]        (0341)     CMP    A, [USBUART_TransferSize]
06DC: B0 07    JNZ   0x06E4        (0342)     JNZ    .L1
                                   (0343) 
06DE: 5D 5E    MOV   A,REG[94]     (0344)     MOV    A, REG[USBUART_EP0DATA+wLengthLo] ; LSB of wLength
06E0: 3A 16    CMP   A,[22]        (0345)     CMP    A, [USBUART_TransferSize+1]
06E2: A0 09    JZ    0x06EC        (0346)     JZ     .L9
                                   (0347) .L1:
06E4: D0 07    JNC   0x06EC        (0348)     JNC    .L9
                                   (0349) ;
06E6: 53 16    MOV   [22],A        (0350)     MOV    [USBUART_TransferSize+1], A ;
06E8: 5D 5F    MOV   A,REG[95]     (0351)     MOV    A, REG[USBUART_EP0DATA+wLengthHi] ;
06EA: 53 15    MOV   [21],A        (0352)     MOV    [USBUART_TransferSize], A   ;
                                   (0353) .L9:
06EC: 55 1B 00 MOV   [27],0        (0354)     MOV    [USBUART_TransferByteCount], 0 ;
06EF: 55 1C 00 MOV   [28],0        (0355)     MOV    [USBUART_TransferByteCount+1], 0 ;
                                   (0356) 
06F2: 2E 1D 01 OR    [29],1        (0357)     OR     [USBUART_EP0DataToggle], 1 ; setup EP0 data toggle
06F5: 80 AA    JMP   0x07A0        (0358)     JMP    USBUART_LoadEndpoint        ;
                                   (0359) ;-----------------------------------------------------------------------------
                                   (0360) ;  FUNCTION NAME: USBUART_ControlReadDataStage
                                   (0361) ;
                                   (0362) ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
                                   (0363) ;                 must be JUMPed to, not called.  It assumes a transfer descriptor
                                   (0364) ;                 has been loaded into the driver USBUART_CurrentTD
                                   (0365) ;                 data structure.
                                   (0366) ;
                                   (0367) ;-----------------------------------------------------------------------------
                                   (0368)  USBUART_ControlReadDataStage:
06F7: 80 A8    JMP   0x07A0        (0369)     JMP     USBUART_LoadEndpoint
                                   (0370) 
                                   (0371) ;-----------------------------------------------------------------------------
                                   (0372) ;  FUNCTION NAME: USBUART_ControlReadStatusStage
                                   (0373) ;
                                   (0374) ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
                                   (0375) ;                 must be JUMPed to, not called.  It handles short or 0 packet
                                   (0376) ;                 It assumes a transfer descriptor has been loaded into the
                                   (0377) ;                 driver USBUART_CurrentTD data structure.
                                   (0378) ;
                                   (0379) ;-----------------------------------------------------------------------------
                                   (0380)  USBUART_ControlReadStatusStage:
06F9: 51 0A    MOV   A,[10]        (0381)     MOV    A, [USBUART_LastSize]       ; Get the number of bytes from the last transfer
06FB: 04 1C    ADD   [28],A        (0382)     ADD    [USBUART_TransferByteCount + 1], A ; Update the transfer byte count
06FD: 0E 1B 00 ADC   [27],0        (0383)     ADC    [USBUART_TransferByteCount], 0 ;
0700: 50 01    MOV   A,1           (0384)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
0702: 91 74    CALL  0x0878        (0385)     CALL   USBUART_UpdateStatusBlock
0704: 55 0B 00 MOV   [11],0        (0386)     MOV    [USBUART_TransferType], USB_TRANS_STATE_IDLE
0707: 50 00    MOV   A,0           (0387)     MOV    A, 0                        ; Count Register
0709: 57 03    MOV   X,3           (0388)     MOV    X, USB_MODE_STALL_IN_OUT
070B: 8F 7F    JMP   0x068B        (0389)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0390) ;-----------------------------------------------------------------------------
                                   (0391) ;  FUNCTION NAME: USBUART_NoDataStageControlTransfer
                                   (0392) ;                 USBUART_InitNoDataStageControlTransfer
                                   (0393) ;
                                   (0394) ;  DESCRIPTION:   This routine processes the status stage of a no data control
                                   (0395) ;                 write.  It must be JUMPed to, not called.
                                   (0396) ;
                                   (0397) ;-----------------------------------------------------------------------------
                                   (0398)  USBUART_NoDataStageControlTransfer:
                                   (0399) _USBUART_InitNoDataStageControlTransfer:
                                   (0400)  USBUART_InitNoDataStageControlTransfer:
070D: 91 7F    CALL  0x088E        (0401)     CALL    USBUART_InitializeStatusBlock
                                   (0402) 
070F: 55 0B 06 MOV   [11],6        (0403)     MOV    [USBUART_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
                                   (0404) 
0712: 50 00    MOV   A,0           (0405)     MOV    A, 0                        ; Count Register
0714: 57 06    MOV   X,6           (0406)     MOV    X, USB_MODE_STATUS_IN_ONLY
0716: 8F 74    JMP   0x068B        (0407)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0408) 
                                   (0409) 
                                   (0410) ;-----------------------------------------------------------------------------
                                   (0411) ;  FUNCTION NAME: USBUART_InitControlWrite
                                   (0412) ;
                                   (0413) ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
                                   (0414) ;                 to, not called.  It assumes a transfer descriptor has been loaded
                                   (0415) ;                 into the driver USBUART_CurrentTD data structure.
                                   (0416) ;
                                   (0417) ;-----------------------------------------------------------------------------
                                   (0418)  USBUART_InitControlWrite:
                                   (0419) _USBUART_InitControlWrite:
0718: 51 14    MOV   A,[20]        (0420)     MOV     A, [USBUART_DataSource]    ; Need to make sure the destination is not ROM
071A: 39 00    CMP   A,0           (0421)     CMP     A, USB_DS_ROM
071C: A1 CC    JZ    0x08E9        (0422)     JZ      USBUART_Not_Supported_Local_Drv
                                   (0423) 
071E: 91 6E    CALL  0x088E        (0424)     CALL    USBUART_InitializeStatusBlock
                                   (0425) 
0720: 55 0B 04 MOV   [11],4        (0426)     MOV    [USBUART_TransferType], USB_TRANS_STATE_CONTROL_WRITE
                                   (0427) 
0723: 2E 1D 01 OR    [29],1        (0428)     OR     [USBUART_EP0DataToggle], 1 ; setup EP0 data toggle
                                   (0429) 
0726: 50 00    MOV   A,0           (0430)     MOV    A, 0                        ; Count Register
0728: 57 0B    MOV   X,11          (0431)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
072A: 8F 60    JMP   0x068B        (0432)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0433) 
                                   (0434) 
                                   (0435) ;-----------------------------------------------------------------------------
                                   (0436) ;  FUNCTION NAME: USBUART_ControlWriteDataStage
                                   (0437) ;
                                   (0438) ;  DESCRIPTION:   This routine processes the data stage of a control
                                   (0439) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0440) ;                 transfer descriptor has been loaded into the driver
                                   (0441) ;                 USBUART_CurrentTD data structure.
                                   (0442) ;
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444)  USBUART_ControlWriteDataStage:
072C: 36 1D 01 XOR   [29],1        (0445)     XOR    [USBUART_EP0DataToggle], 1  ; Update data toggle
                                   (0446) 
072F: 5D 57    MOV   A,REG[87]     (0447)     MOV    A,REG[USBUART_EP0CNT]       ; Get the count
                                   (0448) 
0731: 21 0F    AND   A,15          (0449)     AND     A, 0x0F
0733: 11 02    SUB   A,2           (0450)     SUB     A, 2                       ; Count include the two byte checksum
                                   (0451) 
0735: 53 23    MOV   [35],A        (0452)     MOV     [USBUART_t2], A            ; Assume we have room to receive the whole packet
                                   (0453) 
0737: 50 00    MOV   A,0           (0454)     MOV     A, 0
0739: 3A 15    CMP   A,[21]        (0455)     CMP     A, [USBUART_TransferSize]  ; If the MSB has anything just use the count
073B: B0 07    JNZ   0x0743        (0456)     JNZ     .L1
                                   (0457) 
073D: 51 23    MOV   A,[35]        (0458)     MOV     A, [USBUART_t2]
073F: 3A 16    CMP   A,[22]        (0459)     CMP     A, [USBUART_TransferSize+1]  ;
0741: A0 06    JZ    0x0748        (0460)     JZ      .L6
                                   (0461) .L1:
0743: C0 04    JC    0x0748        (0462)     JC      .L6
0745: 5F 23 16 MOV   [35],[22]     (0463)     MOV     [USBUART_t2], [USBUART_TransferSize+1]
                                   (0464) 
                                   (0465) .L6:
0748: 51 23    MOV   A,[35]        (0466)     MOV     A, [USBUART_t2]
074A: 14 16    SUB   [22],A        (0467)     SUB     [USBUART_TransferSize+1],A   ; Update the bytes remaining
074C: 1E 15 00 SBB   [21],0        (0468)     SBB     [USBUART_TransferSize], 0  ;
                                   (0469) 
074F: 04 1C    ADD   [28],A        (0470)     ADD     [USBUART_TransferByteCount + 1], A ; Update the transfer byte count
0751: 0E 1B 00 ADC   [27],0        (0471)     ADC     [USBUART_TransferByteCount], 0 ;
                                   (0472) 
0754: 57 00    MOV   X,0           (0473)     MOV     X,0                        ; Start the index at 0
                                   (0474) 
                                   (0475) .RAM_COPY:
0756: 5E 58    MOV   A,REG[X+88]   (0476)     MOV     A, REG[X+USBUART_EP0DATA]  ; Get the data
0758: 3F 18    MVI   [24],A        (0477)     MVI     [USBUART_DataPtr+1], A     ; Store the data, bump the destination
                                   (0478) 
075A: 75       INC   X             (0479)     INC     X                          ; Bump the destination offset
075B: 5B       MOV   A,X           (0480)     MOV     A,X                        ; Are we done?
075C: 3A 23    CMP   A,[35]        (0481)     CMP     A, [USBUART_t2]
075E: CF F7    JC    0x0756        (0482)     JC      .RAM_COPY                  ; Not done
                                   (0483) 
0760: 50 00    MOV   A,0           (0484)     MOV    A, 0                        ; Count Register
0762: 57 0B    MOV   X,11          (0485)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
0764: 8F 26    JMP   0x068B        (0486)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0487) 
                                   (0488) ; Jump here on data toggle error
                                   (0489) .error:
0766: 55 0B 00 MOV   [11],0        (0490)     MOV    [USBUART_TransferType], USB_TRANS_STATE_IDLE  ; This simply aborts the transfer
0769: 50 00    MOV   A,0           (0491)     MOV    A, 0                        ; Count Register
076B: 57 03    MOV   X,3           (0492)     MOV    X, USB_MODE_STALL_IN_OUT
076D: 8F 1D    JMP   0x068B        (0493)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0494) 
                                   (0495) 
                                   (0496) ;-----------------------------------------------------------------------------
                                   (0497) ;  FUNCTION NAME: USBUART_ControlWriteStatusStage
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:   This routine processes the status stage of a control
                                   (0500) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0501) ;                 transfer descriptor has been loaded into the driver
                                   (0502) ;                 USBUART_CurrentTD data structure.
                                   (0503) ;
                                   (0504) ;-----------------------------------------------------------------------------
                                   (0505)  USBUART_ControlWriteStatusStage:
076F: 50 01    MOV   A,1           (0506)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
0771: 91 05    CALL  0x0878        (0507)     CALL   USBUART_UpdateStatusBlock
0773: 55 0B 00 MOV   [11],0        (0508)     MOV    [USBUART_TransferType], USB_TRANS_STATE_IDLE  ; The packet is done
0776: 50 00    MOV   A,0           (0509)     MOV    A, 0                        ; Count Register
0778: 57 03    MOV   X,3           (0510)     MOV    X, USB_MODE_STALL_IN_OUT
077A: 8F 10    JMP   0x068B        (0511)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0512) 
                                   (0513) 
                                   (0514) ;-----------------------------------------------------------------------------
                                   (0515) ;  FUNCTION NAME: USBUART_NoDataControlStatusStage
                                   (0516) ;
                                   (0517) ;  DESCRIPTION:   This routine processes the status stage of a control
                                   (0518) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                   (0519) ;                 transfer descriptor has been loaded into the driver
                                   (0520) ;                 USBUART_CurrentTD data structure.
                                   (0521) ;
                                   (0522) ;                 USB Device Addressing happens here because we can't change
                                   (0523) ;                 the SIE Address before the Status IN is received.
                                   (0524) ;
                                   (0525) ;-----------------------------------------------------------------------------
                                   (0526)  USBUART_NoDataControlStatusStage:
077C: 50 01    MOV   A,1           (0527)     MOV     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
077E: 90 F8    CALL  0x0878        (0528)     CALL    USBUART_UpdateStatusBlock
                                   (0529)     ; Dispatch to the proper handler
0780: 3C 22 01 CMP   [34],1        (0530)     CMP     [USBUART_fDataPending], USB_ADDRESS_CHANGE_PENDING
0783: B0 09    JNZ   0x078D        (0531)     JNZ     .L1
                                   (0532) 
                                   (0533)     ; USB ADDRESS CHANGE
0785: 51 0C    MOV   A,[12]        (0534)     MOV     A, [USBUART_TransferBuffer]  ; Get the pending data
                                   (0535) 
0787: 29 80    OR    A,128         (0536)     OR      A, USB_ADDR_ENABLE         ; Set the enable bit
0789: 60 4A    MOV   REG[74],A     (0537)     MOV     REG[USBUART_ADDR], A       ; Update the SIE address
078B: 80 01    JMP   0x078D        (0538)     JMP     .EXIT
                                   (0539) .L1:
                                   (0540) 
                                   (0541) .EXIT:
078D: 55 22 00 MOV   [34],0        (0542)     MOV     [USBUART_fDataPending], 0  ; Clear data pending
                                   (0543) 
0790: 50 00    MOV   A,0           (0544)     MOV    A, 0                        ; Count Register
0792: 57 06    MOV   X,6           (0545)     MOV    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
0794: 8E F6    JMP   0x068B        (0546)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0547) 
                                   (0548) 
                                   (0549) ;-----------------------------------------------------------------------------
                                   (0550) ;  FUNCTION NAME: USBUART_NoDataControlError
                                   (0551) ;
                                   (0552) ;  DESCRIPTION:   This routine handles the condition when we expected a
                                   (0553) ;                 status IN, but receive an OUT
                                   (0554) ;
                                   (0555) ;-----------------------------------------------------------------------------
                                   (0556)  USBUART_NoDataControlError:
0796: 50 03    MOV   A,3           (0557)     MOV    A, USB_XFER_ERROR           ; Return Transaction Error
0798: 90 DE    CALL  0x0878        (0558)     CALL   USBUART_UpdateStatusBlock
079A: 50 00    MOV   A,0           (0559)     MOV    A, 0                        ; Count Register
079C: 57 03    MOV   X,3           (0560)     MOV    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
079E: 8E EC    JMP   0x068B        (0561)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0562) 
                                   (0563) 
                                   (0564) ;-----------------------------------------------------------------------------
                                   (0565) ;  FUNCTION NAME: USBUART_LoadEndpoint
                                   (0566) ;
                                   (0567) ;  DESCRIPTION: Moves data from either RAM OR ROM - depending on the request
                                   (0568) ;               type AND then places the appropriate number of bytes -
                                   (0569) ;               depending on the request size into the endpoint FIFO.
                                   (0570) ;               It finally sets up the endpoint to send data.
                                   (0571) ;
                                   (0572) USBUART_LoadEndpoint:
07A0: 51 0A    MOV   A,[10]        (0573)     MOV     A, [USBUART_LastSize]      ; Get the number of bytes from the last transfer
07A2: 04 1C    ADD   [28],A        (0574)     ADD     [USBUART_TransferByteCount + 1], A ; Update the transfer byte count
07A4: 0E 1B 00 ADC   [27],0        (0575)     ADC     [USBUART_TransferByteCount], 0 ;
07A7: 51 15    MOV   A,[21]        (0576)     MOV     A,  [USBUART_TransferSize] ; Check to see if we have any
07A9: 2A 16    OR    A,[22]        (0577)     OR      A,  [USBUART_TransferSize+1] ;  more data to send
07AB: B0 0E    JNZ   0x07BA        (0578)     JNZ     .cont                      ; Jump if we have to send more data
                                   (0579) 
                                   (0580) ; Flow here if there is no more data to send
07AD: 3C 0A 08 CMP   [10],8        (0581)     CMP     [USBUART_LastSize], 8      ; Was it a full packet?
07B0: A0 47    JZ    0x07F8        (0582)     JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
                                   (0583) 
                                   (0584) ; Flow here if we are entering the status stage
07B2: 50 00    MOV   A,0           (0585)     MOV    A, 0                        ; Count Register
07B4: 53 0A    MOV   [10],A        (0586)     MOV    [USBUART_LastSize], A       ; Clear the byte count
07B6: 57 02    MOV   X,2           (0587)     MOV    X, USB_MODE_STATUS_OUT_ONLY ; Only ACK the Status Out
07B8: 8E D2    JMP   0x068B        (0588)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0589) 
                                   (0590) ; Jump here to determine how many bytes should we transfer
                                   (0591) .cont:
07BA: 3C 15 00 CMP   [21],0        (0592)     CMP     [USBUART_TransferSize], 0  ; Check the MSB
07BD: B0 0A    JNZ   0x07C8        (0593)     JNZ     .L1
                                   (0594) 
07BF: 3C 16 08 CMP   [22],8        (0595)     CMP     [USBUART_TransferSize+1], 8  ; Check the LSB
07C2: D0 05    JNC   0x07C8        (0596)     JNC     .L1
                                   (0597) 
07C4: 51 16    MOV   A,[22]        (0598)     MOV     A,[USBUART_TransferSize+1]   ; Transfer all the remaining data
07C6: 80 03    JMP   0x07CA        (0599)     JMP     .L3
                                   (0600) 
                                   (0601) .L1:
07C8: 50 08    MOV   A,8           (0602)     MOV     A, 8                       ; Just transfer the next 8 bytes
                                   (0603) 
                                   (0604) .L3:
                                   (0605) 
07CA: 14 16    SUB   [22],A        (0606)     SUB     [USBUART_TransferSize+1],A   ; Update the bytes remaining
07CC: 1E 15 00 SBB   [21],0        (0607)     SBB     [USBUART_TransferSize],0
                                   (0608) 
07CF: 53 23    MOV   [35],A        (0609)     MOV     [USBUART_t2],A             ; Save the count
07D1: 57 00    MOV   X,0           (0610)     MOV     X,0
                                   (0611) 
07D3: 3C 14 00 CMP   [20],0        (0612)     CMP     [USBUART_DataSource],USB_DS_ROM  ; RAM or ROM copy?
07D6: B0 17    JNZ   0x07EE        (0613)     JNZ     .RAM_COPY
                                   (0614) 
                                   (0615) ; Copy data from a ROM source
                                   (0616) .ROM_COPY:
07D8: 10       PUSH  X             (0617)     PUSH    X                          ; Save the destination offset
07D9: 51 17    MOV   A,[23]        (0618)     MOV     A,[USBUART_DataPtr]        ; Get the transfer source MSB
07DB: 58 18    MOV   X,[24]        (0619)     MOV     X,[USBUART_DataPtr+1]      ; Set the transfer source LSB
07DD: 76 18    INC   [24]          (0620)     INC     [USBUART_DataPtr+1]        ; Increment the data pointer
07DF: 0E 17 00 ADC   [23],0        (0621)     ADC     [USBUART_DataPtr], 0       ;   MSB if necessary
                                   (0622) 
07E2: 28       ROMX                (0623)     ROMX                               ; Get the data byte
                                   (0624) 
07E3: 20       POP   X             (0625)     POP     X                          ; Get the destination offset
07E4: 61 58    MOV   REG[X+88],A   (0626)     MOV     REG[X + USBUART_EP0DATA], A; Load the data
07E6: 75       INC   X             (0627)     INC     X                          ; Bump the destination offset
07E7: 5B       MOV   A,X           (0628)     MOV     A,X                        ; Are we done?
07E8: 3A 23    CMP   A,[35]        (0629)     CMP     A, [USBUART_t2]
07EA: CF ED    JC    0x07D8        (0630)     JC      .ROM_COPY                  ; Not done
07EC: 80 0B    JMP   0x07F8        (0631)     JMP     .START_TRANSFER            ; Otherwise go start the transfer
                                   (0632) 
                                   (0633) ; Copy data from a RAM source
                                   (0634) .RAM_COPY:
07EE: 3E 18    MVI   A,[24]        (0635)     MVI     A, [USBUART_DataPtr+1]     ; Get the data, bump the source
                                   (0636) 
07F0: 61 58    MOV   REG[X+88],A   (0637)     MOV     REG[X +USBUART_EP0DATA], A ; Load the data
07F2: 75       INC   X             (0638)     INC     X                          ; Bump the destination offset
07F3: 5B       MOV   A,X           (0639)     MOV     A,X                        ; Are we done?
07F4: 3A 23    CMP   A,[35]        (0640)     CMP     A, [USBUART_t2]
07F6: CF F7    JC    0x07EE        (0641)     JC      .RAM_COPY                  ; Not done
                                   (0642) 
                                   (0643) ;; Set up the IN transfer count/mode/etc
                                   (0644) ;    A contains the byte count
                                   (0645) .START_TRANSFER:
07F8: 53 0A    MOV   [10],A        (0646)     MOV     [USBUART_LastSize], A      ; Save the packet size
                                   (0647) 
07FA: 50 01    MOV   A,1           (0648)     MOV     A, 1
07FC: 22 1D    AND   A,[29]        (0649)     AND     A, [USBUART_EP0DataToggle]
07FE: A0 03    JZ    0x0802        (0650)     JZ      .BYPASS_T1
0800: 50 80    MOV   A,128         (0651)     MOV     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
                                   (0652) 
                                   (0653) .BYPASS_T1:
0802: 2A 0A    OR    A,[10]        (0654)     OR      A, [USBUART_LastSize]
0804: 36 1D 01 XOR   [29],1        (0655)     XOR     [USBUART_EP0DataToggle], 1    ; Update the data toggle for next time
                                   (0656) 
0807: 57 0F    MOV   X,15          (0657)     MOV    X, USB_MODE_ACK_IN_STATUS_OUT  ; Set the mode register
0809: 8E 81    JMP   0x068B        (0658)     JMP    USBUART_EP0_UPD_MODE_EXIT
                                   (0659) 
                                   (0660) 
                                   (0661) ;-----------------------------------------------------------------------------
                                   (0662) ;  FUNCTION NAME: USBUART_GetTableEntry
                                   (0663) ;
                                   (0664) ;  DESCRIPTION: This function figures out based on the various bytes in the
                                   (0665) ;               setup packet where to get the data from or put the data to.
                                   (0666) ;               Transfer Data structures are defined each of the supported
                                   (0667) ;               control transfers, this function finds the right one and
                                   (0668) ;               saves it in the CurrentTD structure in RAM.  It then
                                   (0669) ;               calls InitControlRead or InitControlWrite to being the
                                   (0670) ;               transaction.
                                   (0671) ;
                                   (0672) ;-----------------------------------------------------------------------------
                                   (0673) EXPORT USBUART_GetTableEntry
                                   (0674) USBUART_GetTableEntry:
                                   (0675) 
080B: 75       INC   X             (0676)     INC     X                          ; Point to the first table entry
080C: 09 00    ADC   A,0           (0677)     ADC     A, 0                       ;
080E: 08       PUSH  A
                                   (0678) 
080F: 65 23    ASL   [35]          (0679)     TD_INDEX_TO_OFFSET USBUART_t2 ; Convert the index
0811: 65 23    ASL   [35]
0813: 65 23    ASL   [35]
0815: 18       POP   A
                                   (0680) 
0816: 4B       SWAP  A,X           (0681)     SWAP    A, X
0817: 02 23    ADD   A,[35]        (0682)     ADD     A, [USBUART_t2]
0819: 4B       SWAP  A,X           (0683)     SWAP    A, X
081A: 09 00    ADC   A,0           (0684)     ADC     A, 0                       ; A:X now points to the descriptor table entry we want
                                   (0685) 
                                   (0686) ; Flow here to load the Transfer Descriptor (TD_ENTRY)
081C: 55 23 14 MOV   [35],20       (0687)     MOV     [USBUART_t2], USBUART_CurrentTD  ; Use Temp as MVI pointer
081F: 90 26    CALL  0x0847        (0688)     CALL     USBUART_GETBYTE           ; Get the descriptor data source
0821: 90 1C    CALL  0x083F        (0689)     CALL     USBUART_GETWORD           ; Get the descriptor size
0823: 90 1A    CALL  0x083F        (0690)     CALL     USBUART_GETWORD           ; Get the descriptor address
0825: 90 18    CALL  0x083F        (0691)     CALL     USBUART_GETWORD           ; Get the Status Pointer
                                   (0692) ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
0827: 5D 58    MOV   A,REG[88]     (0693)     MOV    A, REG[USBUART_EP0DATA+bmRequestType] ; Get bmRequestType
0829: 21 80    AND   A,128         (0694)     AND     A,0x80                          ; Control Read or Write
082B: A0 03    JZ    0x082F        (0695)     JZ      .control_write
                                   (0696) 
082D: 8E A3    JMP   0x06D1        (0697)     JMP     USBUART_InitControlRead
                                   (0698) 
                                   (0699) .control_write:
082F: 8E E8    JMP   0x0718        (0700)     JMP     USBUART_InitControlWrite
                                   (0701) 
                                   (0702) 
                                   (0703) ;-----------------------------------------------------------------------------
                                   (0704) ;  FUNCTION NAME: USBUART_LOOKUP
                                   (0705) ;
                                   (0706) ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
                                   (0707) ;
                                   (0708) ;-----------------------------------------------------------------------------
                                   (0709) ;
                                   (0710) ;  ARGUMENTS:    A:X Point to the lookup table
                                   (0711) ;                USBUART_t2 contain the table index
                                   (0712) ;
                                   (0713) ;  RETURNS:      Address of the LT_ENTRY in A:X
                                   (0714) ;
                                   (0715) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0716) ;
                                   (0717) ;  THEORY of OPERATION or PROCEDURE:
                                   (0718) ;
                                   (0719) ;-----------------------------------------------------------------------------
                                   (0720) EXPORT USBUART_LOOKUP
                                   (0721) USBUART_LOOKUP:
0831: 75       INC   X             (0722)     INC     X                          ; Point to the first table entry
0832: 09 00    ADC   A,0           (0723)     ADC     A, 0                       ;
0834: 65 23    ASL   [35]
                                   (0724) 
0836: 65 23    ASL   [35]          (0725)     LT_INDEX_TO_OFFSET USBUART_t2      ; Convert the index
0838: 4B       SWAP  A,X           (0726)     SWAP    A, X
0839: 02 23    ADD   A,[35]        (0727)     ADD     A, [USBUART_t2]            ;
083B: 4B       SWAP  A,X           (0728)     SWAP    A, X
083C: 09 00    ADC   A,0           (0729)     ADC     A, 0
083E: 7F       RET                 (0730)     RET
                                   (0731) 
                                   (0732) 
                                   (0733) ;-----------------------------------------------------------------------------
                                   (0734) ;  FUNCTION NAME: USBUART_GETWORD/USBUART_GETBYTE
                                   (0735) ;
                                   (0736) ;  DESCRIPTION:    Get a word value from ROM
                                   (0737) ;
                                   (0738) ;-----------------------------------------------------------------------------
                                   (0739) ;
                                   (0740) ;  ARGUMENTS:    A:X is the ROM Address
                                   (0741) ;                USBUART_t2 is the destination address
                                   (0742) ;
                                   (0743) ;  RETURNS:      USBUART_t1
                                   (0744) ;
                                   (0745) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0746) ;                USES USBUART_t2
                                   (0747) ;                A:X points to the subsequent ROM location
                                   (0748) ;  THEORY of OPERATION or PROCEDURE:
                                   (0749) ;
                                   (0750) ;-----------------------------------------------------------------------------
                                   (0751) EXPORT USBUART_GETWORD
                                   (0752) USBUART_GETWORD:
                                   (0753) 
083F: 08       PUSH  A             (0754)     PUSH    A                          ; Don't loose the pointer MSB
0840: 28       ROMX                (0755)     ROMX                               ; Data source flag
0841: 3F 23    MVI   [35],A        (0756)     MVI     [USBUART_t2], A            ; Save the data source
0843: 18       POP   A             (0757)     POP     A                          ; Get the MSB back
0844: 75       INC   X             (0758)     INC     X                          ; Point to the next  entry
0845: 09 00    ADC   A,0           (0759)     ADC     A, 0                       ;
                                   (0760) 
                                   (0761) EXPORT USBUART_GETBYTE
                                   (0762) USBUART_GETBYTE:
                                   (0763) 
0847: 08       PUSH  A             (0764)     PUSH    A                          ; Don't loose the pointer MSB
0848: 28       ROMX                (0765)     ROMX                               ; Data source flag
0849: 3F 23    MVI   [35],A        (0766)     MVI     [USBUART_t2], A            ; Save the data source
084B: 18       POP   A             (0767)     POP     A                          ; Get the MSB back
084C: 75       INC   X             (0768)     INC     X                          ; Point to the next  entry
084D: 09 00    ADC   A,0           (0769)     ADC     A, 0                       ;
084F: 7F       RET                 (0770)     RET
                                   (0771) 
                                   (0772) 
                                   (0773) ;-----------------------------------------------------------------------------
                                   (0774) ;  FUNCTION NAME: USBUART_GET_DEVICE_TABLE_ENTRY
                                   (0775) ;
                                   (0776) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                   (0777) ;                  Not intended for use by C functions
                                   (0778) ;
                                   (0779) ;-----------------------------------------------------------------------------
                                   (0780) ;
                                   (0781) ;  ARGUMENTS:
                                   (0782) ;
                                   (0783) ;  RETURNS:        A:X points the current DEVICE_TABLE entry
                                   (0784) ;                  Carry flag is set if the current device index is out of range
                                   (0785) ;
                                   (0786) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0787) ;
                                   (0788) ;  THEORY of OPERATION or PROCEDURE:
                                   (0789) ;
                                   (0790) ;-----------------------------------------------------------------------------
                                   (0791) EXPORT USBUART_GET_DEVICE_TABLE_ENTRY
                                   (0792) USBUART_GET_DEVICE_TABLE_ENTRY:
0850: 5F 23 00 MOV   [35],[0]      (0793)     MOV     [USBUART_t2], [USBUART_bCurrentDevice]  ; Use the UM temp var--Selector
                                   (0794) 
0853: 50 01    MOV   A,1           (0795)     MOV     A,>USBUART_DEVICE_LOOKUP   ; Get the ROM Address MSB
0855: 57 D9    MOV   X,217         (0796)     MOV     X,<USBUART_DEVICE_LOOKUP   ; Get the ROM Address LSB
0857: 28       ROMX                (0797)     ROMX                               ; First entry is the table size (only a byte)
0858: 3A 23    CMP   A,[35]        (0798)     CMP     A, [USBUART_t2]            ; Range check
085A: 50 01    MOV   A,1           (0799)     MOV     A,>USBUART_DEVICE_LOOKUP   ; Get the ROM Address MSB
085C: C0 03    JC    0x0860        (0800)     JC      .exit
                                   (0801) ; Flow here if the index is valid
085E: 9F D1    CALL  0x0831        (0802)     CALL    USBUART_LOOKUP             ; Look up the configuration
                                   (0803) ; Jump or flow here on exit
                                   (0804) .exit:
0860: 7F       RET                 (0805)     RET
                                   (0806) 
                                   (0807) 
                                   (0808) ;-----------------------------------------------------------------------------
                                   (0809) ;  FUNCTION NAME: USBUART_GET_CONFIG_TABLE_ENTRY
                                   (0810) ;
                                   (0811) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                   (0812) ;                  Not intended for use by C functions
                                   (0813) ;                  Does not do range checking on
                                   (0814) ;
                                   (0815) ;-----------------------------------------------------------------------------
                                   (0816) ;
                                   (0817) ;  ARGUMENTS:
                                   (0818) ;
                                   (0819) ;  RETURNS:        A:X points the current CONFIG_TABLE entry
                                   (0820) ;                  Carry flag is set if the current device index is out of range
                                   (0821) ;
                                   (0822) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0823) ;
                                   (0824) ;  THEORY of OPERATION or PROCEDURE:
                                   (0825) ;
                                   (0826) ;-----------------------------------------------------------------------------
                                   (0827) EXPORT USBUART_GET_CONFIG_TABLE_ENTRY
                                   (0828) USBUART_GET_CONFIG_TABLE_ENTRY:
0861: 9F ED    CALL  0x0850        (0829)     CALL    USBUART_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
0863: 55 23 24 MOV   [35],36       (0830)     MOV     [USBUART_t2],USBUART_t1    ; Set the GETWORD destination
0866: 9F D7    CALL  0x083F        (0831)     CALL    USBUART_GETWORD            ; Get the pointer to the CONFIG_LOOKUP table
                                   (0832)                                        ; ITempW has the address
0868: 5D 5A    MOV   A,REG[90]     (0833)     MOV     A, REG[USBUART_EP0DATA+wValueLo]  ; Get the configuration number
086A: 53 23    MOV   [35],A        (0834)     MOV     [USBUART_t2],A             ; Save it
086C: 51 24    MOV   A,[36]        (0835)     MOV     A, [USBUART_t1]            ; Get the CONFIG_LOOKUP ROM Address MSB
086E: 58 25    MOV   X,[37]        (0836)     MOV     X, [USBUART_t1+1]          ; Get the CONFIG_LOOKUP ROM Address LSB
                                   (0837) 
                                   (0838) ; A:X Points to the CONFIG_LOOKUP, so get the current entry
0870: 5F 23 01 MOV   [35],[1]      (0839)     MOV     [USBUART_t2], [USBUART_Configuration] ; Get the configuration number
0873: 7A 23    DEC   [35]          (0840)     DEC     [USBUART_t2]               ; We don't populate the 0th entry
0875: 9F BA    CALL  0x0831        (0841)     CALL    USBUART_LOOKUP             ; Look up the configuration
0877: 7F       RET                 (0842)     RET
                                   (0843) 
                                   (0844) 
                                   (0845) ;-----------------------------------------------------------------------------
                                   (0846) ;  FUNCTION NAME: USBUART_UpdateStatusBlock
                                   (0847) ;
                                   (0848) ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
                                   (0849) ;                  block is updated with the completion code from the
                                   (0850) ;                  argument (A) and the _TransferByteCount.
                                   (0851) ;
                                   (0852) ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
                                   (0853) ;                  to make sure no other updates are made to the StatusBlock by
                                   (0854) ;                  the USB User Module.
                                   (0855) ;
                                   (0856) ;-----------------------------------------------------------------------------
                                   (0857) ;
                                   (0858) ;  ARGUMENTS:      A contains the Completion Status Code
                                   (0859) ;
                                   (0860) ;  RETURNS:        None
                                   (0861) ;
                                   (0862) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0863) ;
                                   (0864) ;  THEORY of OPERATION or PROCEDURE:
                                   (0865) ;
                                   (0866) ;-----------------------------------------------------------------------------
                                   (0867) USBUART_UpdateStatusBlock:
0878: 58 1A    MOV   X,[26]        (0868)     MOV     X, [USBUART_StatusBlockPtr + 1] ;
087A: 4B       SWAP  A,X           (0869)     SWAP    A, X                       ; Don't loose the completion code
087B: 39 00    CMP   A,0           (0870)     CMP     A, 0                       ; NULL?
087D: A0 0F    JZ    0x088D        (0871)     JZ      .done                      ; No update on NULL
                                   (0872) ; Flow here to update the VSR Completion Status Block
087F: 4B       SWAP  A,X           (0873)     SWAP    A, X                       ; Completion code A, Pointer in X
0880: 54 00    MOV   [X+0],A       (0874)     MOV     [X + 0], A                 ; Update the completion Code
0882: 51 1B    MOV   A,[27]        (0875)     MOV     A, [USBUART_TransferByteCount] ; Actual Byte Count MSB
0884: 54 01    MOV   [X+1],A       (0876)     MOV     [X + 1], A
0886: 51 1C    MOV   A,[28]        (0877)     MOV     A, [USBUART_TransferByteCount + 1] ; Actual Byte Count LSB
0888: 54 02    MOV   [X+2],A       (0878)     MOV     [X + 2], A
088A: 55 1A 00 MOV   [26],0        (0879)     MOV     [USBUART_StatusBlockPtr + 1], 0 ; Clear the Block Pointer
                                   (0880) .done:
088D: 7F       RET                 (0881)     RET                                ; All done
                                   (0882) 
                                   (0883) 
                                   (0884) ;-----------------------------------------------------------------------------
                                   (0885) ;  FUNCTION NAME: USBUART_InitializeStatusBlock
                                   (0886) ;
                                   (0887) ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
                                   (0888) ;                  The completion code is set to USB_XFER_IDLE.
                                   (0889) ;
                                   (0890) ;-----------------------------------------------------------------------------
                                   (0891) ;
                                   (0892) ;  ARGUMENTS:      None
                                   (0893) ;
                                   (0894) ;  RETURNS:        None
                                   (0895) ;
                                   (0896) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0897) ;
                                   (0898) ;  THEORY of OPERATION or PROCEDURE:
                                   (0899) ;
                                   (0900) ;-----------------------------------------------------------------------------
                                   (0901) USBUART_InitializeStatusBlock:
088E: 51 1A    MOV   A,[26]        (0902)     MOV     A, [USBUART_StatusBlockPtr + 1] ;
0890: 39 00    CMP   A,0           (0903)     CMP     A, 0                       ; NULL?
0892: A0 0B    JZ    0x089E        (0904)     JZ      .done                      ; No update on NULL
                                   (0905) ; Flow here to initialize the Completion Status Block
0894: 4B       SWAP  A,X           (0906)     SWAP    A, X                       ; Pointer in X
0895: 56 00 00 MOV   [X+0],0       (0907)     MOV     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
0898: 55 1B 00 MOV   [27],0        (0908)     MOV     [USBUART_TransferByteCount], 0 ; Clear the byte count
089B: 55 1C 00 MOV   [28],0        (0909)     MOV     [USBUART_TransferByteCount + 1], 0 ;
                                   (0910) .done:
089E: 7F       RET                 (0911)     RET                                ; All done
                                   (0912) 
                                   (0913) 
                                   (0914) ;-----------------------------------------------------------------------------
                                   (0915) ;  FUNCTION NAME: ;  USB 1st Tier Dispatch Jump Table (based on bmRequestType)
                                   (0916) ;
                                   (0917) ;  DESCRIPTION:
                                   (0918) ;
                                   (0919) ;-----------------------------------------------------------------------------
                                   (0920) ;
                                   (0921) ;  ARGUMENTS:
                                   (0922) ;
                                   (0923) ;  RETURNS:
                                   (0924) ;
                                   (0925) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0926) ;
                                   (0927) ;  THEORY of OPERATION or PROCEDURE:
                                   (0928) ;
                                   (0929) ;-----------------------------------------------------------------------------
                                   (0930) MACRO BMREQUEST_DISPATCH
                                   (0931) IF (USB_CB_@0_@1_@2 & 1)
                                   (0932)     JMP     USBUART_DT_@0_@1_@2_Dispatch
                                   (0933) ELSE
                                   (0934)     JMP     USBUART_Not_Supported_Local_Drv
                                   (0935) ENDIF
                                   (0936) ENDM
                                   (0937) 
                                   (0938) USBUART_DT_bmRequestType::
089F: 8D 3C    JMP   0x05DC        (0939)     BMREQUEST_DISPATCH    h2d,std,dev
08A1: 8D 71    JMP   0x0613        (0940)     BMREQUEST_DISPATCH    h2d,std,ifc
08A3: 8D A9    JMP   0x064D        (0941)     BMREQUEST_DISPATCH    h2d,std,ep
08A5: 80 43    JMP   0x08E9        (0942)     BMREQUEST_DISPATCH    h2d,std,oth
08A7: 80 41    JMP   0x08E9        (0943)     BMREQUEST_DISPATCH    h2d,cls,dev
08A9: 81 A2    JMP   0x0A4C        (0944)     BMREQUEST_DISPATCH    h2d,cls,ifc
08AB: 80 3D    JMP   0x08E9        (0945)     BMREQUEST_DISPATCH    h2d,cls,ep
08AD: 80 3B    JMP   0x08E9        (0946)     BMREQUEST_DISPATCH    h2d,cls,oth
08AF: 80 39    JMP   0x08E9        (0947)     BMREQUEST_DISPATCH    h2d,vnd,dev
08B1: 80 37    JMP   0x08E9        (0948)     BMREQUEST_DISPATCH    h2d,vnd,ifc
08B3: 80 35    JMP   0x08E9        (0949)     BMREQUEST_DISPATCH    h2d,vnd,ep
08B5: 80 33    JMP   0x08E9        (0950)     BMREQUEST_DISPATCH    h2d,vnd,oth
08B7: 80 31    JMP   0x08E9        (0951)     BMREQUEST_DISPATCH    h2d,rsv,dev
08B9: 80 2F    JMP   0x08E9        (0952)     BMREQUEST_DISPATCH    h2d,rsv,ifc
08BB: 80 2D    JMP   0x08E9        (0953)     BMREQUEST_DISPATCH    h2d,rsv,ep
08BD: 80 2B    JMP   0x08E9        (0954)     BMREQUEST_DISPATCH    h2d,rsv,oth
08BF: 8C FC    JMP   0x05BC        (0955)     BMREQUEST_DISPATCH    d2h,std,dev
08C1: 8D 3C    JMP   0x05FE        (0956)     BMREQUEST_DISPATCH    d2h,std,ifc
08C3: 8D 64    JMP   0x0628        (0957)     BMREQUEST_DISPATCH    d2h,std,ep
08C5: 80 23    JMP   0x08E9        (0958)     BMREQUEST_DISPATCH    d2h,std,oth
08C7: 80 21    JMP   0x08E9        (0959)     BMREQUEST_DISPATCH    d2h,cls,dev
08C9: 81 D2    JMP   0x0A9C        (0960)     BMREQUEST_DISPATCH    d2h,cls,ifc
08CB: 80 1D    JMP   0x08E9        (0961)     BMREQUEST_DISPATCH    d2h,cls,ep
08CD: 80 1B    JMP   0x08E9        (0962)     BMREQUEST_DISPATCH    d2h,cls,oth
08CF: 80 19    JMP   0x08E9        (0963)     BMREQUEST_DISPATCH    d2h,vnd,dev
08D1: 80 17    JMP   0x08E9        (0964)     BMREQUEST_DISPATCH    d2h,vnd,ifc
08D3: 80 15    JMP   0x08E9        (0965)     BMREQUEST_DISPATCH    d2h,vnd,ep
08D5: 80 13    JMP   0x08E9        (0966)     BMREQUEST_DISPATCH    d2h,vnd,oth
08D7: 80 11    JMP   0x08E9        (0967)     BMREQUEST_DISPATCH    d2h,rsv,dev
08D9: 80 0F    JMP   0x08E9        (0968)     BMREQUEST_DISPATCH    d2h,rsv,ifc
08DB: 80 0D    JMP   0x08E9        (0969)     BMREQUEST_DISPATCH    d2h,rsv,ep
08DD: 80 0B    JMP   0x08E9        (0970)     BMREQUEST_DISPATCH    d2h,rsv,oth
08DF: 39 20    CMP   A,32
                                   (0971) USBUART_DT_End:
                                   (0972) USBUART_DT_Size: equ (USBUART_DT_End-USBUART_DT_bmRequestType) / 2
                                   (0973) USBUART_bmRequestType_Dispatch::
08E1: D0 04    JNC   0x08E6        (0974)     DISPATCHER USBUART_DT_bmRequestType, USBUART_DT_Size, USBUART_Not_Supported_Local_Drv
08E3: 64       ASL   A
08E4: EF BA    JACC  0x089F
08E6: 7D 08 E9 LJMP  0x08E9
                                   (0975) 
                                   (0976) USBUART_Not_Supported_Local_Drv:
08E9: 7D 03 BE LJMP  0x03BE        (0977)         LJMP     USBUART_Not_Supported
08EC: 12 01    SUB   A,[1]
08EE: 00       SWI   
08EF: 02 02    ADD   A,[2]
08F1: 00       SWI   
08F2: 00       SWI   
08F3: 08       PUSH  A
08F4: B4 04    JNZ   0x0CF9
08F6: 00       SWI   
08F7: 50 00    MOV   A,0
08F9: 00       SWI   
08FA: 01 02    ADD   A,2
08FC: 04 01    ADD   [1],A
08FE: 09 02    ADC   A,2
0900: 43 00 02 OR    REG[0],2
0903: 01 03    ADD   A,3
0905: 80 32    JMP   0x0938
0907: 09 04    ADC   A,4
0909: 00       SWI   
090A: 00       SWI   
090B: 01 02    ADD   A,2
090D: 02 01    ADD   A,[1]
090F: 00       SWI   
0910: 05 24    ADD   [X+36],A
0912: 00       SWI   
0913: 10       PUSH  X
0914: 01 04    ADD   A,4
0916: 24 02    AND   [2],A
0918: 02 05    ADD   A,[5]
091A: 24 06    AND   [6],A
091C: 00       SWI   
091D: 01 05    ADD   A,5
091F: 24 01    AND   [1],A
0921: 00       SWI   
0922: 01 07    ADD   A,7
0924: 05 81    ADD   [X-127],A
0926: 03 08    ADD   A,[X+8]
0928: 00       SWI   
0929: 02 09    ADD   A,[9]
092B: 04 01    ADD   [1],A
092D: 00       SWI   
092E: 02 0A    ADD   A,[10]
0930: 00       SWI   
0931: 00       SWI   
0932: 00       SWI   
0933: 07 05 82 ADD   [X+5],130
0936: 02 40    ADD   A,[pData+2]
0938: 00       SWI   
0939: 00       SWI   
093A: 07 05 03 ADD   [X+5],3
093D: 02 40    ADD   A,[pData+2]
093F: 00       SWI   
0940: 00       SWI   
0941: 04 00    ADD   [0],A
0943: 00       SWI   
0944: 04 09    ADD   [9],A
0946: 6A       RLC   A
0947: 00       SWI   
0948: 00       SWI   
0949: DE 00    JNC   0x074A
094B: 00       SWI   
094C: 2C 09    OR    [9],A
094E: 6E 00    RRC   [0]
0950: 00       SWI   
0951: DE 00    JNC   0x0752
0953: 00       SWI   
0954: 22 09    AND   A,[9]
0956: 9A 00    CALL  0x0358
0958: 00       SWI   
0959: DE 00    JNC   0x075A
095B: 00       SWI   
095C: 2E 09 BC OR    [9],188
095F: 00       SWI   
0960: 00       SWI   
0961: DE 00    JNC   0x0762
0963: 00       SWI   
0964: 0A 09    ADC   A,[9]
0966: EA 00    JACC  0x0367
0968: 00       SWI   
0969: DE 04    JNC   0x076E
096B: 03 09    ADD   A,[X+9]
096D: 04 2C    ADD   [44],A
096F: 03 43    ADD   A,[X+67]
0971: 00       SWI   
0972: 79       DEC   X
0973: 00       SWI   
0974: 70 00    AND   F,0
0976: 72 00    XOR   F,0
0978: 65 00    ASL   [0]
097A: 73       CPL   A
097B: 00       SWI   
097C: 73       CPL   A
097D: 00       SWI   
097E: 20       POP   X
097F: 00       SWI   
0980: 53 00    MOV   [0],A
0982: 65 00    ASL   [0]
0984: 6D       RRC   A
0985: 00       SWI   
0986: 69 00    ASR   [X+0]
0988: 63 00 6F MOV   REG[X+0],111
098B: 00       SWI   
098C: 6E 00    RRC   [0]
098E: 64       ASL   A
098F: 00       SWI   
0990: 75       INC   X
0991: 00       SWI   
0992: 63 00 74 MOV   REG[X+0],116
0995: 00       SWI   
0996: 6F 00    RRC   [X+0]
0998: 72 00    XOR   F,0
099A: 22 03    AND   A,[3]
099C: 43 00 59 OR    REG[0],89
099F: 00       SWI   
09A0: 38 00    ADD   SP,0
09A2: 43 00 32 OR    REG[0],50
09A5: 00       SWI   
09A6: 34 00    XOR   [0],A
09A8: 37 00 39 XOR   [X+0],57
09AB: 00       SWI   
09AC: 34 00    XOR   [0],A
09AE: 2D 00    OR    [X+0],A
09B0: 32 00    XOR   A,[0]
09B2: 34 00    XOR   [0],A
09B4: 4C 00    SWAP  A,[0]
09B6: 46 00 58 XOR   REG[X+0],88
09B9: 00       SWI   
09BA: 49 00 2E TST   REG[0],46
09BD: 03 55    ADD   A,[X+85]
09BF: 00       SWI   
09C0: 53 00    MOV   [0],A
09C2: 42 00 2D AND   REG[X+0],45
09C5: 00       SWI   
09C6: 55 00 41 MOV   [0],65
09C9: 00       SWI   
09CA: 52 00    MOV   A,[X+0]
09CC: 54 00    MOV   [X+0],A
09CE: 20       POP   X
09CF: 00       SWI   
09D0: 43 00 6F OR    REG[0],111
09D3: 00       SWI   
09D4: 6E 00    RRC   [0]
09D6: 66 00    ASL   [X+0]
09D8: 69 00    ASR   [X+0]
09DA: 67       ASR   A
09DB: 00       SWI   
09DC: 75       INC   X
09DD: 00       SWI   
09DE: 72 00    XOR   F,0
09E0: 61 00    MOV   REG[X+0],A
09E2: 74       INC   A
09E3: 00       SWI   
09E4: 69 00    ASR   [X+0]
09E6: 6F 00    RRC   [X+0]
09E8: 6E 00    RRC   [0]
09EA: 0A 03    ADC   A,[3]
09EC: 30       HALT  
09ED: 00       SWI   
09EE: 30       HALT  
09EF: 00       SWI   
09F0: 30       HALT  
09F1: 00       SWI   
09F2: 30       HALT  
09F3: 00       SWI   
09F4: 00       SWI   
09F5: 01 00    ADD   A,0
09F7: 08       PUSH  A
09F8: 00       SWI   
09F9: 2B 00    OR    A,[X+0]
09FB: 00       SWI   
09FC: DE 00    JNC   0x07FD
09FE: 01 00    ADD   A,0
0A00: 07 00 33 ADD   [X+0],51
0A03: 00       SWI   
0A04: 00       SWI   
0A05: DE 80    JNC   0x0886

FILE: lib\usbuart_cls_cdc.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USBUART_cls_cdc.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/10/20 at 16:08:45 
                                   (0005) ;; Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: Communication Device Class (CDC) request implementation
                                   (0008) ;;               for the CY8C24090 and CY7C64215 family of devices
                                   (0009) ;;
                                   (0010) ;;  Copyright (c) Cypress Semiconductor 2006. All Rights Reserved.
                                   (0011) ;;*****************************************************************************
                                   (0012) ;;*****************************************************************************
                                   (0013) 
                                   (0014) include "m8c.inc"
                                   (0015) include "USBUART_macros.inc"
                                   (0016) include "USBUART.inc"
                                   (0017) include "memory.inc"
                                   (0018) 
                                   (0019) AREA InterruptRAM (RAM,REL,CON)
                                   (0020) 
                                   (0021) DummyBuffer:
                                   (0022) 	BLK 8	; dummy buffer for SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE requests
                                   (0023) 
                                   (0024) EXPORT USBUART_LineCoding
                                   (0025) EXPORT _USBUART_LineCoding
                                   (0026) USBUART_LineCoding:
                                   (0027) _USBUART_LineCoding:
                                   (0028) 	BLK	4	;dwDTERate		Data terminal rate, in bits per second 
                                   (0029) 	BLK 1	;bCharFormat		Stop bits (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                   (0030) 	BLK	1	;bParityType		Parity (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                   (0031) 	BLK 1	;bDataBits			Data bits (5,6,7,8 or 16)
                                   (0032) 
                                   (0033) EXPORT USBUART_LineControlBitmap 
                                   (0034) EXPORT _USBUART_LineControlBitmap 
                                   (0035) USBUART_LineControlBitmap:: 
                                   (0036) _USBUART_LineControlBitmap: 
                                   (0037)     BLK 2   ; Line control bitmap
                                   (0038)     		;	D15..D2 - reserved
                                   (0039)     		;   D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                   (0040)     		;	D0 - DTR (0 = not present, 1 = present)
                                   (0041) 	
                                   (0042) AREA UserModules (ROM, REL)
                                   (0043) 
                                   (0044) .LITERAL
                                   (0045) GetSetEncapsulatedCommand:
                                   (0046) 	TD_START_TABLE	1
                                   (0047) 	TD_ENTRY		USB_DS_RAM, 8, DummyBuffer, NULL_PTR
                                   (0048) 
                                   (0049) GetSetLineCodingTable:
                                   (0050)     TD_START_TABLE  1               
                                   (0051)     TD_ENTRY        USB_DS_RAM, 7, USBUART_LineCoding, NULL_PTR 
                                   (0052) .ENDLITERAL
                                   (0053) 
                                   (0054) ;-----------------------------------------------------------------------------
                                   (0055) ;  USB 2nd Tier Dispatch Jump Tables for CDC Requests (based on bRequest)
                                   (0056) ;-----------------------------------------------------------------------------
                                   (0057) ;  FUNCTION NAME: ;  USB 2nd Tier Dispatch Jump Table
                                   (0058) ;
                                   (0059) ;  DESCRIPTION:   The following tables dispatch to the Class request handler
                                   (0060) ;                 functions.  (Assumes bmRequestType(5:6) is 1, Class)
                                   (0061) ;-----------------------------------------------------------------------------
                                   (0062) USBUART_DT_h2d_cls_ifc:
0A07: A1 80    JZ    0x0B88        (0063)     jmp     USBUART_CB_h2d_cls_ifc_00			;00
0A09: E8 80    JACC  0x028A        (0064)     jmp     USBUART_Not_Supported_Local1		;01
0A0B: E6 80    JACC  0x108C        (0065)     jmp     USBUART_Not_Supported_Local1		;02
0A0D: E4 80    JACC  0x0E8E        (0066)     jmp     USBUART_Not_Supported_Local1		;03
0A0F: E2 80    JACC  0x0C90        (0067)     jmp     USBUART_Not_Supported_Local1		;04
0A11: E0 80    JACC  0x0A92        (0068)     jmp     USBUART_Not_Supported_Local1		;05
0A13: DE 80    JNC   0x0894        (0069)     jmp     USBUART_Not_Supported_Local1		;06
0A15: DC 80    JNC   0x0696        (0070)     jmp     USBUART_Not_Supported_Local1		;07
0A17: DA 80    JNC   0x0498        (0071)     jmp     USBUART_Not_Supported_Local1		;08
0A19: D8 80    JNC   0x029A        (0072)     jmp     USBUART_Not_Supported_Local1		;09
0A1B: D6 80    JNC   0x109C        (0073)     jmp     USBUART_Not_Supported_Local1		;0A
0A1D: D4 80    JNC   0x0E9E        (0074)     jmp     USBUART_Not_Supported_Local1		;0B
0A1F: D2 80    JNC   0x0CA0        (0075)     jmp     USBUART_Not_Supported_Local1		;0C
0A21: D0 80    JNC   0x0AA2        (0076)     jmp     USBUART_Not_Supported_Local1		;0D
0A23: CE 80    JC    0x08A4        (0077)     jmp     USBUART_Not_Supported_Local1		;0E
0A25: CC 80    JC    0x06A6        (0078)     jmp     USBUART_Not_Supported_Local1		;0F
0A27: CA 80    JC    0x04A8        (0079)     jmp     USBUART_Not_Supported_Local1		;10
0A29: C8 80    JC    0x02AA        (0080)     jmp     USBUART_Not_Supported_Local1		;11
0A2B: C6 80    JC    0x10AC        (0081)     jmp     USBUART_Not_Supported_Local1		;12
0A2D: C4 80    JC    0x0EAE        (0082)     jmp     USBUART_Not_Supported_Local1		;13
0A2F: C2 80    JC    0x0CB0        (0083)     jmp     USBUART_Not_Supported_Local1		;14
0A31: C0 80    JC    0x0AB2        (0084)     jmp     USBUART_Not_Supported_Local1		;15
0A33: BE 80    JNZ   0x08B4        (0085)     jmp     USBUART_Not_Supported_Local1		;16
0A35: BC 80    JNZ   0x06B6        (0086)     jmp     USBUART_Not_Supported_Local1		;17
0A37: BA 80    JNZ   0x04B8        (0087)     jmp     USBUART_Not_Supported_Local1		;18
0A39: B8 80    JNZ   0x02BA        (0088)     jmp     USBUART_Not_Supported_Local1		;19
0A3B: B6 80    JNZ   0x10BC        (0089)     jmp     USBUART_Not_Supported_Local1		;1A
0A3D: B4 80    JNZ   0x0EBE        (0090)     jmp     USBUART_Not_Supported_Local1		;1B
0A3F: B2 80    JNZ   0x0CC0        (0091)     jmp     USBUART_Not_Supported_Local1		;1C
0A41: B0 80    JNZ   0x0AC2        (0092)     jmp     USBUART_Not_Supported_Local1		;1D
0A43: AE 80    JZ    0x08C4        (0093)     jmp     USBUART_Not_Supported_Local1		;1E
0A45: AC 80    JZ    0x06C6        (0094)     jmp     USBUART_Not_Supported_Local1		;1F
0A47: 70 80    AND   F,128         (0095)     jmp     USBUART_CB_h2d_cls_ifc_20			;20
0A49: A8 80    JZ    0x02CA        (0096)     jmp     USBUART_Not_Supported_Local1		;21
0A4B: 7B 5D    DEC   [X+93]        (0097)     jmp     USBUART_CB_h2d_cls_ifc_22			;22
                                   (0098) USBUART_DT_h2d_cls_ifc_End:
                                   (0099) USBUART_DT_h2d_cls_ifc_Size: equ (USBUART_DT_h2d_cls_ifc_End-USBUART_DT_h2d_cls_ifc) / 2
                                   (0100) 
                                   (0101) USBUART_DT_h2d_cls_ifc_Dispatch::
0A4D: 59 39    MOV   X,[X+57]      (0102)     mov   A, REG[USBUART_EP0DATA + bRequest]       ; Get the request number
0A4F: 23 D0    AND   A,[X-48]
0A51: 04 64    ADD   [__r0],A      (0103)     DISPATCHER USBUART_DT_h2d_cls_ifc, USBUART_DT_h2d_cls_ifc_Size, USBUART_Not_Supported_Local1 
0A53: EF B2    JACC  0x0A06
0A55: 7D 0A F1 LJMP  0x0AF1
                                   (0104) 
                                   (0105) ;-----------------------------------------------------------------------------
                                   (0106) USBUART_DT_d2h_cls_ifc:
0A58: 80 98    JMP   0x0AF1        (0107)     jmp     USBUART_Not_Supported_Local1		;00
0A5A: 80 78    JMP   0x0AD3        (0108)     jmp     USBUART_CB_d2h_cls_ifc_01			;01
0A5C: 80 94    JMP   0x0AF1        (0109)     jmp     USBUART_Not_Supported_Local1		;02
0A5E: 80 92    JMP   0x0AF1        (0110)     jmp     USBUART_Not_Supported_Local1		;03
0A60: 80 90    JMP   0x0AF1        (0111)     jmp     USBUART_Not_Supported_Local1		;04
0A62: 80 8E    JMP   0x0AF1        (0112)     jmp     USBUART_Not_Supported_Local1		;05
0A64: 80 8C    JMP   0x0AF1        (0113)     jmp     USBUART_Not_Supported_Local1		;06
0A66: 80 8A    JMP   0x0AF1        (0114)     jmp     USBUART_Not_Supported_Local1		;07
0A68: 80 88    JMP   0x0AF1        (0115)     jmp     USBUART_Not_Supported_Local1		;08
0A6A: 80 86    JMP   0x0AF1        (0116)     jmp     USBUART_Not_Supported_Local1		;09
0A6C: 80 84    JMP   0x0AF1        (0117)     jmp     USBUART_Not_Supported_Local1		;0A
0A6E: 80 82    JMP   0x0AF1        (0118)     jmp     USBUART_Not_Supported_Local1		;0B
0A70: 80 80    JMP   0x0AF1        (0119)     jmp     USBUART_Not_Supported_Local1		;0C
0A72: 80 7E    JMP   0x0AF1        (0120)     jmp     USBUART_Not_Supported_Local1		;0D
0A74: 80 7C    JMP   0x0AF1        (0121)     jmp     USBUART_Not_Supported_Local1		;0E
0A76: 80 7A    JMP   0x0AF1        (0122)     jmp     USBUART_Not_Supported_Local1		;0F
0A78: 80 78    JMP   0x0AF1        (0123)     jmp     USBUART_Not_Supported_Local1		;10
0A7A: 80 76    JMP   0x0AF1        (0124)     jmp     USBUART_Not_Supported_Local1		;11
0A7C: 80 74    JMP   0x0AF1        (0125)     jmp     USBUART_Not_Supported_Local1		;12
0A7E: 80 72    JMP   0x0AF1        (0126)     jmp     USBUART_Not_Supported_Local1		;13
0A80: 80 70    JMP   0x0AF1        (0127)     jmp     USBUART_Not_Supported_Local1		;14
0A82: 80 6E    JMP   0x0AF1        (0128)     jmp     USBUART_Not_Supported_Local1		;15
0A84: 80 6C    JMP   0x0AF1        (0129)     jmp     USBUART_Not_Supported_Local1		;16
0A86: 80 6A    JMP   0x0AF1        (0130)     jmp     USBUART_Not_Supported_Local1		;17
0A88: 80 68    JMP   0x0AF1        (0131)     jmp     USBUART_Not_Supported_Local1		;18
0A8A: 80 66    JMP   0x0AF1        (0132)     jmp     USBUART_Not_Supported_Local1		;19
0A8C: 80 64    JMP   0x0AF1        (0133)     jmp     USBUART_Not_Supported_Local1		;1A
0A8E: 80 62    JMP   0x0AF1        (0134)     jmp     USBUART_Not_Supported_Local1		;1B
0A90: 80 60    JMP   0x0AF1        (0135)     jmp     USBUART_Not_Supported_Local1		;1C
0A92: 80 5E    JMP   0x0AF1        (0136)     jmp     USBUART_Not_Supported_Local1		;1D
0A94: 80 5C    JMP   0x0AF1        (0137)     jmp     USBUART_Not_Supported_Local1		;1E
0A96: 80 5A    JMP   0x0AF1        (0138)     jmp     USBUART_Not_Supported_Local1		;1F
0A98: 80 58    JMP   0x0AF1        (0139)     jmp     USBUART_Not_Supported_Local1		;20
0A9A: 80 47    JMP   0x0AE2        (0140)     jmp     USBUART_CB_d2h_cls_ifc_21			;21
                                   (0141) USBUART_DT_d2h_cls_ifc_End:
                                   (0142) USBUART_DT_d2h_cls_ifc_Size: equ (USBUART_DT_d2h_cls_ifc_End-USBUART_DT_d2h_cls_ifc) / 2
                                   (0143) 
                                   (0144) USBUART_DT_d2h_cls_ifc_Dispatch::
0A9C: 5D 59    MOV   A,REG[89]     (0145)     mov   A, REG[USBUART_EP0DATA + bRequest]       ; Get the request number
0A9E: 39 22    CMP   A,34
0AA0: D0 04    JNC   0x0AA5        (0146)     DISPATCHER USBUART_DT_d2h_cls_ifc, USBUART_DT_d2h_cls_ifc_Size, USBUART_Not_Supported_Local1 
0AA2: 64       ASL   A
0AA3: EF B4    JACC  0x0A58
0AA5: 7D 0A F1 LJMP  0x0AF1
                                   (0147) 
                                   (0148) ;-----------------------------------------------------------------------------
                                   (0149) ; FUNCTION NAME: USBUART_CB_h2d_cls_ifc_00
                                   (0150) ;-----------------------------------------------------------------------------
                                   (0151) ; CDC INTERFACE REQUEST: Send_Encapsulated_Command
                                   (0152) ;-----------------------------------------------------------------------------
                                   (0153) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                   (0154) ; bRequest       : SET_ENCAPSULATED_COMMAND		     	= 00h    
                                   (0155) ; wValue         : Zero		                    		= 0000h  
                                   (0156) ; wIndex         : INTERFACE                      		= --xxh
                                   (0157) ; wLength        : Amount of data, in bytes associated with recipient
                                   (0158) ; Data			 : Control protocol-based command (Dummy buffer)	
                                   (0159) ;-----------------------------------------------------------------------------
                                   (0160) USBUART_CB_h2d_cls_ifc_00:
0AA8: 5D 5C    MOV   A,REG[92]     (0161)     mov   A, REG[USBUART_EP0DATA+wIndexLo] ; Get the interface number
0AAA: 39 02    CMP   A,2           (0162)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0AAC: D0 44    JNC   0x0AF1        (0163)     jnc   USBUART_Not_Supported_Local1
0AAE: 53 23    MOV   [35],A        (0164)     mov   [USBUART_t2], A                  ; Selector
0AB0: 50 09    MOV   A,9           (0165)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0AB2: 57 F4    MOV   X,244         (0166)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0AB4: 7D 08 0B LJMP  0x080B        (0167)     ljmp   USBUART_GetTableEntry
                                   (0168) 
                                   (0169) ;-----------------------------------------------------------------------------
                                   (0170) ; FUNCTION NAME: USBUART_CB_h2d_cls_ifc_20
                                   (0171) ;-----------------------------------------------------------------------------
                                   (0172) ; CDC INTERFACE REQUEST: Set_Line_Coding
                                   (0173) ;-----------------------------------------------------------------------------
                                   (0174) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                   (0175) ; bRequest       : SET_LINE_CODING				     	= 20h    
                                   (0176) ; wValue         : Zero		                    		= 0000h  
                                   (0177) ; wIndex         : INTERFACE                      		= --xxh
                                   (0178) ; wLength        : Report Size                    		= 0007h  
                                   (0179) ; Data			 : Line Coding Structure	
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) USBUART_CB_h2d_cls_ifc_20:
0AB7: 5D 5C    MOV   A,REG[92]     (0182)     mov   A, REG[USBUART_EP0DATA+wIndexLo] ; Get the interface number
0AB9: 39 02    CMP   A,2           (0183)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0ABB: D0 35    JNC   0x0AF1        (0184)     jnc   USBUART_Not_Supported_Local1
0ABD: 53 23    MOV   [35],A        (0185)     mov   [USBUART_t2], A                  ; Selector
0ABF: 50 09    MOV   A,9           (0186)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0AC1: 57 FD    MOV   X,253         (0187)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0AC3: 7D 08 0B LJMP  0x080B        (0188)     ljmp   USBUART_GetTableEntry
                                   (0189) 
                                   (0190) ;-----------------------------------------------------------------------------
                                   (0191) ; FUNCTION NAME: USBUART_CB_h2d_cls_ifc_22
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ; CDC INTERFACE REQUEST: Set_Control_Line_State
                                   (0194) ;-----------------------------------------------------------------------------
                                   (0195) ; bmRequestType  : (H2D | CLASS | INTERFACE)      		= 21h
                                   (0196) ; bRequest       : SET_CONTROL_LINE_STATE		     	= 22h    
                                   (0197) ; wValue         : Control Signal Bitmap           		= xxxxh  
                                   (0198) ; wIndex         : INTERFACE                      		= --xxh
                                   (0199) ; wLength        : Report Size                    		= 0000h  
                                   (0200) ; Data			 : Line Coding Structure	
                                   (0201) ;-----------------------------------------------------------------------------
                                   (0202) USBUART_CB_h2d_cls_ifc_22:
0AC6: 5D 5C    MOV   A,REG[92]     (0203)     mov   A, REG[USBUART_EP0DATA+wIndexLo] ; Get the interface number
0AC8: 39 02    CMP   A,2           (0204)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0ACA: D0 26    JNC   0x0AF1        (0205)     jnc   USBUART_Not_Supported_Local1
0ACC: 5D 5A    MOV   A,REG[90]     (0206)     mov   A, REG[USBUART_EP0DATA+wValueLo] ; Get the bitmap
0ACE: 53 3B    MOV   [59],A        (0207)     mov   [USBUART_LineControlBitmap+1], A 
0AD0: 7D 07 0D LJMP  0x070D        (0208)     ljmp   USBUART_NoDataStageControlTransfer
                                   (0209) 
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: USBUART_CB_d2h_cls_ifc_01
                                   (0212) ;-----------------------------------------------------------------------------
                                   (0213) ; CDC INTERFACE REQUEST: Get_Encapsulated_Response
                                   (0214) ;-----------------------------------------------------------------------------
                                   (0215) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                   (0216) ; bRequest       : GET_ENCAPSULATED_RESPONSE	     	= 01h    
                                   (0217) ; wValue         : Zero		               				= 0000h  
                                   (0218) ; wIndex         : INTERFACE                      		= --xxh
                                   (0219) ; wLength        : Amount of data, in bytes associated with recipient
                                   (0220) ; Data			 : Control protocol-based data (Dummy buffer)	
                                   (0221) ;-----------------------------------------------------------------------------
                                   (0222) USBUART_CB_d2h_cls_ifc_01:
0AD3: 5D 5C    MOV   A,REG[92]     (0223)     mov   A, REG[USBUART_EP0DATA+wIndexLo] ; Get the interface number
0AD5: 39 02    CMP   A,2           (0224)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0AD7: D0 19    JNC   0x0AF1        (0225)     jnc   USBUART_Not_Supported_Local1
0AD9: 53 23    MOV   [35],A        (0226)     mov   [USBUART_t2], A                  ; Selector
0ADB: 50 09    MOV   A,9           (0227)     mov   A,>GetSetEncapsulatedCommand   ; Get the ROM Address MSB
0ADD: 57 F4    MOV   X,244         (0228)     mov   X,<GetSetEncapsulatedCommand   ; Get the ROM Address LSB
0ADF: 7D 08 0B LJMP  0x080B        (0229)     ljmp   USBUART_GetTableEntry
                                   (0230)     
                                   (0231) ;-----------------------------------------------------------------------------
                                   (0232) ;  FUNCTION NAME: USBUART_CB_d2h_cls_ifc_21
                                   (0233) ;-----------------------------------------------------------------------------
                                   (0234) ; CDC INTERFACE REQUEST: Get_Line_Coding
                                   (0235) ;-----------------------------------------------------------------------------
                                   (0236) ; bmRequestType  : (D2H | CLASS | INTERFACE)      		= A1h
                                   (0237) ; bRequest       : GET_LINE_CODING				     	= 21h    
                                   (0238) ; wValue         : Zero		               				= 0000h  
                                   (0239) ; wIndex         : INTERFACE                      		= --xxh
                                   (0240) ; wLength        : Report Size                    		= 0007h  
                                   (0241) ; Data			 : Line Coding Structure	
                                   (0242) ; 
                                   (0243) ;-----------------------------------------------------------------------------
                                   (0244) USBUART_CB_d2h_cls_ifc_21:
                                   (0245) 
0AE2: 5D 5C    MOV   A,REG[92]     (0246)     mov   A, REG[USBUART_EP0DATA+wIndexLo] ; Get the interface number
0AE4: 39 02    CMP   A,2           (0247)     cmp   A, 2                           ; Only for CDC interfaces (1 and 2)
0AE6: D0 0A    JNC   0x0AF1        (0248)     jnc   USBUART_Not_Supported_Local1
0AE8: 53 23    MOV   [35],A        (0249)     mov   [USBUART_t2], A                  ; Selector
0AEA: 50 09    MOV   A,9           (0250)     mov   A,>GetSetLineCodingTable       ; Get the ROM Address MSB
0AEC: 57 FD    MOV   X,253         (0251)     mov   X,<GetSetLineCodingTable       ; Get the ROM Address LSB
0AEE: 7D 08 0B LJMP  0x080B        (0252)     ljmp   USBUART_GetTableEntry
                                   (0253) 
                                   (0254) ;-----------------------------------------------------------------------------
                                   (0255) ;  FUNCTION NAME: USBUART_Not_Supported_Local1
                                   (0256) ;-----------------------------------------------------------------------------
                                   (0257) ;  Handle requests that are not supported
                                   (0258) ;-----------------------------------------------------------------------------
                                   (0259) USBUART_Not_Supported_Local1:
0AF1: 7D 03 BE LJMP  0x03BE        (0260) 	ljmp USBUART_Not_Supported

FILE: lib\usbuart.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;  FILENAME: USBUART.asm
                                   (0003) ;;   Version: 1.0, Updated on 2006/10/20 at 16:08:45
                                   (0004) ;;  Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0005) ;;
                                   (0006) ;;  DESCRIPTION: USBUART User Module Descriptors
                                   (0007) ;;
                                   (0008) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                   (0009) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0010) ;;        This means it is the caller's responsibility to preserve any values
                                   (0011) ;;        in the X and A registers that are still needed after the API
                                   (0012) ;;        function returns. Even though these registers may be preserved now,
                                   (0013) ;;        there is no guarantee they will be preserved in future releases.
                                   (0014) ;;-----------------------------------------------------------------------------
                                   (0015) ;;  Copyright (c) Cypress Semiconductor, 2006. All Rights Reserved.
                                   (0016) ;;*****************************************************************************
                                   (0017) ;;*****************************************************************************
                                   (0018) include "m8c.inc"	   
                                   (0019) include "memory.inc"
                                   (0020) include "USBUART_macros.inc"
                                   (0021) include "USBUART.inc"
                                   (0022) 
                                   (0023) ;-----------------------------------------------
                                   (0024) ;  Global Symbols
                                   (0025) ;-----------------------------------------------
                                   (0026) EXPORT USBUART_Start
                                   (0027) EXPORT _USBUART_Start
                                   (0028) EXPORT USBUART_Stop
                                   (0029) EXPORT _USBUART_Stop
                                   (0030) EXPORT USBUART_Init
                                   (0031) EXPORT _USBUART_Init
                                   (0032) 
                                   (0033) EXPORT USBUART_Write
                                   (0034) EXPORT _USBUART_Write
                                   (0035) EXPORT _USBUART_CWrite
                                   (0036) EXPORT USBUART_CWrite
                                   (0037) EXPORT USBUART_PutString
                                   (0038) EXPORT _USBUART_PutString
                                   (0039) EXPORT USBUART_CPutString
                                   (0040) EXPORT _USBUART_CPutString
                                   (0041) EXPORT USBUART_PutChar
                                   (0042) EXPORT _USBUART_PutChar
                                   (0043) EXPORT USBUART_PutCRLF
                                   (0044) EXPORT _USBUART_PutCRLF
                                   (0045) EXPORT USBUART_PutSHexByte
                                   (0046) EXPORT _USBUART_PutSHexByte
                                   (0047) EXPORT USBUART_PutSHexInt
                                   (0048) EXPORT _USBUART_PutSHexInt
                                   (0049) 
                                   (0050) EXPORT USBUART_bGetRxCount
                                   (0051) EXPORT _USBUART_bGetRxCount
                                   (0052) EXPORT USBUART_bTxIsReady
                                   (0053) EXPORT _USBUART_bTxIsReady
                                   (0054) 
                                   (0055) EXPORT USBUART_Read
                                   (0056) EXPORT _USBUART_Read
                                   (0057) EXPORT USBUART_ReadAll
                                   (0058) EXPORT _USBUART_ReadAll
                                   (0059) EXPORT USBUART_ReadChar
                                   (0060) EXPORT _USBUART_ReadChar
                                   (0061) 
                                   (0062) EXPORT USBUART_dwGetDTERate
                                   (0063) EXPORT _USBUART_dwGetDTERate
                                   (0064) EXPORT USBUART_bGetCharFormat
                                   (0065) EXPORT _USBUART_bGetCharFormat
                                   (0066) EXPORT USBUART_bGetParityType
                                   (0067) EXPORT _USBUART_bGetParityType
                                   (0068) EXPORT USBUART_bGetDataBits
                                   (0069) EXPORT _USBUART_bGetDataBits
                                   (0070) EXPORT USBUART_bGetDataBits
                                   (0071) EXPORT _USBUART_bGetDataBits
                                   (0072) EXPORT USBUART_bGetLineControlBitmap
                                   (0073) EXPORT _USBUART_bGetLineControlBitmap
                                   (0074) EXPORT USBUART_SendStateNotify
                                   (0075) EXPORT _USBUART_SendStateNotify
                                   (0076) 
                                   (0077) EXPORT USBUART_bCheckUSBActivity
                                   (0078) EXPORT _USBUART_bCheckUSBActivity
                                   (0079) 
                                   (0080) 
                                   (0081) AREA InterruptRAM (RAM,REL,CON)
                                   (0082) ;-----------------------------------------------
                                   (0083) ;  Variable Allocation
                                   (0084) ;-----------------------------------------------
                                   (0085) EXPORT USBUART_APITemp
                                   (0086)  USBUART_APITemp:                       BLK   2 ; Two bytes of temporary  storage shared by the API  functions
                                   (0087) 
                                   (0088) 
                                   (0089) AREA UserModules (ROM, REL)
                                   (0090) 
                                   (0091) .SECTION
                                   (0092) ;-----------------------------------------------------------------------------
                                   (0093) ;  FUNCTION NAME: USBUART_Start
                                   (0094) ;
                                   (0095) ;  DESCRIPTION:    Starts the USB User Module
                                   (0096) ;                    Sets the device selection
                                   (0097) ;                    Set the configuration to unconfigured
                                   (0098) ;                    Enables the SIE for Address 0
                                   (0099) ;                    Enables the USB pullup ( D+ for full speed)
                                   (0100) ;
                                   (0101) ;-----------------------------------------------------------------------------
                                   (0102) ;
                                   (0103) ;  ARGUMENTS:    A  is the operation voltage
                                   (0104) ;
                                   (0105) ;  RETURNS:		 Nothing
                                   (0106) ;
                                   (0107) ;  SIDE EFFECTS: 
                                   (0108) ;    The A and X registers may be modified by this or future implementations
                                   (0109) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0110) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0111) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0112) ;    functions.
                                   (0113) ;
                                   (0114)  USBUART_Start:
                                   (0115) _USBUART_Start:
                                   (0116)     RAM_PROLOGUE RAM_USE_CLASS_4
0AF4: 70 BF    AND   F,191         (0117)     RAM_PROLOGUE RAM_USE_CLASS_3
0AF6: 62 D0 00 MOV   REG[208],0    (0118) 	RAM_SETPAGE_CUR >USBUART_bCurrentDevice ; Set the CUR_PP to the right page
0AF9: 62 D3 00 MOV   REG[211],0    (0119)     RAM_SETPAGE_IDX >USBUART_bCurrentDevice ; Set the IDX_PP to the right page
0AFC: 55 00 00 MOV   [0],0         (0120)     mov     [USBUART_bCurrentDevice], 0; The app selects the desired device
                                   (0121) 
0AFF: 55 0B 00 MOV   [11],0        (0122)     mov     [USBUART_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0B02: 55 01 00 MOV   [1],0         (0123)     mov     [USBUART_Configuration], 0 ; Unconfigured
0B05: 55 02 00 MOV   [2],0         (0124)     mov     [USBUART_DeviceStatus], 0  ; Clears device status
                                   (0125) 
0B08: 62 6C 00 MOV   REG[108],0    (0126)     mov     reg[TMP_DR0], 0	           ; EP1 start address in PMA space
0B0B: 62 6D 40 MOV   REG[109],64   (0127) 	mov     reg[TMP_DR1], 64              ; EP2 start address in PMA space
0B0E: 62 6E 80 MOV   REG[110],128  (0128) 	mov     reg[TMP_DR2], 128             ; EP3 start address in PMA space
0B11: 62 6F C0 MOV   REG[111],192  (0129) 	mov     reg[TMP_DR3], 192             ; EP4 start address in PMA space
                                   (0130) 
0B14: 57 04    MOV   X,4           (0131)     mov     X, USB_MAX_EP_NUMBER       ; Set up loop to clear all of the endpoint data items
                                   (0132) ; Flow or jump here to clear the data for the next endpoint
                                   (0133) .loop:
0B16: 56 1D 00 MOV   [X+29],0      (0134)     mov     [X + USBUART_EPDataToggle], 0  ; Or in the toggle
0B19: 79       DEC   X             (0135)     dec     X                          ; Are we done?
0B1A: BF FB    JNZ   0x0B16        (0136)     jnz     .loop                      ; Jump to do another endpoint    
                                   (0137) ; Flow here to enable the SIE
                                   (0138) 
0B1C: 62 4A 80 MOV   REG[74],128   (0139)     mov     reg[USBUART_ADDR], USB_ADDR_ENABLE ; Enable Address 0
0B1F: 62 4B 00 MOV   REG[75],0     (0140) 	mov     reg[USBUART_USBIO_CR0], USB_AUTO_DPDM
                                   (0141) 
0B22: 71 10    OR    F,16          (0142)     M8C_SetBank1
0B24: 60 C1    MOV   REG[193],A    (0143) 	mov     reg[USBUART_USB_CR1], A
0B26: 70 EF    AND   F,239         (0144) 	M8C_SetBank0
0B28: 62 56 03 MOV   REG[86],3     (0145)     mov     reg[USBUART_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
0B2B: 43 DF 05 OR    REG[223],5    (0146)     M8C_EnableIntMask USBUART_INT_REG, (USBUART_INT_RESET_MASK | USBUART_INT_EP0_MASK)
                                   (0147) 
                                   (0148) ;   Enable the pullup so we can start to rock and roll
0B2E: 62 4C 04 MOV   REG[76],4     (0149)     mov     reg[USBUART_USBIO_CR1], USB_PULLUP_ENABLE ; Pullup D+
0B31: 70 3F    AND   F,63
                                   (0150) 
0B33: 71 C0    OR    F,192         (0151)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0152) 	RAM_EPILOGUE RAM_USE_CLASS_4
0B35: 7F       RET                 (0153)     RET
                                   (0154) .ENDSECTION
                                   (0155) 
                                   (0156) .SECTION
                                   (0157) ;-----------------------------------------------------------------------------
                                   (0158) ;  FUNCTION NAME: USBUART_Stop
                                   (0159) ;
                                   (0160) ;  DESCRIPTION: Performs all necessary shutdown tasks required for the USBUART
                                   (0161) ;               User Module.
                                   (0162) ;
                                   (0163) ;-----------------------------------------------------------------------------
                                   (0164) ;
                                   (0165) ;  ARGUMENTS: None
                                   (0166) ;
                                   (0167) ;  RETURNS:   Nothing
                                   (0168) ;
                                   (0169) ;  SIDE EFFECTS: 
                                   (0170) ;    The A and X registers may be modified by this or future implementations
                                   (0171) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0172) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0173) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0174) ;    functions.
                                   (0175) ;
                                   (0176)  USBUART_Stop:
                                   (0177) _USBUART_Stop:
                                   (0178)     RAM_PROLOGUE RAM_USE_CLASS_4
0B36: 62 D0 00 MOV   REG[208],0    (0179) 	RAM_SETPAGE_CUR >USBUART_bCurrentDevice ; Set the CUR_PP to the right page
                                   (0180) 
0B39: 55 00 00 MOV   [0],0         (0181)     mov     [USBUART_bCurrentDevice], 0; The app selects the desired device
                                   (0182) 
0B3C: 55 0B 00 MOV   [11],0        (0183)     mov     [USBUART_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
0B3F: 55 01 00 MOV   [1],0         (0184)     mov     [USBUART_Configuration], 0 ; Unconfigured
0B42: 55 02 00 MOV   [2],0         (0185)     mov     [USBUART_DeviceStatus], 0  ; Clears device status
0B45: 62 4A 00 MOV   REG[74],0     (0186)     mov     reg[USBUART_ADDR], 0       ; Clear the address and Address 0
0B48: 41 4C FB AND   REG[76],251   (0187) 	and     reg[USBUART_USBIO_CR1], ~USB_PULLUP_ENABLE ; Release D+
0B4B: 62 DF 00 MOV   REG[223],0    (0188)     mov     reg[USBUART_INT_REG], 0x00 ; Enable the interrupt
                                   (0189) 
                                   (0190) 	RAM_EPILOGUE RAM_USE_CLASS_4
0B4E: 7F       RET                 (0191)     RET
                                   (0192) .ENDSECTION
                                   (0193) 
                                   (0194) .SECTION
                                   (0195) ;-----------------------------------------------------------------------------
                                   (0196) ;  FUNCTION NAME: USBUART_bCheckUSBActivity
                                   (0197) ;
                                   (0198) ;  DESCRIPTION: Checks for USB Bus Activity.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: Nothing
                                   (0203) ;
                                   (0204) ;  RETURNS:   A is a flag that indicates bus activity 
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
                                   (0207) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0208) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0209) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0210) ;    functions.
                                   (0211) ;
                                   (0212)  USBUART_bCheckUSBActivity:
                                   (0213) _USBUART_bCheckUSBActivity:
                                   (0214)     RAM_PROLOGUE RAM_USE_CLASS_1
0B4F: 71 10    OR    F,16          (0215)     M8C_SetBank1    
0B51: 5D C1    MOV   A,REG[193]    (0216)     mov    A, reg[USBUART_USB_CR1]     ; USB Activity bit indicates activity
0B53: 21 04    AND   A,4           (0217)     and    A, USB_BUS_ACTIVITY         ; Activity?
0B55: A0 05    JZ    0x0B5B        (0218)     jz     .no_activity                ; Jump on no activity?
                                   (0219) ; Flow here on bus activity
0B57: 50 01    MOV   A,1           (0220)     mov    A, 1                        ; Return true
0B59: 80 03    JMP   0x0B5D        (0221)     jmp    .done
                                   (0222) ; Jump here on no activity
                                   (0223) .no_activity:
0B5B: 50 00    MOV   A,0           (0224)     mov    A, 0                        ; Return false
                                   (0225) ; Jump or flow here to clear the activity bit, then return
                                   (0226) .done:
0B5D: 41 C1 FB AND   REG[193],251  (0227)     and    reg[USBUART_USB_CR1], ~USB_BUS_ACTIVITY  ; Clear the activity flag
0B60: 70 EF    AND   F,239         (0228)     M8C_SetBank0
                                   (0229) 	RAM_EPILOGUE RAM_USE_CLASS_1
0B62: 7F       RET                 (0230)     ret
                                   (0231) .ENDSECTION
                                   (0232) 
                                   (0233) .SECTION
                                   (0234) ;-----------------------------------------------------------------------------
                                   (0235) ;  FUNCTION NAME: USBUART_bGetRxCount
                                   (0236) ;
                                   (0237) ;  DESCRIPTION: This function returns the number of bytes that were received 
                                   (0238) ;               from the PC and are waiting in the RX buffer.
                                   (0239) ;
                                   (0240) ;-----------------------------------------------------------------------------
                                   (0241) ;
                                   (0242) ;  ARGUMENTS:   
                                   (0243) ;	none
                                   (0244) ;
                                   (0245) ;  RETURNS:
                                   (0246) ;	If RX associated endpoint has EVENT_PENDING status return ()in A register) the values stored in the
                                   (0247) ;  	Count registers of the Endpoint; otherwise return zero.
                                   (0248) ;
                                   (0249) ;  SIDE EFFECTS: 
                                   (0250) ;    The A and X registers may be modified by this or future implementations
                                   (0251) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0252) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0253) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0254) ;    functions.
                                   (0255) ;
                                   (0256)  USBUART_bGetRxCount:
                                   (0257) _USBUART_bGetRxCount:
0B63: 70 BF    AND   F,191         (0258)     RAM_PROLOGUE RAM_USE_CLASS_3
0B65: 62 D3 00 MOV   REG[211],0    (0259) 	RAM_SETPAGE_IDX >USBUART_EndpointAPIStatus ; Set the IDX_PP to the right page
0B68: 51 29    MOV   A,[41]        (0260) 	mov     A, [USBUART_EndpointAPIStatus+3]	; Get the state
0B6A: 39 01    CMP   A,1           (0261) 	cmp 	A, EVENT_PENDING 
0B6C: A0 05    JZ    0x0B72        (0262) 	jz		.ev_pending
0B6E: 50 00    MOV   A,0           (0263) 	mov		A, 0
0B70: 80 05    JMP   0x0B76        (0264) 	jmp		.exit
                                   (0265) .ev_pending:	
0B72: 5D 53    MOV   A,REG[83]     (0266)     mov     A, reg[USBUART_EP3CNT0]    ; Here is the count
0B74: 11 02    SUB   A,2           (0267) 	sub		A, 2
0B76: 70 3F    AND   F,63
                                   (0268) ; Jump or flow here for a common exit
                                   (0269) .exit:
0B78: 71 C0    OR    F,192         (0270)     RAM_EPILOGUE RAM_USE_CLASS_3
0B7A: 7F       RET                 (0271)     ret
                                   (0272) .ENDSECTION
                                   (0273) 
                                   (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: USBUART_Write,  USBUART_CWrite
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:    Send specified numbers of data
                                   (0279) ;
                                   (0280) ;-----------------------------------------------------------------------------
                                   (0281) ;
                                   (0282) ;  ARGUMENTS:
                                   (0283) ;     [SP-6] MSB of Count to send
                                   (0284) ;     [SP-5] LSB of Count to send
                                   (0285) ;     [SP-4] MSB of data array address
                                   (0286) ;     [SP-3] LSB of data array address
                                   (0287) ;
                                   (0288) ;  RETURNS:
                                   (0289) ;     none
                                   (0290) ;
                                   (0291) ;  SIDE EFFECTS:
                                   (0292) ;    The A and X registers may be modified by this or future implementations
                                   (0293) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0294) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0295) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0296) ;    functions.
                                   (0297) ;          
                                   (0298) ;    Currently only the page pointer registers listed below are modified: 
                                   (0299) ;          CUR_PP
                                   (0300) ;          IDX_PP
                                   (0301) ;
                                   (0302) MEM_TYPE:	equ -1
                                   (0303) ; -2 and -3 is the return address to caller
                                   (0304) DATA_LSB:   equ -4           ; LSB pointer of data
                                   (0305) DATA_MSB:   equ -5           ; MSB pointer of data
                                   (0306) CNTLEN: equ -6			 ; Length of data to send
                                   (0307) 
                                   (0308)  USBUART_CWrite:
                                   (0309) _USBUART_CWrite:
0B7B: 50 01    MOV   A,1           (0310) 	mov		A, 1 ;Set MEM_TYPE
0B7D: 08       PUSH  A             (0311) 	push	A 
0B7E: 80 04    JMP   0x0B83        (0312) 	jmp		USBUART_Write_Start
                                   (0313)  USBUART_Write:
                                   (0314) _USBUART_Write:
0B80: 50 00    MOV   A,0           (0315) 	mov		A, 0 ;Set MEM_TYPE
0B82: 08       PUSH  A             (0316) 	push	A 
                                   (0317) USBUART_Write_Start:
                                   (0318)     RAM_PROLOGUE RAM_USE_CLASS_4
0B83: 70 BF    AND   F,191         (0319)     RAM_PROLOGUE RAM_USE_CLASS_3
0B85: 62 D0 00 MOV   REG[208],0    (0320) 	RAM_SETPAGE_CUR >USBUART_bCurrentDevice ; Set the CUR_PP to the right page
0B88: 62 D3 03 MOV   REG[211],3    (0321)     RAM_SETPAGE_IDX2STK    
                                   (0322)     ;Should we toggle the data bit??
                                   (0323)     ;SET THE COUNT AND TOGGLE
0B8B: 4F       MOV   X,SP          (0324) 	mov     X, SP
0B8C: 52 FA    MOV   A,[X-6]       (0325) 	mov     A, [X+CNTLEN]                 ; Get the LSB of the Count	
0B8E: 53 3C    MOV   [60],A        (0326) 	mov     [USBUART_APITemp], A          ; Save the count
                                   (0327) 	
0B90: 36 1F 80 XOR   [31],128      (0328) 	xor     [USBUART_EPDataToggle+2], USB_CNT_TOGGLE
                                   (0329) 
0B93: 52 FA    MOV   A,[X-6]       (0330) 	mov     A, [X+CNTLEN]                  ;Get The LSB of the count
0B95: 60 51    MOV   REG[81],A     (0331)     mov     reg[USBUART_EP2CNT0], A     ; Write it into the register
0B97: 51 1F    MOV   A,[31]        (0332) 	mov     A, [USBUART_EPDataToggle+2]    ; Retrieve the saved toggle (MSB)
0B99: 60 50    MOV   REG[80],A     (0333) 	mov     reg[USBUART_EP2CNT1], A        ; Write it into the register
                                   (0334)     
                                   (0335) ; It's Time to move the data
                                   (0336) ; First we need to determine where, within the PMA, the EP Start Address is
0B9B: 5D 6D    MOV   A,REG[109]    (0337) 	mov     A, reg[TMP_DR1]                ; Get the address of ep from tmp register 
0B9D: 71 10    OR    F,16          (0338) 	M8C_SetBank1
0B9F: 60 40    MOV   REG[64],A     (0339) 	mov     reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space 
0BA1: 70 EF    AND   F,239         (0340) 	M8C_SetBank0	
                                   (0341) 
                                   (0342) ; Now we are y to start moving data
0BA3: 52 FA    MOV   A,[X-6]       (0343) 	mov     A, [X+CNTLEN]                  ; Check the count     
0BA5: A0 2C    JZ    0x0BD2        (0344) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                   (0345) 
0BA7: 2F FF 00 OR    [X-1],0       (0346) 	or	 	[X+MEM_TYPE], 0
0BAA: B0 14    JNZ   0x0BBF        (0347) 	jnz		.start_send_rom
                                   (0348) 
0BAC: 52 FC    MOV   A,[X-4]       (0349) 	mov     A, [X+DATA_LSB]
0BAE: 08       PUSH  A             (0350) 	push    A
                                   (0351) IF SYSTEM_LARGE_MEMORY_MODEL
0BAF: 52 FB    MOV   A,[X-5]       (0352) 	mov     A, [X+DATA_MSB]
0BB1: 60 D3    MOV   REG[211],A    (0353) 	mov     reg[IDX_PP], A
                                   (0354) ENDIF
0BB3: 20       POP   X             (0355) 	pop     X
                                   (0356) 	
                                   (0357) .loop_ram: 
0BB4: 52 00    MOV   A,[X+0]       (0358) 	mov		A, [X]
0BB6: 60 40    MOV   REG[64],A     (0359) 	mov     reg[PMA0_DR], A
0BB8: 75       INC   X             (0360) 	inc     X
0BB9: 7A 3C    DEC   [60]          (0361) 	dec     [USBUART_APITemp]
0BBB: BF F8    JNZ   0x0BB4        (0362) 	jnz     .loop_ram
0BBD: 80 14    JMP   0x0BD2        (0363) 	jmp 	.done
                                   (0364) 
                                   (0365) .start_send_rom:
0BBF: 52 FB    MOV   A,[X-5]       (0366) 	mov     A, [X+DATA_MSB]
0BC1: 53 3D    MOV   [61],A        (0367) 	mov		[USBUART_APITemp+1], A
0BC3: 59 FC    MOV   X,[X-4]       (0368) 	mov     X, [X+DATA_LSB]
                                   (0369) 
                                   (0370) .loop_rom: 
0BC5: 28       ROMX                (0371) 	romx
0BC6: 60 40    MOV   REG[64],A     (0372) 	mov     reg[PMA0_DR], A
                                   (0373) 
0BC8: 75       INC   X             (0374) 	inc     X	;go next address
0BC9: 0E 3D 00 ADC   [61],0        (0375) 	adc		[USBUART_APITemp+1], 0 ; don't forget carry
0BCC: 51 3D    MOV   A,[61]        (0376) 	mov 	A, [USBUART_APITemp+1] ; prepare MSB of address
                                   (0377) 	
0BCE: 7A 3C    DEC   [60]          (0378) 	dec     [USBUART_APITemp]
0BD0: BF F4    JNZ   0x0BC5        (0379) 	jnz     .loop_rom
                                   (0380) 	
                                   (0381) .done:
0BD2: 55 28 00 MOV   [40],0        (0382)     mov     [USBUART_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0BD5: 71 10    OR    F,16          (0383) 	M8C_SetBank1	
0BD7: 5D 6D    MOV   A,REG[109]    (0384) 	mov     A, reg[TMP_DR1]               ; Get the value of the PMA start Address								
0BD9: 60 52    MOV   REG[82],A     (0385) 	mov     reg[PMA0_RA+2], A             ; Load it into EP PMA so pre-fetch occurs                                          
0BDB: 62 C5 0D MOV   REG[197],13   (0386)     mov     reg[USBUART_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0BDE: 70 EF    AND   F,239         (0387) 	M8C_SetBank0	
                                   (0388) 
0BE0: 18       POP   A             (0389) 	pop 	A ; Clean up MEM_TYPE
0BE1: 70 3F    AND   F,63
0BE3: 71 C0    OR    F,192         (0390)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0391) 	RAM_EPILOGUE RAM_USE_CLASS_4
0BE5: 7F       RET                 (0392)     ret
                                   (0393) .ENDSECTION
                                   (0394) 
                                   (0395) .SECTION
                                   (0396) ;-----------------------------------------------------------------------------
                                   (0397) ;  FUNCTION NAME: USBUART_PutString
                                   (0398) ;
                                   (0399) ;  DESCRIPTION:    Send NULL terminated string
                                   (0400) ;
                                   (0401) ;-----------------------------------------------------------------------------
                                   (0402) ;
                                   (0403) ;  ARGUMENTS:
                                   (0404) ;     A contains MSB of the string pointer
                                   (0405) ;     X contains LSB of the string pointer
                                   (0406) ;
                                   (0407) ;  RETURNS:
                                   (0408) ;     none
                                   (0409) ;
                                   (0410) ;  SIDE EFFECTS:
                                   (0411) ;    The A and X registers may be modified by this or future implementations
                                   (0412) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0413) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0414) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0415) ;    functions.
                                   (0416) ;          
                                   (0417) ;    Currently only the page pointer registers listed below are modified: 
                                   (0418) ;          CUR_PP
                                   (0419) ;          IDX_PP
                                   (0420) ;
                                   (0421) 
                                   (0422)  USBUART_PutString:
                                   (0423) _USBUART_PutString:
                                   (0424)     RAM_PROLOGUE RAM_USE_CLASS_4
0BE6: 70 BF    AND   F,191         (0425)     RAM_PROLOGUE RAM_USE_CLASS_3
0BE8: 62 D0 00 MOV   REG[208],0    (0426) 	RAM_SETPAGE_CUR >USBUART_APITemp      ; Set the CUR_PP to the right page
0BEB: 08       PUSH  A             (0427) 	push	A
0BEC: 08       PUSH  A             (0428) 	push	A	;put MSB of dataPtr  - prepare to Write call
0BED: 10       PUSH  X             (0429) 	push	X	;put LSB of dataPtr - prepare to Write call
                                   (0430) IF SYSTEM_LARGE_MEMORY_MODEL
0BEE: 60 D3    MOV   REG[211],A    (0431) 	mov     reg[IDX_PP], A
                                   (0432) ENDIF
0BF0: 55 3C 00 MOV   [60],0        (0433) 	mov		[USBUART_APITemp], 0; init the length counter 
                                   (0434) .loop:
0BF3: 52 00    MOV   A,[X+0]       (0435) 	mov		A, [X]
0BF5: A0 06    JZ    0x0BFC        (0436) 	jz		.done
0BF7: 75       INC   X             (0437) 	inc		X
0BF8: 76 3C    INC   [60]          (0438) 	inc		[USBUART_APITemp]
0BFA: 8F F8    JMP   0x0BF3        (0439) 	jmp		.loop
                                   (0440) .done:
0BFC: 62 D3 03 MOV   REG[211],3    (0441)     RAM_SETPAGE_IDX2STK
0BFF: 51 3C    MOV   A,[60]        (0442) 	mov		A, [USBUART_APITemp]
0C01: 4F       MOV   X,SP          (0443) 	mov		X, SP
0C02: 54 FD    MOV   [X-3],A       (0444) 	mov 	[X-3], A
0C04: 7C 0B 80 LCALL 0x0B80        (0445) 	lcall 	USBUART_Write
0C07: 38 FD    ADD   SP,253        (0446) 	add		SP, 253
0C09: 70 3F    AND   F,63
0C0B: 71 C0    OR    F,192         (0447)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0448) 	RAM_EPILOGUE RAM_USE_CLASS_4
0C0D: 7F       RET                 (0449)     ret
                                   (0450) .ENDSECTION
                                   (0451) 
                                   (0452) .SECTION
                                   (0453) ;-----------------------------------------------------------------------------
                                   (0454) ;  FUNCTION NAME: USBUART_CPutString
                                   (0455) ;
                                   (0456) ;  DESCRIPTION:    Send NULL terminated string ROM located string
                                   (0457) ;
                                   (0458) ;-----------------------------------------------------------------------------
                                   (0459) ;
                                   (0460) ;  ARGUMENTS:
                                   (0461) ;     A contains MSB of the string pointer
                                   (0462) ;     X contains LSB of the string pointer
                                   (0463) ;
                                   (0464) ;  RETURNS:
                                   (0465) ;     none
                                   (0466) ;
                                   (0467) ;  SIDE EFFECTS:
                                   (0468) ;    The A and X registers may be modified by this or future implementations
                                   (0469) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0470) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0471) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0472) ;    functions.
                                   (0473) ;          
                                   (0474) ;    Currently only the page pointer registers listed below are modified: 
                                   (0475) ;          CUR_PP
                                   (0476) ;          IDX_PP
                                   (0477) ;
                                   (0478) 
                                   (0479)  USBUART_CPutString:
                                   (0480) _USBUART_CPutString:
                                   (0481)     RAM_PROLOGUE RAM_USE_CLASS_4
0C0E: 70 BF    AND   F,191         (0482)     RAM_PROLOGUE RAM_USE_CLASS_3
0C10: 62 D0 00 MOV   REG[208],0    (0483) 	RAM_SETPAGE_CUR >USBUART_APITemp      ; Set the CUR_PP to the right page
0C13: 62 D3 03 MOV   REG[211],3    (0484) 	RAM_SETPAGE_IDX2STK 
0C16: 08       PUSH  A             (0485) 	push	A	;reserve placeholder for count - prepare to Write call
0C17: 08       PUSH  A             (0486) 	push	A	;put MSB of dataPtr  - prepare to Write call
0C18: 10       PUSH  X             (0487) 	push	X	;put LSB of dataPtr - prepare to Write call
0C19: 55 3C 00 MOV   [60],0        (0488) 	mov		[USBUART_APITemp], 0	; init the length counter 
0C1C: 53 3D    MOV   [61],A        (0489) 	mov		[USBUART_APITemp+1], A	; store the pointer MSB
                                   (0490) .loop:
0C1E: 28       ROMX                (0491) 	romx 
0C1F: A0 0B    JZ    0x0C2B        (0492) 	jz		.done
0C21: 75       INC   X             (0493) 	inc		X	;increment pointer LSB
0C22: 0E 3D 00 ADC   [61],0        (0494) 	adc 	[USBUART_APITemp+1],0 ;don't forget carry
0C25: 76 3C    INC   [60]          (0495) 	inc		[USBUART_APITemp]	;increment counter
0C27: 51 3D    MOV   A,[61]        (0496) 	mov 	A, [USBUART_APITemp+1]	;load MSB into A - prepare address for romx
0C29: 8F F4    JMP   0x0C1E        (0497) 	jmp		.loop
                                   (0498) .done:
0C2B: 51 3C    MOV   A,[60]        (0499) 	mov		A, [USBUART_APITemp]
0C2D: 4F       MOV   X,SP          (0500) 	mov		X, SP
0C2E: 54 FD    MOV   [X-3],A       (0501) 	mov 	[X-3], A
0C30: 7C 0B 7B LCALL 0x0B7B        (0502) 	lcall 	USBUART_CWrite
0C33: 38 FD    ADD   SP,253        (0503) 	add		SP, 253
0C35: 70 3F    AND   F,63
0C37: 71 C0    OR    F,192         (0504)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0505) 	RAM_EPILOGUE RAM_USE_CLASS_4
0C39: 7F       RET                 (0506)     ret
                                   (0507) .ENDSECTION
                                   (0508) 
                                   (0509) .SECTION
                                   (0510) ;-----------------------------------------------------------------------------
                                   (0511) ;  FUNCTION NAME: USBUART_PutChar
                                   (0512) ;
                                   (0513) ;  DESCRIPTION:    Send one character
                                   (0514) ;
                                   (0515) ;-----------------------------------------------------------------------------
                                   (0516) ;
                                   (0517) ;  ARGUMENTS:
                                   (0518) ;     A contains character to send
                                   (0519) ;
                                   (0520) ;  RETURNS:
                                   (0521) ;     none
                                   (0522) ;
                                   (0523) ;  SIDE EFFECTS:
                                   (0524) ;    The A and X registers may be modified by this or future implementations
                                   (0525) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0526) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0527) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0528) ;    functions.
                                   (0529) ;          
                                   (0530) 
                                   (0531)  USBUART_PutChar:
                                   (0532) _USBUART_PutChar:
                                   (0533)     RAM_PROLOGUE RAM_USE_CLASS_1
0C3A: 08       PUSH  A             (0534) 	push 	A	;save character in stack
0C3B: 50 01    MOV   A,1           (0535) 	mov 	A, 1;	set 1 byte to transfer
0C3D: 08       PUSH  A             (0536) 	push	A
                                   (0537) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0C3E: 5D D1    MOV   A,REG[209]    (0538)     mov   	A, reg[STK_PP]
                                   (0539) ELSE	
                                   (0540) 	mov 	A, 0
                                   (0541) ENDIF	
0C40: 08       PUSH  A             (0542) 	push	A	;put MSB of dataPtr  - prepare to Write call
0C41: 4F       MOV   X,SP          (0543) 	mov 	X, SP
0C42: 5B       MOV   A,X           (0544) 	mov		A, X
0C43: 11 03    SUB   A,3           (0545) 	sub 	A, 3
0C45: 08       PUSH  A             (0546) 	push	A	;put LSB of dataPtr - prepare to Write call
0C46: 7C 0B 80 LCALL 0x0B80        (0547) 	lcall 	USBUART_Write
0C49: 38 FC    ADD   SP,252        (0548) 	add		SP, 252
                                   (0549) 	RAM_EPILOGUE RAM_USE_CLASS_1
0C4B: 7F       RET                 (0550)     ret
                                   (0551) .ENDSECTION
                                   (0552) 
                                   (0553) .SECTION
                                   (0554) ;-----------------------------------------------------------------------------
                                   (0555) ;  FUNCTION NAME: USBUART_PutCRLF
                                   (0556) ;
                                   (0557) ;  DESCRIPTION:    Send one character
                                   (0558) ;
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) ;
                                   (0561) ;  ARGUMENTS:
                                   (0562) ;     none
                                   (0563) ;
                                   (0564) ;  RETURNS:
                                   (0565) ;     none
                                   (0566) ;
                                   (0567) ;  SIDE EFFECTS:
                                   (0568) ;    The A and X registers may be modified by this or future implementations
                                   (0569) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0570) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0571) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0572) ;    functions.
                                   (0573) ;          
                                   (0574) 
                                   (0575)  USBUART_PutCRLF:
                                   (0576) _USBUART_PutCRLF:
                                   (0577)     RAM_PROLOGUE RAM_USE_CLASS_1
0C4C: 50 0D    MOV   A,13          (0578) 	mov 	A, 0Dh	
0C4E: 08       PUSH  A             (0579) 	push 	A	;save character in stack
0C4F: 50 0A    MOV   A,10          (0580) 	mov 	A, 0Ah	
0C51: 08       PUSH  A             (0581) 	push 	A	;save character in stack
0C52: 50 02    MOV   A,2           (0582) 	mov 	A, 2;	set 2 byte to transfer
0C54: 08       PUSH  A             (0583) 	push	A
                                   (0584) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0C55: 5D D1    MOV   A,REG[209]    (0585)     mov   	A, reg[STK_PP]
                                   (0586) ELSE	
                                   (0587) 	mov 	A, 0
                                   (0588) ENDIF	
0C57: 08       PUSH  A             (0589) 	push	A	;put MSB of dataPtr  - prepare to Write call
0C58: 4F       MOV   X,SP          (0590) 	mov 	X, SP
0C59: 5B       MOV   A,X           (0591) 	mov		A, X
0C5A: 11 04    SUB   A,4           (0592) 	sub 	A, 4
0C5C: 08       PUSH  A             (0593) 	push	A	;put LSB of dataPtr - prepare to Write call
0C5D: 7C 0B 80 LCALL 0x0B80        (0594) 	lcall 	USBUART_Write
0C60: 38 FB    ADD   SP,251        (0595) 	add		SP, 251
                                   (0596) 	RAM_EPILOGUE RAM_USE_CLASS_1
0C62: 7F       RET                 (0597)     ret
0C63: 30       HALT  
0C64: 31 32    XOR   A,50
0C66: 33 34    XOR   A,[X+52]
0C68: 35 36    XOR   [X+54],A
0C6A: 37 38 39 XOR   [X+56],57
0C6D: 41 42 43 AND   REG[66],67
0C70: 44 45 46 OR    REG[X+69],70
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .LITERAL
                                   (0601) USBUART_HEX_STR:
                                   (0602)      DS    "0123456789ABCDEF"
                                   (0603) .ENDLITERAL
                                   (0604) 
                                   (0605) .SECTION
                                   (0606) ;-----------------------------------------------------------------------------
                                   (0607) ;  FUNCTION NAME: USBUART_PutSHexByte
                                   (0608) ;
                                   (0609) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                   (0610) ;
                                   (0611) ;-----------------------------------------------------------------------------
                                   (0612) ;
                                   (0613) ;  ARGUMENTS:
                                   (0614) ;     A contains byte to send
                                   (0615) ;
                                   (0616) ;  RETURNS:
                                   (0617) ;     none
                                   (0618) ;
                                   (0619) ;  SIDE EFFECTS:
                                   (0620) ;    The A and X registers may be modified by this or future implementations
                                   (0621) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0622) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0623) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0624) ;    functions.
                                   (0625) ;          
                                   (0626)  USBUART_PutSHexByte:
                                   (0627) _USBUART_PutSHexByte:
                                   (0628)     RAM_PROLOGUE RAM_USE_CLASS_1
0C73: 5C       MOV   X,A           (0629) 	mov 	X, A	; Save lower nibble
0C74: 67       ASR   A             (0630) 	asr		A   ; Shift high nibble to right
0C75: 67       ASR   A             (0631) 	asr		A
0C76: 67       ASR   A             (0632) 	asr		A
0C77: 67       ASR   A             (0633) 	asr		A
0C78: 21 0F    AND   A,15          (0634) 	and		A,0Fh	; Mask off nibble
0C7A: FF E7    INDEX 0x0C63        (0635) 	index USBUART_HEX_STR;  Get Hex value
0C7C: 08       PUSH  A             (0636) 	push 	A
0C7D: 5B       MOV   A,X           (0637) 	mov		A, X	
0C7E: 21 0F    AND   A,15          (0638) 	and   	A,0Fh	; Mask off lower nibble
0C80: FF E1    INDEX 0x0C63        (0639) 	index USBUART_HEX_STR	; Get Hex value
0C82: 08       PUSH  A             (0640) 	push	A
0C83: 50 02    MOV   A,2           (0641) 	mov		A, 2	; 2 bytes to transfer
0C85: 08       PUSH  A             (0642) 	push	A
                                   (0643) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0C86: 5D D1    MOV   A,REG[209]    (0644)     mov   	A, reg[STK_PP]
                                   (0645) ELSE	
                                   (0646) 	mov 	A, 0
                                   (0647) ENDIF	
0C88: 08       PUSH  A             (0648) 	push	A	;put MSB of dataPtr  - prepare to Write call
0C89: 4F       MOV   X,SP          (0649) 	mov 	X, SP
0C8A: 5B       MOV   A,X           (0650) 	mov		A, X
0C8B: 11 04    SUB   A,4           (0651) 	sub 	A, 4
0C8D: 08       PUSH  A             (0652) 	push	A	;put LSB of dataPtr - prepare to Write call
0C8E: 7C 0B 80 LCALL 0x0B80        (0653) 	lcall 	USBUART_Write
0C91: 38 FB    ADD   SP,251        (0654) 	add		SP, 251
                                   (0655) 	RAM_EPILOGUE RAM_USE_CLASS_1
0C93: 7F       RET                 (0656)     ret
                                   (0657) .ENDSECTION
                                   (0658) 
                                   (0659) .SECTION
                                   (0660) ;-----------------------------------------------------------------------------
                                   (0661) ;  FUNCTION NAME: USBUART_PutSHexInt
                                   (0662) ;
                                   (0663) ;  DESCRIPTION:    Print a byte in Hex (two byte) representation to the USBUART
                                   (0664) ;
                                   (0665) ;-----------------------------------------------------------------------------
                                   (0666) ;
                                   (0667) ;  ARGUMENTS:
                                   (0668) ;     A  => LSB of Int
                                   (0669) ;     X  => MSB of Int
                                   (0670) ;
                                   (0671) ;  RETURNS:
                                   (0672) ;     none
                                   (0673) ;
                                   (0674) ;  SIDE EFFECTS:
                                   (0675) ;    The A and X registers may be modified by this or future implementations
                                   (0676) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0677) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0678) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0679) ;    functions.
                                   (0680) ;          
                                   (0681)  USBUART_PutSHexInt:
                                   (0682) _USBUART_PutSHexInt:
0C94: 70 BF    AND   F,191         (0683)     RAM_PROLOGUE RAM_USE_CLASS_3
0C96: 62 D3 03 MOV   REG[211],3    (0684) 	RAM_SETPAGE_IDX2STK 
0C99: 08       PUSH  A             (0685) 	push	A	;save LSB
0C9A: 5B       MOV   A,X           (0686) 	mov 	A, X	
0C9B: 67       ASR   A             (0687) 	asr		A   ; Shift high nibble to right
0C9C: 67       ASR   A             (0688) 	asr		A
0C9D: 67       ASR   A             (0689) 	asr		A
0C9E: 67       ASR   A             (0690) 	asr		A
0C9F: 21 0F    AND   A,15          (0691) 	and		A,0Fh	; Mask off nibble
0CA1: FF C0    INDEX 0x0C63        (0692) 	index USBUART_HEX_STR;  Get Hex value
0CA3: 08       PUSH  A             (0693) 	push	A	
0CA4: 5B       MOV   A,X           (0694) 	mov		A, X	;retrieve lower nibble
0CA5: 21 0F    AND   A,15          (0695) 	and   	A,0Fh	; Mask off lower nibble
0CA7: FF BA    INDEX 0x0C63        (0696) 	index USBUART_HEX_STR	; Get Hex value
0CA9: 08       PUSH  A             (0697) 	push	A
0CAA: 4F       MOV   X,SP          (0698) 	mov 	X, SP	
0CAB: 52 FD    MOV   A,[X-3]       (0699) 	mov		A, [X-3]	;retrieve LSB
0CAD: 5C       MOV   X,A           (0700) 	mov 	X, A	; Save lower nibble
0CAE: 67       ASR   A             (0701) 	asr		A   ; Shift high nibble to right
0CAF: 67       ASR   A             (0702) 	asr		A
0CB0: 67       ASR   A             (0703) 	asr		A
0CB1: 67       ASR   A             (0704) 	asr		A
0CB2: 21 0F    AND   A,15          (0705) 	and		A,0Fh	; Mask off nibble
0CB4: FF AD    INDEX 0x0C63        (0706) 	index USBUART_HEX_STR;  Get Hex value
0CB6: 08       PUSH  A             (0707) 	push	A	
0CB7: 5B       MOV   A,X           (0708) 	mov		A, X
0CB8: 21 0F    AND   A,15          (0709) 	and   	A,0Fh	; Mask off lower nibble
0CBA: FF A7    INDEX 0x0C63        (0710) 	index USBUART_HEX_STR	; Get Hex value
0CBC: 08       PUSH  A             (0711) 	push	A
                                   (0712) 	
0CBD: 50 04    MOV   A,4           (0713) 	mov		A, 4	; 4 bytes to transfer
0CBF: 08       PUSH  A             (0714) 	push	A
                                   (0715) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0CC0: 5D D1    MOV   A,REG[209]    (0716)     mov   	A, reg[STK_PP]
                                   (0717) ELSE	
                                   (0718) 	mov 	A, 0
                                   (0719) ENDIF	
0CC2: 08       PUSH  A             (0720) 	push	A	;put MSB of dataPtr  - prepare to Write call
0CC3: 4F       MOV   X,SP          (0721) 	mov 	X, SP
0CC4: 5B       MOV   A,X           (0722) 	mov		A, X
0CC5: 11 06    SUB   A,6           (0723) 	sub 	A, 6
0CC7: 08       PUSH  A             (0724) 	push	A	;put LSB of dataPtr - prepare to Write call
0CC8: 7C 0B 80 LCALL 0x0B80        (0725) 	lcall 	USBUART_Write
0CCB: 38 F8    ADD   SP,248        (0726) 	add		SP, 248
0CCD: 70 3F    AND   F,63
0CCF: 71 C0    OR    F,192         (0727) 	RAM_EPILOGUE RAM_USE_CLASS_3
0CD1: 7F       RET                 (0728)     ret
                                   (0729) .ENDSECTION
                                   (0730) 
                                   (0731) .SECTION
                                   (0732) ;-----------------------------------------------------------------------------
                                   (0733) ;  FUNCTION NAME: USBUART_Read
                                   (0734) ;
                                   (0735) ;  DESCRIPTION:    This function reads from the specified endpoint buffer
                                   (0736) ;                  with the count number of bytes.
                                   (0737) ;
                                   (0738) ;-----------------------------------------------------------------------------
                                   (0739) ;
                                   (0740) ;  ARGUMENTS:
                                   (0741) ;     [SP-5] Count to read
                                   (0742) ;     [SP-4] MSB of data array address to put data in
                                   (0743) ;     [SP-3] LSB of data array address to put data in
                                   (0744) ;
                                   (0745) ;  RETURNS:
                                   (0746) ;     none
                                   (0747) ;
                                   (0748) ;  SIDE EFFECTS:
                                   (0749) ;    The A and X registers may be modified by this or future implementations
                                   (0750) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0751) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0752) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0753) ;    functions.
                                   (0754) ;          
                                   (0755) ;    Currently only the page pointer registers listed below are modified: 
                                   (0756) ;          CUR_PP
                                   (0757) ;          IDX_PP
                                   (0758) ;
                                   (0759) DATA_LSBR:   equ -3           ; MSB pointer of data
                                   (0760) DATA_MSBR:   equ -4           ; LSB pointer of data
                                   (0761) CNTLEN:		 equ -5           ; Length of data to send
                                   (0762) 
                                   (0763)  USBUART_Read:
                                   (0764) _USBUART_Read:
                                   (0765)     RAM_PROLOGUE RAM_USE_CLASS_4
0CD2: 70 BF    AND   F,191         (0766)     RAM_PROLOGUE RAM_USE_CLASS_3
0CD4: 62 D0 00 MOV   REG[208],0    (0767) 	RAM_SETPAGE_CUR >USBUART_bCurrentDevice ; Set the CUR_PP to the right page
0CD7: 62 D3 03 MOV   REG[211],3    (0768)     RAM_SETPAGE_IDX2STK    
                                   (0769) 
                                   (0770)     ;Get the count value passed
0CDA: 4F       MOV   X,SP          (0771) 	mov		X, SP
0CDB: 52 FB    MOV   A,[X-5]       (0772) 	mov     A, [X+CNTLEN]                 ; Get the Count
0CDD: 53 3C    MOV   [60],A        (0773) 	mov     [USBUART_APITemp], A          ; Save the count
                                   (0774) 	
                                   (0775)     ;Determine which is smaller the requested data or the available data
0CDF: 5D 53    MOV   A,REG[83]     (0776) 	mov     A, reg[USBUART_EP3CNT0]        ; Get the Real count
0CE1: 53 3D    MOV   [61],A        (0777) 	mov 	[USBUART_APITemp+1], A ; set the reminder
0CE3: 11 02    SUB   A,2           (0778) 	sub 	A, 2
0CE5: 3A 3C    CMP   A,[60]        (0779) 	cmp     A, [USBUART_APITemp]           ; Are they equal
0CE7: A0 07    JZ    0x0CEF        (0780) 	jz      .CountCorrect                  ; If they are check if they are 1
0CE9: D0 05    JNC   0x0CEF        (0781) 	jnc      .CountCorrect                 ;If the requested count is smaller use it 
0CEB: 50 80    MOV   A,128         (0782) 	mov 	A, 80h	; Set error condition and exit
0CED: 80 4A    JMP   0x0D38        (0783) 	jmp 	.exit
                                   (0784) .CountCorrect:
                                   (0785) ; First we need to determine where, within the PMA, the EP Start Address is
0CEF: 5D 6E    MOV   A,REG[110]    (0786) 	mov     A, reg[TMP_DR2]                ; Get the address of ep from tmp register 
0CF1: 71 10    OR    F,16          (0787) 	M8C_SetBank1
0CF3: 60 50    MOV   REG[80],A     (0788) 	mov     reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
0CF5: 70 EF    AND   F,239         (0789) 	M8C_SetBank0
                                   (0790) 
                                   (0791) ; Now we are ready to start moving data
0CF7: 51 3C    MOV   A,[60]        (0792) 	mov     A, [USBUART_APITemp]           ; Check the Count register
0CF9: A0 14    JZ    0x0D0E        (0793) 	jz      .done                          ; If it is 0 then we have a 0 length packet
                                   (0794) 
                                   (0795) .start_send:
0CFB: 52 FD    MOV   A,[X-3]       (0796) 	mov     A, [X+DATA_LSBR]               ; Get the LSB of the pointer
0CFD: 08       PUSH  A             (0797) 	push    A                              ; save on stack
                                   (0798) IF SYSTEM_LARGE_MEMORY_MODEL
0CFE: 52 FC    MOV   A,[X-4]       (0799) 	mov     A, [X+DATA_MSBR]               ; Get the MSB of the pointer
0D00: 60 D3    MOV   REG[211],A    (0800) 	mov     reg[IDX_PP], A                 ; Use as value for IDX_PP
                                   (0801) ENDIF
0D02: 20       POP   X             (0802) 	pop     X                              ; Get the LSB again
                                   (0803) 
                                   (0804) .loop: 
0D03: 5D 40    MOV   A,REG[64]     (0805) 	mov     A, reg[PMA0_DR]                ; Get the data from the PMA space
0D05: 54 00    MOV   [X+0],A       (0806) 	mov		[X], A                            ; save it in data array
0D07: 75       INC   X             (0807) 	inc     X                              ; increment the pointer
0D08: 7A 3D    DEC   [61]          (0808) 	dec		[USBUART_APITemp+1]               ; decrement the reminder
0D0A: 7A 3C    DEC   [60]          (0809) 	dec     [USBUART_APITemp]              ; decrement the counter
0D0C: BF F6    JNZ   0x0D03        (0810) 	jnz     .loop                          ; wait for count to zero out
                                   (0811) 
                                   (0812) .done:
0D0E: 4F       MOV   X,SP          (0813) 	mov		X, SP
0D0F: 5D 6E    MOV   A,REG[110]    (0814)     mov     A, reg[TMP_DR2]
0D11: 03 FB    ADD   A,[X-5]       (0815)     add     A, [X+CNTLEN]
0D13: 60 6E    MOV   REG[110],A    (0816)     mov     reg[TMP_DR2], A 
0D15: 3C 3D 02 CMP   [61],2        (0817) 	cmp 	[USBUART_APITemp+1], 2 	; If only 2 bytes of checksum left in EP
0D18: A0 07    JZ    0x0D20        (0818) 	jz		.BufferEmpty
0D1A: 51 3D    MOV   A,[61]        (0819) 	mov		A, [USBUART_APITemp+1]		; Prepare count reminder for return
0D1C: 60 53    MOV   REG[83],A     (0820) 	mov		reg[USBUART_EP3CNT0], A
0D1E: 80 19    JMP   0x0D38        (0821) 	jmp .exit
                                   (0822) 
                                   (0823) .BufferEmpty:	
0D20: 55 29 00 MOV   [41],0        (0824)     mov     [USBUART_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0D23: 62 53 40 MOV   REG[83],64    (0825) 	mov     reg[USBUART_EP3CNT0], 64 
0D26: 71 10    OR    F,16          (0826) 	M8C_SetBank1
0D28: 62 6E 80 MOV   REG[110],128  (0827) 	mov		reg[TMP_DR2], 128
0D2B: 5D 6E    MOV   A,REG[110]    (0828)     mov     A, reg[TMP_DR2]
0D2D: 60 43    MOV   REG[67],A     (0829) 	mov     reg[PMA3_WA], A
0D2F: 5D C6    MOV   A,REG[198]    (0830)     mov     A, reg[USBUART_EP3MODE]    ; Unlock the mode register
0D31: 62 C6 09 MOV   REG[198],9    (0831)     mov     reg[USBUART_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0D34: 50 00    MOV   A,0           (0832) 	mov 	A, 0;	; No error and no bytes left in EP
0D36: 70 EF    AND   F,239         (0833)     M8C_SetBank0
0D38: 70 3F    AND   F,63
                                   (0834) 	
                                   (0835) .exit:
0D3A: 71 C0    OR    F,192         (0836)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0837) 	RAM_EPILOGUE RAM_USE_CLASS_4
0D3C: 7F       RET                 (0838)     ret
                                   (0839) .ENDSECTION
                                   (0840) 
                                   (0841) .SECTION
                                   (0842) ;-----------------------------------------------------------------------------
                                   (0843) ;  FUNCTION NAME: USBUART_ReadAll
                                   (0844) ;
                                   (0845) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                   (0846) ;
                                   (0847) ;-----------------------------------------------------------------------------
                                   (0848) ;
                                   (0849) ;  ARGUMENTS:
                                   (0850) ;     A - MSB of data array address to put data in
                                   (0851) ;     X - LSB of data array address to put data in
                                   (0852) ;
                                   (0853) ;  RETURNS:
                                   (0854) ;     none
                                   (0855) ;
                                   (0856) ;  SIDE EFFECTS:
                                   (0857) ;    The A and X registers may be modified by this or future implementations
                                   (0858) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0859) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0860) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0861) ;    functions.
                                   (0862) ;          
                                   (0863) 
                                   (0864)  USBUART_ReadAll:
                                   (0865) _USBUART_ReadAll:
                                   (0866)     RAM_PROLOGUE RAM_USE_CLASS_2
0D3D: 38 01    ADD   SP,1          (0867) 	add		SP, 1	; Prepare space for number of bytes
0D3F: 08       PUSH  A             (0868) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D40: 10       PUSH  X             (0869) 	push	X	;put LSB of dataPtr - prepare to Write call
0D41: 5D 53    MOV   A,REG[83]     (0870)     mov     A, reg[USBUART_EP3CNT0]    ; Here is the count
0D43: 11 02    SUB   A,2           (0871) 	sub		A, 2
0D45: 4F       MOV   X,SP          (0872) 	mov		X, SP
0D46: 54 FD    MOV   [X-3],A       (0873) 	mov 	[X-3], A ; put the number of bytes
0D48: 7C 0C D2 LCALL 0x0CD2        (0874) 	lcall 	USBUART_Read
0D4B: 38 FD    ADD   SP,253        (0875) 	add		SP, 253
0D4D: 70 3F    AND   F,63
0D4F: 71 C0    OR    F,192         (0876)     RAM_EPILOGUE RAM_USE_CLASS_2
0D51: 7F       RET                 (0877)     ret
                                   (0878) .ENDSECTION
                                   (0879) 
                                   (0880) .SECTION
                                   (0881) ;-----------------------------------------------------------------------------
                                   (0882) ;  FUNCTION NAME: USBUART_ReadChar
                                   (0883) ;
                                   (0884) ;  DESCRIPTION:    This function reads all from the Rx associated endpoint buffer
                                   (0885) ;
                                   (0886) ;-----------------------------------------------------------------------------
                                   (0887) ;
                                   (0888) ;  ARGUMENTS:
                                   (0889) ;     none
                                   (0890) ;
                                   (0891) ;  RETURNS:
                                   (0892) ;     none
                                   (0893) ;
                                   (0894) ;  SIDE EFFECTS:
                                   (0895) ;    The A and X registers may be modified by this or future implementations
                                   (0896) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0897) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0898) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0899) ;    functions.
                                   (0900) ;          
                                   (0901) 
                                   (0902)  USBUART_ReadChar:
                                   (0903) _USBUART_ReadChar:
                                   (0904)     RAM_PROLOGUE RAM_USE_CLASS_1
0D52: 38 01    ADD   SP,1          (0905) 	add		SP, 1	; Prepare placeholder in stack
0D54: 50 01    MOV   A,1           (0906) 	mov		A, 1
0D56: 08       PUSH  A             (0907) 	push	A		; Read one byte
                                   (0908) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0D57: 5D D1    MOV   A,REG[209]    (0909)     mov   	A, reg[STK_PP]
                                   (0910) ELSE	
                                   (0911) 	mov 	A, 0
                                   (0912) ENDIF	
0D59: 08       PUSH  A             (0913) 	push	A	;put MSB of dataPtr  - prepare to Write call
0D5A: 4F       MOV   X,SP          (0914) 	mov 	X, SP
0D5B: 5B       MOV   A,X           (0915) 	mov		A, X
0D5C: 11 03    SUB   A,3           (0916) 	sub 	A, 3
0D5E: 08       PUSH  A             (0917) 	push	A	;put LSB of dataPtr - prepare to Write call
0D5F: 7C 0C D2 LCALL 0x0CD2        (0918) 	lcall 	USBUART_Read
0D62: 38 FD    ADD   SP,253        (0919) 	add		SP, 253
0D64: 5C       MOV   X,A           (0920) 	mov		X, A	;copy status to MSB
0D65: 18       POP   A             (0921) 	pop		A	; Get the character from the stack;
                                   (0922)     RAM_EPILOGUE RAM_USE_CLASS_1
0D66: 7F       RET                 (0923)     ret
                                   (0924) .ENDSECTION
                                   (0925) 
                                   (0926) .SECTION
                                   (0927) ;-----------------------------------------------------------------------------
                                   (0928) ;  FUNCTION NAME: USBUART_bTxIsReady
                                   (0929) ;
                                   (0930) ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for 
                                   (0931) ;                 an endpoint
                                   (0932) ;
                                   (0933) ;-----------------------------------------------------------------------------
                                   (0934) ;
                                   (0935) ;  ARGUMENTS:    
                                   (0936) ;	none
                                   (0937) ;
                                   (0938) ;  RETURNS:       A is 0 if Tx is not ready and non-zero if it is
                                   (0939) ;
                                   (0940) ;  SIDE EFFECTS: 
                                   (0941) ;    The A and X registers may be modified by this or future implementations
                                   (0942) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0943) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0944) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0945) ;    functions.
                                   (0946) ;
                                   (0947)  USBUART_bTxIsReady:
                                   (0948) _USBUART_bTxIsReady:
                                   (0949)     RAM_PROLOGUE RAM_USE_CLASS_1
0D67: 71 10    OR    F,16          (0950) 	M8C_SetBank1
0D69: 5D C5    MOV   A,REG[197]    (0951)     mov    A, reg[USBUART_EP2MODE]
0D6B: 70 EF    AND   F,239         (0952) 	M8C_SetBank0
0D6D: 21 10    AND   A,16          (0953)     and    A, 0x10
0D6F: 7F       RET                 (0954)     ret                                ; Exit
                                   (0955)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0956) .ENDSECTION
                                   (0957) 
                                   (0958) 
                                   (0959) .SECTION
                                   (0960) ;-----------------------------------------------------------------------------
                                   (0961) ;  FUNCTION NAME: USBUART_Init
                                   (0962) ;
                                   (0963) ;  DESCRIPTION:    Try to initialize USBUART device if it already enumerated
                                   (0964) ;
                                   (0965) ;-----------------------------------------------------------------------------
                                   (0966) ;
                                   (0967) ;  ARGUMENTS:  None
                                   (0968) ;
                                   (0969) ;  RETURNS:	1 if successfully initialized, otherwise 0
                                   (0970) ;
                                   (0971) ;  SIDE EFFECTS: 
                                   (0972) ;    The A and X registers may be modified by this or future implementations
                                   (0973) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0974) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0975) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0976) ;    functions.
                                   (0977) ;
                                   (0978)  USBUART_Init:
                                   (0979) _USBUART_Init:
                                   (0980)     RAM_PROLOGUE RAM_USE_CLASS_4
0D70: 70 BF    AND   F,191         (0981)     RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0982) ; check that USB is configured
0D72: 62 D0 00 MOV   REG[208],0    (0983) 	RAM_SETPAGE_CUR >USBUART_Configuration
0D75: 51 01    MOV   A,[1]         (0984)     mov     A,[USBUART_Configuration]
0D77: A0 3C    JZ    0x0DB4        (0985) 	jz		.done
                                   (0986) ; load zero length dummy packet to EP2
0D79: 62 D0 00 MOV   REG[208],0    (0987) 	RAM_SETPAGE_CUR >USBUART_bCurrentDevice ; Set the CUR_PP to the right page
                                   (0988) 
                                   (0989)     ;SET THE COUNT AND TOGGLE
0D7C: 62 51 00 MOV   REG[81],0     (0990)     mov     reg[USBUART_EP2CNT0], 0     ; Write it into the register
0D7F: 51 1F    MOV   A,[31]        (0991) 	mov     A, [USBUART_EPDataToggle+2]    ; Get The Data toggle for EP
0D81: 60 50    MOV   REG[80],A     (0992) 	mov     reg[USBUART_EP2CNT1], A        ; Write it into the register
                                   (0993)     
                                   (0994)     ; It's Time to move the data
                                   (0995)     ; First we need to determine where, within the PMA, the EP Start Address is
0D83: 62 D3 03 MOV   REG[211],3    (0996)     RAM_SETPAGE_IDX2STK	
0D86: 5D 6D    MOV   A,REG[109]    (0997) 	mov     A, reg[TMP_DR1]                ; Get the address of ep from tmp register 
0D88: 71 10    OR    F,16          (0998) 	M8C_SetBank1
0D8A: 60 40    MOV   REG[64],A     (0999) 	mov     reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space 
0D8C: 70 EF    AND   F,239         (1000) 	M8C_SetBank0	
                                   (1001) 
                                   (1002)     ; Now we are ready to start moving data
0D8E: 55 28 00 MOV   [40],0        (1003)     mov     [USBUART_EndpointAPIStatus+2], NO_EVENT_PENDING ; Set the state
0D91: 71 10    OR    F,16          (1004) 	M8C_SetBank1	
0D93: 5D 6D    MOV   A,REG[109]    (1005) 	mov     A, reg[TMP_DR1]               ; Get the value of the PMA start Address								
0D95: 60 52    MOV   REG[82],A     (1006) 	mov     reg[PMA2_RA], A               ; Load it into EP PMA so pre-fetch occurs                                          
0D97: 62 C5 0D MOV   REG[197],13   (1007) 	mov     reg[USBUART_EP2MODE], USB_MODE_ACK_IN ; Enable the endpoint
0D9A: 70 EF    AND   F,239         (1008) 	M8C_SetBank0	
                                   (1009) 
                                   (1010) ; Enable EP 3
0D9C: 62 D3 00 MOV   REG[211],0    (1011)     RAM_SETPAGE_IDX >USBUART_EndpointAPIStatus
0D9F: 55 29 00 MOV   [41],0        (1012)     mov     [USBUART_EndpointAPIStatus+3], NO_EVENT_PENDING ; For the API
0DA2: 62 53 40 MOV   REG[83],64    (1013) 	mov     reg[USBUART_EP3CNT0], 64 
0DA5: 71 10    OR    F,16          (1014) 	M8C_SetBank1
0DA7: 5D 6E    MOV   A,REG[110]    (1015)     mov     A, reg[TMP_DR2]
0DA9: 60 43    MOV   REG[67],A     (1016) 	mov     reg[PMA3_WA], A
0DAB: 5D C6    MOV   A,REG[198]    (1017)     mov     A, reg[USBUART_EP3MODE]    ; Unlock the mode register
0DAD: 62 C6 09 MOV   REG[198],9    (1018)     mov     reg[USBUART_EP3MODE], USB_MODE_ACK_OUT ; Enable the endpoint
0DB0: 70 EF    AND   F,239         (1019)     M8C_SetBank0
                                   (1020) 
                                   (1021) ; prepare return
0DB2: 50 01    MOV   A,1           (1022) 	mov		A, 1
0DB4: 70 3F    AND   F,63
                                   (1023) 	
                                   (1024) .done:
0DB6: 71 C0    OR    F,192         (1025)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1026) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DB8: 7F       RET                 (1027)     ret
                                   (1028) .ENDSECTION
                                   (1029) 
                                   (1030) .SECTION
                                   (1031) ;-----------------------------------------------------------------------------
                                   (1032) ;  FUNCTION NAME: USBUART_dwGetDTERate
                                   (1033) ;
                                   (1034) ;  DESCRIPTION:    Return DTE Rate 
                                   (1035) ;
                                   (1036) ;-----------------------------------------------------------------------------
                                   (1037) ;
                                   (1038) ;  ARGUMENTS:  None
                                   (1039) ;
                                   (1040) ;  RETURNS:	DWORD containing DTE rate in bits per second
                                   (1041) ;
                                   (1042) ;  SIDE EFFECTS: 
                                   (1043) ;    The A and X registers may be modified by this or future implementations
                                   (1044) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1045) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1046) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1047) ;    functions.
                                   (1048) ;
                                   (1049) USBUART_dwGetDTERate:
                                   (1050) _USBUART_dwGetDTERate:
                                   (1051) 	RAM_PROLOGUE RAM_USE_CLASS_4
0DB9: 70 BF    AND   F,191         (1052) 	RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1053) 	; Disable interrupt here
0DBB: 41 DF FB AND   REG[223],251  (1054) 	M8C_DisableIntMask USBUART_INT_REG, USBUART_INT_EP0_MASK
0DBE: 62 D0 00 MOV   REG[208],0    (1055) 	RAM_SETPAGE_CUR >USBUART_LineCoding
0DC1: 60 D3    MOV   REG[211],A    (1056) 	RAM_SETPAGE_IDX A
0DC3: 08       PUSH  A             (1057) 	push  A
0DC4: 51 36    MOV   A,[54]        (1058) 	mov   A,[USBUART_LineCoding + 3]
0DC6: 54 00    MOV   [X+0],A       (1059) 	mov   [X + 0],A
0DC8: 51 35    MOV   A,[53]        (1060) 	mov   A,[USBUART_LineCoding + 2]
0DCA: 54 01    MOV   [X+1],A       (1061) 	mov   [X + 1],A
0DCC: 51 34    MOV   A,[52]        (1062) 	mov   A,[USBUART_LineCoding + 1]
0DCE: 54 02    MOV   [X+2],A       (1063) 	mov   [X + 2],A
0DD0: 51 33    MOV   A,[51]        (1064) 	mov   A,[USBUART_LineCoding]
0DD2: 54 03    MOV   [X+3],A       (1065) 	mov   [X + 3],A
0DD4: 18       POP   A             (1066) 	pop   A
                                   (1067)    
0DD5: 43 DF 04 OR    REG[223],4    (1068) 	M8C_EnableIntMask USBUART_INT_REG, USBUART_INT_EP0_MASK
0DD8: 70 3F    AND   F,63
                                   (1069) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DDA: 71 C0    OR    F,192         (1070) 	RAM_EPILOGUE RAM_USE_CLASS_3
0DDC: 7F       RET                 (1071) 	ret
                                   (1072) .ENDSECTION
                                   (1073) 
                                   (1074) .SECTION
                                   (1075) ;-----------------------------------------------------------------------------
                                   (1076) ;  FUNCTION NAME: USBUART_bGetCharFormat
                                   (1077) ;
                                   (1078) ;  DESCRIPTION:    Returns number of stop bits
                                   (1079) ;
                                   (1080) ;-----------------------------------------------------------------------------
                                   (1081) ;
                                   (1082) ;  ARGUMENTS:  None
                                   (1083) ;
                                   (1084) ;  RETURNS:	BYTE containing character format (data bits)
                                   (1085) ;				 (0 = 1 stop bit, 1 = 1.5 stop bit, 2 = 2 stop bit)
                                   (1086) ;
                                   (1087) ;  SIDE EFFECTS: 
                                   (1088) ;    The A and X registers may be modified by this or future implementations
                                   (1089) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1090) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1091) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1092) ;    functions.
                                   (1093) ;
                                   (1094) USBUART_bGetCharFormat:
                                   (1095) _USBUART_bGetCharFormat:
                                   (1096) 	RAM_PROLOGUE RAM_USE_CLASS_4
0DDD: 62 D0 00 MOV   REG[208],0    (1097) 	RAM_SETPAGE_CUR >USBUART_LineCoding
0DE0: 51 37    MOV   A,[55]        (1098) 	mov A, [USBUART_LineCoding+4];
                                   (1099) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DE2: 7F       RET                 (1100) 	ret
                                   (1101) .ENDSECTION
                                   (1102) 
                                   (1103) .SECTION
                                   (1104) ;-----------------------------------------------------------------------------
                                   (1105) ;  FUNCTION NAME: USBUART_bGetParityType
                                   (1106) ;
                                   (1107) ;  DESCRIPTION:    Return Parity type 
                                   (1108) ;
                                   (1109) ;-----------------------------------------------------------------------------
                                   (1110) ;
                                   (1111) ;  ARGUMENTS:  None
                                   (1112) ;
                                   (1113) ;  RETURNS:	Parity type 
                                   (1114) ;				 (0 = none, 1 = odd, 2 = even, 3 = mark, 4 = space)
                                   (1115) ;
                                   (1116) ;  SIDE EFFECTS: 
                                   (1117) ;    The A and X registers may be modified by this or future implementations
                                   (1118) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1119) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1120) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1121) ;    functions.
                                   (1122) ;
                                   (1123) USBUART_bGetParityType:
                                   (1124) _USBUART_bGetParityType:
                                   (1125) 	RAM_PROLOGUE RAM_USE_CLASS_4
0DE3: 62 D0 00 MOV   REG[208],0    (1126) 	RAM_SETPAGE_CUR >USBUART_LineCoding
0DE6: 51 38    MOV   A,[56]        (1127) 	mov A, [USBUART_LineCoding+5];
                                   (1128) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DE8: 7F       RET                 (1129) 	ret
                                   (1130) .ENDSECTION
                                   (1131) 
                                   (1132) .SECTION
                                   (1133) ;-----------------------------------------------------------------------------
                                   (1134) ;  FUNCTION NAME: USBUART_bGetDataBits
                                   (1135) ;
                                   (1136) ;  DESCRIPTION:    Returns data bits (5,6,7,8 or 16)
                                   (1137) ;
                                   (1138) ;-----------------------------------------------------------------------------
                                   (1139) ;
                                   (1140) ;  ARGUMENTS:  None
                                   (1141) ;
                                   (1142) ;  RETURNS:	Data bits 
                                   (1143) ;				 (5,6,7,8 or 16)
                                   (1144) ;
                                   (1145) ;  SIDE EFFECTS: 
                                   (1146) ;    The A and X registers may be modified by this or future implementations
                                   (1147) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1148) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1149) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1150) ;    functions.
                                   (1151) ;
                                   (1152) USBUART_bGetDataBits:
                                   (1153) _USBUART_bGetDataBits:
                                   (1154) 	RAM_PROLOGUE RAM_USE_CLASS_4
0DE9: 62 D0 00 MOV   REG[208],0    (1155) 	RAM_SETPAGE_CUR >USBUART_LineCoding
0DEC: 51 39    MOV   A,[57]        (1156) 	mov A, [USBUART_LineCoding+6];
                                   (1157) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DEE: 7F       RET                 (1158) 	ret
                                   (1159) .ENDSECTION
                                   (1160) 
                                   (1161) .SECTION
                                   (1162) ;-----------------------------------------------------------------------------
                                   (1163) ;  FUNCTION NAME: USBUART_bGetLineControl
                                   (1164) ;
                                   (1165) ;  DESCRIPTION:    Return Line Control Bitmap
                                   (1166) ;
                                   (1167) ;-----------------------------------------------------------------------------
                                   (1168) ;
                                   (1169) ;  ARGUMENTS:  None
                                   (1170) ;
                                   (1171) ;  RETURNS:	Line control bitmap
                                   (1172) ;				D7..D2 - reserved
                                   (1173) ;				D1 - RTS (0 = deactivate carrier, 1 = activate carrier)
                                   (1174) ;				D0 - DTR (0 = not present, 1 = present);
                                   (1175) ;
                                   (1176) ;  SIDE EFFECTS: 
                                   (1177) ;    The A and X registers may be modified by this or future implementations
                                   (1178) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1179) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1180) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1181) ;    functions.
                                   (1182) ;
                                   (1183) USBUART_bGetLineControlBitmap:
                                   (1184) _USBUART_bGetLineControlBitmap:
                                   (1185) 	RAM_PROLOGUE RAM_USE_CLASS_4
0DEF: 62 D0 00 MOV   REG[208],0    (1186) 	RAM_SETPAGE_CUR >USBUART_LineControlBitmap
0DF2: 51 3B    MOV   A,[59]        (1187) 	mov A, [USBUART_LineControlBitmap+1];
                                   (1188) 	RAM_EPILOGUE RAM_USE_CLASS_4
0DF4: 7F       RET                 (1189) 	ret
                                   (1190) .ENDSECTION
                                   (1191) 
                                   (1192) .SECTION
                                   (1193) ;-----------------------------------------------------------------------------
                                   (1194) ;  FUNCTION NAME: USBUART_SendStateNotify
                                   (1195) ;
                                   (1196) ;  DESCRIPTION:    Send notification about UART state
                                   (1197) ;
                                   (1198) ;-----------------------------------------------------------------------------
                                   (1199) ;
                                   (1200) ;  ARGUMENTS:
                                   (1201) ;     	A - State bitmap
                                   (1202) ;
                                   (1203) ;  RETURNS:
                                   (1204) ;     none
                                   (1205) ;
                                   (1206) ;  SIDE EFFECTS:
                                   (1207) ;    The A and X registers may be modified by this or future implementations
                                   (1208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1210) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1211) ;    functions.
                                   (1212) ;          
                                   (1213) ;    Currently only the page pointer registers listed below are modified: 
                                   (1214) ;          CUR_PP
                                   (1215) ;          IDX_PP
                                   (1216) ;
                                   (1217) ; -2 and -3 is the return address to caller
                                   (1218)  USBUART_SendStateNotify:
                                   (1219) _USBUART_SendStateNotify:
                                   (1220)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1221)     ;Should we toggle the data bit??
                                   (1222)     ;SET THE COUNT AND TOGGLE
0DF5: 08       PUSH  A             (1223) 	push 	A
0DF6: 55 3C 0A MOV   [60],10       (1224) 	mov     [USBUART_APITemp], 10         ; Save the count
0DF9: 36 1E 80 XOR   [30],128      (1225) 	xor     [USBUART_EPDataToggle+1], USB_CNT_TOGGLE
                                   (1226) 
0DFC: 62 4F 0A MOV   REG[79],10    (1227)     mov     reg[USBUART_EP1CNT0], 10    ; Write it into the register
0DFF: 51 1E    MOV   A,[30]        (1228) 	mov     A, [USBUART_EPDataToggle+1]    ; Retrieve the saved toggle (MSB)
0E01: 60 4E    MOV   REG[78],A     (1229) 	mov     reg[USBUART_EP1CNT1], A        ; Write it into the register
                                   (1230)     
                                   (1231) ; It's Time to move the data
                                   (1232) ; First we need to determine where, within the PMA, the EP Start Address is
0E03: 5D 6C    MOV   A,REG[108]    (1233) 	mov     A, reg[TMP_DR0]                ; Get the address of ep from tmp register 
0E05: 71 10    OR    F,16          (1234) 	M8C_SetBank1
0E07: 60 40    MOV   REG[64],A     (1235) 	mov     reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space 
0E09: 70 EF    AND   F,239         (1236) 	M8C_SetBank0	
                                   (1237) 
                                   (1238) ; Now we are y to start moving data
0E0B: 62 40 A1 MOV   REG[64],161   (1239) 	mov		reg[PMA0_DR], A1h	; bmRequestType
0E0E: 62 40 20 MOV   REG[64],32    (1240) 	mov		reg[PMA0_DR], 20h	; Serial State
0E11: 62 40 00 MOV   REG[64],0     (1241) 	mov		reg[PMA0_DR], 0		; wValue MSB
0E14: 62 40 00 MOV   REG[64],0     (1242) 	mov		reg[PMA0_DR], 0		; wValue LSB
0E17: 62 40 00 MOV   REG[64],0     (1243) 	mov		reg[PMA0_DR], 0		; wIndex MSB
0E1A: 62 40 00 MOV   REG[64],0     (1244) 	mov		reg[PMA0_DR], 0		; wIndex (Interface)
0E1D: 62 40 00 MOV   REG[64],0     (1245) 	mov		reg[PMA0_DR], 0		;wLen
0E20: 62 40 02 MOV   REG[64],2     (1246) 	mov		reg[PMA0_DR], 2		;wLen
0E23: 62 40 00 MOV   REG[64],0     (1247) 	mov		reg[PMA0_DR], 0		;wLen
0E26: 18       POP   A             (1248) 	pop		A
0E27: 60 40    MOV   REG[64],A     (1249) 	mov		reg[PMA0_DR], A		;State bitmap
                                   (1250) 	
0E29: 55 27 00 MOV   [39],0        (1251)     mov     [USBUART_EndpointAPIStatus+1], NO_EVENT_PENDING ; Set the state
0E2C: 71 10    OR    F,16          (1252) 	M8C_SetBank1	
0E2E: 5D 6C    MOV   A,REG[108]    (1253) 	mov     A, reg[TMP_DR0]               ; Get the value of the PMA start Address								
0E30: 60 51    MOV   REG[81],A     (1254) 	mov     reg[PMA0_RA+1], A             ; Load it into EP PMA so pre-fetch occurs                                          
0E32: 62 C4 0D MOV   REG[196],13   (1255)     mov     reg[USBUART_EP1MODE], USB_MODE_ACK_IN ; Enable the endpoint
0E35: 70 EF    AND   F,239         (1256) 	M8C_SetBank0	
                                   (1257)     RAM_EPILOGUE RAM_USE_CLASS_1
0E37: 7F       RET                 (1258)     ret

FILE: .\main.c
(0001) /** 
(0002)  * @file  main.c
(0003)  * @brief PSoC USBUARTeXg C
(0004)  *
(0005)  * @author Yasuhiro ISHII
(0006)  * @date 2007-01-01
(0007)  * @version $Id: $
(0008)  *
(0009)  */
(0010) 
(0011) #include <m8c.h>        // part specific constants and macros
(0012) #include <stdlib.h>
(0013) #include "common.h"
(0014) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0015) 
(0016) static void usbuart_stdout(char* str);
(0017) 
(0018) BYTE pData[32];  
(0019) int Len;
(0020) 
(0021) void main(void){
_main:
  ram                  --> X+2
  i                    --> X+0
__text_start:
0E38: 10       PUSH  X
0E39: 4F       MOV   X,SP
0E3A: 38 0C    ADD   SP,12
(0022) 	int i = 30;
0E3C: 56 01 1E MOV   [X+1],30
0E3F: 56 00 00 MOV   [X+0],0
(0023) 	char ram[10];
(0024) 
(0025) 	M8C_EnableGInt;							// Global InterruptsL
0E42: 71 01    OR    F,1
(0026) 
(0027) 	USBUART_Start(USBUART_5V_OPERATION);
0E44: 10       PUSH  X
0E45: 50 03    MOV   A,3
0E47: 7C 0A F4 LCALL 0x0AF4
0E4A: 20       POP   X
(0028) 	tprintf_SetCallBack(usbuart_stdout);	// tprintfopR[obNo^
0E4B: 50 01    MOV   A,1
0E4D: 08       PUSH  A
0E4E: 50 D7    MOV   A,215
0E50: 08       PUSH  A
0E51: 7C 0F C4 LCALL _tprintf_SetCallBack
0E54: 38 FE    ADD   SP,254
(0029) 	while(!USBUART_Init());					// USBUART
0E56: 10       PUSH  X
0E57: 7C 0D 70 LCALL 0x0D70
0E5A: 62 D0 00 MOV   REG[208],0
0E5D: 20       POP   X
0E5E: 39 00    CMP   A,0
0E60: AF F5    JZ    0x0E56
0E62: 80 7D    JMP   0x0EE0
(0030) 
(0031) 	///////////////////////////////////////////////////////////////////////////
(0032) 	// 
(0033) 	///////////////////////////////////////////////////////////////////////////
(0034) 
(0035) 	// 
(0036) 
(0037) 	while(1){
(0038) 
(0039) 		// L[
(0040) 
(0041) 		Len = USBUART_bGetRxCount();       //Get count of ready data
0E64: 10       PUSH  X
0E65: 7C 0B 63 LCALL 0x0B63
0E68: 20       POP   X
0E69: 62 D0 00 MOV   REG[208],0
0E6C: 53 66    MOV   [Len+1],A
0E6E: 55 65 00 MOV   [Len],0
(0042) 		if (Len){
0E71: 3C 65 00 CMP   [Len],0
0E74: B0 06    JNZ   0x0E7B
0E76: 3C 66 00 CMP   [Len+1],0
0E79: A0 66    JZ    0x0EE0
(0043) 			USBUART_ReadAll(pData);        //Read all data rom RX
0E7B: 10       PUSH  X
0E7C: 50 00    MOV   A,0
0E7E: 08       PUSH  A
0E7F: 50 3E    MOV   A,62
0E81: 5C       MOV   X,A
0E82: 18       POP   A
0E83: 7C 0D 3D LCALL 0x0D3D
0E86: 20       POP   X
(0044) 
(0045) 			// L[AeXgpbZ[W\
(0046) 			{
(0047) 				i++;		// CNg
0E87: 77 01    INC   [X+1]
0E89: 0F 00 00 ADC   [X+0],0
(0048) 
(0049) 				tstrcpy(ram,"R A M!");
0E8C: 50 01    MOV   A,1
0E8E: 08       PUSH  A
0E8F: 50 CE    MOV   A,206
0E91: 08       PUSH  A
0E92: 62 D0 00 MOV   REG[208],0
0E95: 5A 63    MOV   [__r1],X
0E97: 06 63 02 ADD   [__r1],2
0E9A: 50 03    MOV   A,3
0E9C: 08       PUSH  A
0E9D: 51 63    MOV   A,[__r1]
0E9F: 08       PUSH  A
0EA0: 7C 1A 38 LCALL _tstrcpy
(0050) 
(0051) 				ctprintf("i = %d(Hex:%X)(ROM:%S)(RAM:%s) %c%c%c\n\r",i,i,"Hello",ram,0x31,0x32,0x33);
0EA3: 50 00    MOV   A,0
0EA5: 08       PUSH  A
0EA6: 50 33    MOV   A,51
0EA8: 08       PUSH  A
0EA9: 50 00    MOV   A,0
0EAB: 08       PUSH  A
0EAC: 50 32    MOV   A,50
0EAE: 08       PUSH  A
0EAF: 50 00    MOV   A,0
0EB1: 08       PUSH  A
0EB2: 50 31    MOV   A,49
0EB4: 08       PUSH  A
0EB5: 62 D0 00 MOV   REG[208],0
0EB8: 5A 63    MOV   [__r1],X
0EBA: 06 63 02 ADD   [__r1],2
0EBD: 50 03    MOV   A,3
0EBF: 08       PUSH  A
0EC0: 51 63    MOV   A,[__r1]
0EC2: 08       PUSH  A
0EC3: 50 01    MOV   A,1
0EC5: 08       PUSH  A
0EC6: 50 A0    MOV   A,160
0EC8: 08       PUSH  A
0EC9: 52 00    MOV   A,[X+0]
0ECB: 08       PUSH  A
0ECC: 52 01    MOV   A,[X+1]
0ECE: 08       PUSH  A
0ECF: 52 00    MOV   A,[X+0]
0ED1: 08       PUSH  A
0ED2: 52 01    MOV   A,[X+1]
0ED4: 08       PUSH  A
0ED5: 50 01    MOV   A,1
0ED7: 08       PUSH  A
0ED8: 50 A6    MOV   A,166
0EDA: 08       PUSH  A
0EDB: 7C 0F 25 LCALL _ctprintf
0EDE: 38 EC    ADD   SP,236
0EE0: 8F 83    JMP   0x0E64
(0052) 			}
(0053) 		}
(0054) 	}
(0055) 
(0056) }
0EE2: 38 F4    ADD   SP,244
0EE4: 20       POP   X
0EE5: 8F FF    JMP   0x0EE5
(0057) 
(0058) /** USBUARTo
(0059)  * @param str oASCIIZ|C^
(0060)  */
(0061) static void usbuart_stdout(char* str){
_usbuart_stdout:
  len                  --> X+0
  str                  --> X-5
0EE7: 10       PUSH  X
0EE8: 4F       MOV   X,SP
0EE9: 38 02    ADD   SP,2
(0062) 	int len;
(0063) 
(0064) 	len = tstrlen(str) + 1;
0EEB: 52 FB    MOV   A,[X-5]
0EED: 08       PUSH  A
0EEE: 52 FC    MOV   A,[X-4]
0EF0: 08       PUSH  A
0EF1: 7C 1C 31 LCALL _tstrlen
0EF4: 38 FE    ADD   SP,254
0EF6: 62 D0 00 MOV   REG[208],0
0EF9: 51 63    MOV   A,[__r1]
0EFB: 01 01    ADD   A,1
0EFD: 54 01    MOV   [X+1],A
0EFF: 51 64    MOV   A,[__r0]
0F01: 09 00    ADC   A,0
0F03: 54 00    MOV   [X+0],A
(0065) 
(0066) 	while (!USBUART_bTxIsReady());
0F05: 10       PUSH  X
0F06: 7C 0D 67 LCALL 0x0D67
0F09: 62 D0 00 MOV   REG[208],0
0F0C: 20       POP   X
0F0D: 39 00    CMP   A,0
0F0F: AF F5    JZ    0x0F05
(0067) 	USBUART_Write(str,len);
0F11: 52 01    MOV   A,[X+1]
0F13: 10       PUSH  X
0F14: 08       PUSH  A
0F15: 52 FB    MOV   A,[X-5]
0F17: 08       PUSH  A
0F18: 52 FC    MOV   A,[X-4]
0F1A: 08       PUSH  A
0F1B: 7C 0B 80 LCALL 0x0B80
0F1E: 38 FD    ADD   SP,253
0F20: 20       POP   X
(0068) 
(0069) }
0F21: 38 FE    ADD   SP,254
0F23: 20       POP   X
0F24: 7F       RET   

FILE: .\tprintf.c
(0001) /*
(0002)   Tiny printf module
(0003)    for Embedded microcontrollers
(0004)    Copyright(C) 2005-2006 Yasuhiro ISHII
(0005)    File Version : 0.3
(0006) 
(0007)    (tsprintfuart_txsgp)
(0008) 
(0009)    0.3 : oR[obNX
(0010)    0.2 : vtsprintfn
(0011)    0.1 : First version
(0012) */
(0013) 
(0014) //#include <stdarg.h>
(0015) #include "common.h"
(0016) #include "./tsprintf.h"
(0017) 
(0018) int ctprintf(const char* , ...);
(0019) void tprintf_SetCallBack(void (*)(char*));
(0020) 
(0021) static void (*uart_txs)(char*);
(0022) 
(0023) /** constpTiny printf
(0024)  * @param fmt w
(0025)  * @param [argument]... \
(0026)  * @return 
(0027)  * @note fmtwROMmw
(0028)  */
(0029) int ctprintf(const char* fmt, ...){
_ctprintf:
  len                  --> X+82
  ap                   --> X+80
  buf                  --> X+0
  fmt                  --> X-5
0F25: 10       PUSH  X
0F26: 4F       MOV   X,SP
0F27: 38 54    ADD   SP,84
(0030) 	char buf[80];
(0031) 	va_list ap;
(0032) 	int len;
(0033) 
(0034) 	// R[obNmF
(0035) 	if (uart_txs == NULL){
0F29: 62 D0 00 MOV   REG[208],0
0F2C: 51 68    MOV   A,[uart_txs+1]
0F2E: 08       PUSH  A
0F2F: 51 67    MOV   A,[uart_txs]
0F31: 62 D0 00 MOV   REG[208],0
0F34: 53 64    MOV   [__r0],A
0F36: 18       POP   A
0F37: 53 63    MOV   [__r1],A
0F39: 51 64    MOV   A,[__r0]
0F3B: 10       PUSH  X
0F3C: 08       PUSH  A
0F3D: 58 63    MOV   X,[__r1]
0F3F: 28       ROMX  
0F40: 53 64    MOV   [__r0],A
0F42: 18       POP   A
0F43: 75       INC   X
0F44: 09 00    ADC   A,0
0F46: 28       ROMX  
0F47: 20       POP   X
0F48: 3C 64 00 CMP   [__r0],0
0F4B: B0 10    JNZ   0x0F5C
0F4D: 39 00    CMP   A,0
0F4F: B0 0C    JNZ   0x0F5C
(0036) 		return(-1);
0F51: 62 D0 00 MOV   REG[208],0
0F54: 55 63 FF MOV   [__r1],255
0F57: 55 64 FF MOV   [__r0],255
0F5A: 80 65    JMP   0x0FC0
(0037) 	}
(0038) 
(0039) 	va_start(ap, fmt);
0F5C: 62 D0 00 MOV   REG[208],0
0F5F: 5A 63    MOV   [__r1],X
0F61: 16 63 05 SUB   [__r1],5
0F64: 51 63    MOV   A,[__r1]
0F66: 54 51    MOV   [X+81],A
0F68: 56 50 03 MOV   [X+80],3
(0040) 	
(0041) 	len = cvtsprintf(buf, fmt, ap);
0F6B: 52 50    MOV   A,[X+80]
0F6D: 08       PUSH  A
0F6E: 52 51    MOV   A,[X+81]
0F70: 08       PUSH  A
0F71: 52 FB    MOV   A,[X-5]
0F73: 08       PUSH  A
0F74: 52 FC    MOV   A,[X-4]
0F76: 08       PUSH  A
0F77: 50 03    MOV   A,3
0F79: 08       PUSH  A
0F7A: 10       PUSH  X
0F7B: 7C 10 13 LCALL _cvtsprintf
0F7E: 38 FA    ADD   SP,250
0F80: 62 D0 00 MOV   REG[208],0
0F83: 51 63    MOV   A,[__r1]
0F85: 54 53    MOV   [X+83],A
0F87: 51 64    MOV   A,[__r0]
0F89: 54 52    MOV   [X+82],A
(0042) 
(0043) 	va_end(ap);
(0044) 
(0045) 	// opR[obNR[
(0046) 	(*uart_txs)(buf);
0F8B: 50 03    MOV   A,3
0F8D: 08       PUSH  A
0F8E: 10       PUSH  X
0F8F: 62 D0 00 MOV   REG[208],0
0F92: 51 68    MOV   A,[uart_txs+1]
0F94: 08       PUSH  A
0F95: 51 67    MOV   A,[uart_txs]
0F97: 62 D0 00 MOV   REG[208],0
0F9A: 53 64    MOV   [__r0],A
0F9C: 18       POP   A
0F9D: 53 63    MOV   [__r1],A
0F9F: 51 64    MOV   A,[__r0]
0FA1: 10       PUSH  X
0FA2: 08       PUSH  A
0FA3: 58 63    MOV   X,[__r1]
0FA5: 28       ROMX  
0FA6: 53 64    MOV   [__r0],A
0FA8: 18       POP   A
0FA9: 75       INC   X
0FAA: 09 00    ADC   A,0
0FAC: 28       ROMX  
0FAD: 53 63    MOV   [__r1],A
0FAF: 20       POP   X
0FB0: 7C 1D 68 LCALL __icall
0FB3: 38 FE    ADD   SP,254
(0047) 	
(0048) 	return(len);
0FB5: 62 D0 00 MOV   REG[208],0
0FB8: 52 53    MOV   A,[X+83]
0FBA: 53 63    MOV   [__r1],A
0FBC: 52 52    MOV   A,[X+82]
0FBE: 53 64    MOV   [__r0],A
0FC0: 38 AC    ADD   SP,172
0FC2: 20       POP   X
0FC3: 7F       RET   
(0049) }
(0050) 
(0051) /** Type printfWopR[obNo^
(0052)  * @param func ASCIIZovoid func(char*)^|C^
(0053)  * @note NULLw
(0054)  */
(0055) void tprintf_SetCallBack(void (*func)(char*)){
_tprintf_SetCallBack:
  func                 --> X-5
0FC4: 10       PUSH  X
0FC5: 4F       MOV   X,SP
(0056) 
(0057) 	uart_txs = func;
0FC6: 62 D0 00 MOV   REG[208],0
0FC9: 52 FC    MOV   A,[X-4]
0FCB: 53 68    MOV   [uart_txs+1],A
0FCD: 52 FB    MOV   A,[X-5]
0FCF: 53 67    MOV   [uart_txs],A
(0058) 
(0059) }
0FD1: 20       POP   X
0FD2: 7F       RET   

FILE: .\tsprintf.c
(0001) /*
(0002)   Tiny sprintf module
(0003)    for Embedded microcontrollers
(0004)    Copyright(C) 2005 Yasuhiro ISHII
(0005)    
(0006)    File Version : 1.3
(0007)    Copyright(C) 2005-2007 Yasuhiro ISHII
(0008) 
(0009)    yo[WAbvz
(0010)    0.1 : 
(0011)    0.2 : decimal0\   20050313
(0012)    0.3 : hexa decimal0\ 20050313
(0013)    0.4 : \[XR[h(^M) 20050503
(0014)    0.5 : tsprintf size 20050503
(0015)    0.6 : %d,%xunsigned 20050522
(0016)    0.7 : %d,%xw(%[n]d)/0w(%0[n]d) 20050522
(0017)    0.8 : va_listnvtsprintfAvsprintfvtsprintfe 20050522
(0018)    0.9 : hexAl01oOC 20050526
(0019)    1.0 : decAl01oOC 20050629
(0020)    1.1 : n[o[hEA[LeN`const` 20061224
(0021)    1.2 : mRAMoOC(10iA16i\)
(0022)    1.3 : PSoCp
(0023) 
(0024)    printfIgp
(0025)    mFB
(0026) 
(0027) */
(0028) #include "common.h"
(0029) #include "./tsprintf.h"
(0030) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0031) 
(0032) int ctsprintf(char* ,const char* ,...);
(0033) int cvtsprintf(char* buff,const char* fmt,va_list arg);
(0034) 
(0035) static int tsprintf_string(char* ,char* );
(0036) static int tsprintf_cstring(const char* str,char* buff);
(0037) static int tsprintf_char(int ,char* );
(0038) static int tsprintf_decimal(signed long,char* ,int ,int );
(0039) static int tsprintf_hexadecimal(unsigned long ,char* ,int ,int ,int );
(0040) 
(0041) /** Tiny sprintf(constw)
(0042)  * @param buff i[obt@|C^
(0043)  * @param fmt w
(0044)  * @param [argument]... \
(0045)  * @return 
(0046)  * @note fmtwROMmw
(0047)  */
(0048) int ctsprintf(char* buff,const char* fmt, ...){
_ctsprintf:
  result               --> X+2
  arg                  --> X+0
  fmt                  --> X-7
  buff                 --> X-5
0FD3: 10       PUSH  X
0FD4: 4F       MOV   X,SP
0FD5: 38 04    ADD   SP,4
(0049) 	va_list arg;
(0050) 	int result;
(0051) 
(0052) 	va_start(arg, fmt);
0FD7: 62 D0 00 MOV   REG[208],0
0FDA: 5A 63    MOV   [__r1],X
0FDC: 16 63 07 SUB   [__r1],7
0FDF: 51 63    MOV   A,[__r1]
0FE1: 54 01    MOV   [X+1],A
0FE3: 56 00 03 MOV   [X+0],3
(0053) 
(0054) 	result = cvtsprintf(buff,fmt,arg);
0FE6: 52 00    MOV   A,[X+0]
0FE8: 08       PUSH  A
0FE9: 52 01    MOV   A,[X+1]
0FEB: 08       PUSH  A
0FEC: 52 F9    MOV   A,[X-7]
0FEE: 08       PUSH  A
0FEF: 52 FA    MOV   A,[X-6]
0FF1: 08       PUSH  A
0FF2: 52 FB    MOV   A,[X-5]
0FF4: 08       PUSH  A
0FF5: 52 FC    MOV   A,[X-4]
0FF7: 08       PUSH  A
0FF8: 90 19    CALL  _cvtsprintf
0FFA: 38 FA    ADD   SP,250
0FFC: 62 D0 00 MOV   REG[208],0
0FFF: 51 63    MOV   A,[__r1]
1001: 54 03    MOV   [X+3],A
1003: 51 64    MOV   A,[__r0]
1005: 54 02    MOV   [X+2],A
(0055) 	
(0056) 	va_end(arg);
(0057) 
(0058) 	return(result);
1007: 52 03    MOV   A,[X+3]
1009: 53 63    MOV   [__r1],A
100B: 52 02    MOV   A,[X+2]
100D: 53 64    MOV   [__r0],A
100F: 38 FC    ADD   SP,252
1011: 20       POP   X
1012: 7F       RET   
(0059) }
(0060) 
(0061) /** Tiny vsprintf(constw)
(0062)  * @param buff i[obt@|C^
(0063)  * @param fmt w
(0064)  * @param arg 
(0065)  * @return 
(0066)  * @note fmtwROMmw
(0067)  */
(0068) int cvtsprintf(char* buff,const char* fmt,va_list arg){
_cvtsprintf:
  prev_sizeofarg       --> X+8
  width                --> X+6
  zeroflag             --> X+4
  len                  --> X+2
  size                 --> X+0
  arg                  --> X-9
  fmt                  --> X-7
  buff                 --> X-5
1013: 10       PUSH  X
1014: 4F       MOV   X,SP
1015: 38 0C    ADD   SP,12
(0069) 	int len;
(0070) 	int size;
(0071) 	int zeroflag,width;
(0072) 	int prev_sizeofarg;
(0073) 
(0074) 	prev_sizeofarg = 0;
1017: 56 09 00 MOV   [X+9],0
101A: 56 08 00 MOV   [X+8],0
(0075) 
(0076) 	size = 0;
101D: 56 01 00 MOV   [X+1],0
1020: 56 00 00 MOV   [X+0],0
(0077) 	len = 0;
1023: 56 03 00 MOV   [X+3],0
1026: 56 02 00 MOV   [X+2],0
1029: 83 72    JMP   0x139C
(0078) 
(0079) 	while(*fmt){
(0080) 		if(*fmt=='%'){		/* %  */
102B: 62 D0 00 MOV   REG[208],0
102E: 52 FA    MOV   A,[X-6]
1030: 53 63    MOV   [__r1],A
1032: 52 F9    MOV   A,[X-7]
1034: 10       PUSH  X
1035: 58 63    MOV   X,[__r1]
1037: 28       ROMX  
1038: 20       POP   X
1039: 39 25    CMP   A,37
103B: B3 1F    JNZ   0x135B
(0081) 			zeroflag = width = 0;
103D: 56 07 00 MOV   [X+7],0
1040: 56 06 00 MOV   [X+6],0
1043: 56 05 00 MOV   [X+5],0
1046: 56 04 00 MOV   [X+4],0
(0082) 			fmt++;
1049: 77 FA    INC   [X-6]
104B: 0F F9 00 ADC   [X-7],0
(0083) 
(0084) 			if (*fmt == '0'){
104E: 52 FA    MOV   A,[X-6]
1050: 53 63    MOV   [__r1],A
1052: 52 F9    MOV   A,[X-7]
1054: 10       PUSH  X
1055: 58 63    MOV   X,[__r1]
1057: 28       ROMX  
1058: 20       POP   X
1059: 39 30    CMP   A,48
105B: B0 0C    JNZ   0x1068
(0085) 				fmt++;
105D: 77 FA    INC   [X-6]
105F: 0F F9 00 ADC   [X-7],0
(0086) 				zeroflag = 1;
1062: 56 05 01 MOV   [X+5],1
1065: 56 04 00 MOV   [X+4],0
(0087) 			}
(0088) 			if ((*fmt >= '0') && (*fmt <= '9')){
1068: 62 D0 00 MOV   REG[208],0
106B: 52 FA    MOV   A,[X-6]
106D: 53 63    MOV   [__r1],A
106F: 52 F9    MOV   A,[X-7]
1071: 10       PUSH  X
1072: 58 63    MOV   X,[__r1]
1074: 28       ROMX  
1075: 20       POP   X
1076: 53 63    MOV   [__r1],A
1078: 55 64 00 MOV   [__r0],0
107B: 11 30    SUB   A,48
107D: 50 00    MOV   A,0
107F: 31 80    XOR   A,128
1081: 19 80    SBB   A,128
1083: C0 3C    JC    0x10C0
1085: 62 D0 00 MOV   REG[208],0
1088: 50 39    MOV   A,57
108A: 12 63    SUB   A,[__r1]
108C: 51 64    MOV   A,[__r0]
108E: 31 80    XOR   A,128
1090: 53 60    MOV   [__rX],A
1092: 50 80    MOV   A,128
1094: 1A 60    SBB   A,[__rX]
1096: C0 29    JC    0x10C0
(0089) 				width = *(fmt++) - '0';
1098: 62 D0 00 MOV   REG[208],0
109B: 52 FA    MOV   A,[X-6]
109D: 53 63    MOV   [__r1],A
109F: 52 F9    MOV   A,[X-7]
10A1: 53 64    MOV   [__r0],A
10A3: 51 63    MOV   A,[__r1]
10A5: 01 01    ADD   A,1
10A7: 54 FA    MOV   [X-6],A
10A9: 51 64    MOV   A,[__r0]
10AB: 09 00    ADC   A,0
10AD: 54 F9    MOV   [X-7],A
10AF: 51 64    MOV   A,[__r0]
10B1: 10       PUSH  X
10B2: 58 63    MOV   X,[__r1]
10B4: 28       ROMX  
10B5: 20       POP   X
10B6: 11 30    SUB   A,48
10B8: 54 07    MOV   [X+7],A
10BA: 50 00    MOV   A,0
10BC: 19 00    SBB   A,0
10BE: 54 06    MOV   [X+6],A
(0090) 			}
(0091) 
(0092) 			switch(*fmt){
10C0: 62 D0 00 MOV   REG[208],0
10C3: 52 FA    MOV   A,[X-6]
10C5: 53 63    MOV   [__r1],A
10C7: 52 F9    MOV   A,[X-7]
10C9: 10       PUSH  X
10CA: 58 63    MOV   X,[__r1]
10CC: 28       ROMX  
10CD: 20       POP   X
10CE: 54 0B    MOV   [X+11],A
10D0: 56 0A 00 MOV   [X+10],0
10D3: 3D 0A 00 CMP   [X+10],0
10D6: B0 06    JNZ   0x10DD
10D8: 3D 0B 63 CMP   [X+11],99
10DB: A1 79    JZ    0x1255
10DD: 52 0B    MOV   A,[X+11]
10DF: 11 64    SUB   A,100
10E1: 62 D0 00 MOV   REG[208],0
10E4: 53 5F    MOV   [__rY],A
10E6: 52 0A    MOV   A,[X+10]
10E8: 31 80    XOR   A,128
10EA: 19 80    SBB   A,128
10EC: 2A 5F    OR    A,[__rY]
10EE: A0 45    JZ    0x1134
10F0: D0 22    JNC   0x1113
10F2: 52 0B    MOV   A,[X+11]
10F4: 11 53    SUB   A,83
10F6: 62 D0 00 MOV   REG[208],0
10F9: 53 5F    MOV   [__rY],A
10FB: 52 0A    MOV   A,[X+10]
10FD: 31 80    XOR   A,128
10FF: 19 80    SBB   A,128
1101: C2 0D    JC    0x130F
1103: 2A 5F    OR    A,[__rY]
1105: A1 CB    JZ    0x12D1
1107: 3D 0A 00 CMP   [X+10],0
110A: B0 06    JNZ   0x1111
110C: 3D 0B 58 CMP   [X+11],88
110F: A0 EA    JZ    0x11FA
1111: 81 FD    JMP   0x130F
1113: 52 0B    MOV   A,[X+11]
1115: 11 73    SUB   A,115
1117: 62 D0 00 MOV   REG[208],0
111A: 53 5F    MOV   [__rY],A
111C: 52 0A    MOV   A,[X+10]
111E: 31 80    XOR   A,128
1120: 19 80    SBB   A,128
1122: C1 EC    JC    0x130F
1124: 2A 5F    OR    A,[__rY]
1126: A1 6C    JZ    0x1293
1128: 3D 0A 00 CMP   [X+10],0
112B: B0 06    JNZ   0x1132
112D: 3D 0B 78 CMP   [X+11],120
1130: A0 70    JZ    0x11A1
1132: 81 DC    JMP   0x130F
(0093) 			case 'd':		/* 16rbg 10i */
(0094) 				size = tsprintf_decimal(va_arg(arg,H),buff,zeroflag,width);
1134: 52 06    MOV   A,[X+6]
1136: 08       PUSH  A
1137: 52 07    MOV   A,[X+7]
1139: 08       PUSH  A
113A: 52 04    MOV   A,[X+4]
113C: 08       PUSH  A
113D: 52 05    MOV   A,[X+5]
113F: 08       PUSH  A
1140: 52 FB    MOV   A,[X-5]
1142: 08       PUSH  A
1143: 52 FC    MOV   A,[X-4]
1145: 08       PUSH  A
1146: 62 D0 00 MOV   REG[208],0
1149: 52 F8    MOV   A,[X-8]
114B: 01 FE    ADD   A,254
114D: 53 63    MOV   [__r1],A
114F: 52 F7    MOV   A,[X-9]
1151: 09 FF    ADC   A,255
1153: 53 64    MOV   [__r0],A
1155: 51 63    MOV   A,[__r1]
1157: 54 F8    MOV   [X-8],A
1159: 51 64    MOV   A,[__r0]
115B: 54 F7    MOV   [X-9],A
115D: 60 D4    MOV   REG[212],A
115F: 3E 63    MVI   A,[__r1]
1161: 53 64    MOV   [__r0],A
1163: 3E 63    MVI   A,[__r1]
1165: 53 61    MOV   [__r3],A
1167: 51 64    MOV   A,[__r0]
1169: 53 62    MOV   [__r2],A
116B: 47 62 80 TST   [__r2],128
116E: A0 09    JZ    0x1178
1170: 55 63 FF MOV   [__r1],255
1173: 55 64 FF MOV   [__r0],255
1176: 80 0A    JMP   0x1181
1178: 62 D0 00 MOV   REG[208],0
117B: 55 63 00 MOV   [__r1],0
117E: 55 64 00 MOV   [__r0],0
1181: 62 D0 00 MOV   REG[208],0
1184: 51 64    MOV   A,[__r0]
1186: 08       PUSH  A
1187: 51 63    MOV   A,[__r1]
1189: 08       PUSH  A
118A: 51 62    MOV   A,[__r2]
118C: 08       PUSH  A
118D: 51 61    MOV   A,[__r3]
118F: 08       PUSH  A
1190: 92 34    CALL  _tsprintf_decimal
1192: 38 F6    ADD   SP,246
1194: 62 D0 00 MOV   REG[208],0
1197: 51 63    MOV   A,[__r1]
1199: 54 01    MOV   [X+1],A
119B: 51 64    MOV   A,[__r0]
119D: 54 00    MOV   [X+0],A
(0095) 				break;
119F: 81 A0    JMP   0x1340
(0096) 			case 'x':		/* 16rbg 16i 0-f */
(0097) //				size = tsprintf_hexadecimal(va_arg(arg,unsigned long),buff,0,zeroflag,width);
(0098) 				size = tsprintf_hexadecimal(va_arg(arg,UH),buff,0,zeroflag,width);
11A1: 52 06    MOV   A,[X+6]
11A3: 08       PUSH  A
11A4: 52 07    MOV   A,[X+7]
11A6: 08       PUSH  A
11A7: 52 04    MOV   A,[X+4]
11A9: 08       PUSH  A
11AA: 52 05    MOV   A,[X+5]
11AC: 08       PUSH  A
11AD: 50 00    MOV   A,0
11AF: 08       PUSH  A
11B0: 08       PUSH  A
11B1: 52 FB    MOV   A,[X-5]
11B3: 08       PUSH  A
11B4: 52 FC    MOV   A,[X-4]
11B6: 08       PUSH  A
11B7: 62 D0 00 MOV   REG[208],0
11BA: 52 F8    MOV   A,[X-8]
11BC: 01 FE    ADD   A,254
11BE: 53 63    MOV   [__r1],A
11C0: 52 F7    MOV   A,[X-9]
11C2: 09 FF    ADC   A,255
11C4: 53 64    MOV   [__r0],A
11C6: 51 63    MOV   A,[__r1]
11C8: 54 F8    MOV   [X-8],A
11CA: 51 64    MOV   A,[__r0]
11CC: 54 F7    MOV   [X-9],A
11CE: 60 D4    MOV   REG[212],A
11D0: 3E 63    MVI   A,[__r1]
11D2: 53 64    MOV   [__r0],A
11D4: 3E 63    MVI   A,[__r1]
11D6: 16 63 02 SUB   [__r1],2
11D9: 53 61    MOV   [__r3],A
11DB: 51 64    MOV   A,[__r0]
11DD: 53 62    MOV   [__r2],A
11DF: 50 00    MOV   A,0
11E1: 08       PUSH  A
11E2: 08       PUSH  A
11E3: 51 62    MOV   A,[__r2]
11E5: 08       PUSH  A
11E6: 51 61    MOV   A,[__r3]
11E8: 08       PUSH  A
11E9: 94 5F    CALL  _tsprintf_hexadecimal
11EB: 38 F4    ADD   SP,244
11ED: 62 D0 00 MOV   REG[208],0
11F0: 51 63    MOV   A,[__r1]
11F2: 54 01    MOV   [X+1],A
11F4: 51 64    MOV   A,[__r0]
11F6: 54 00    MOV   [X+0],A
(0099) 				break;
11F8: 81 47    JMP   0x1340
(0100) 			case 'X':		/* 16rbg 16i 0-F */
(0101) //				size = tsprintf_hexadecimal(va_arg(arg,unsigned long),buff,1,zeroflag,width);
(0102) 				size = tsprintf_hexadecimal(va_arg(arg,UH),buff,1,zeroflag,width);
11FA: 52 06    MOV   A,[X+6]
11FC: 08       PUSH  A
11FD: 52 07    MOV   A,[X+7]
11FF: 08       PUSH  A
1200: 52 04    MOV   A,[X+4]
1202: 08       PUSH  A
1203: 52 05    MOV   A,[X+5]
1205: 08       PUSH  A
1206: 50 00    MOV   A,0
1208: 08       PUSH  A
1209: 50 01    MOV   A,1
120B: 08       PUSH  A
120C: 52 FB    MOV   A,[X-5]
120E: 08       PUSH  A
120F: 52 FC    MOV   A,[X-4]
1211: 08       PUSH  A
1212: 62 D0 00 MOV   REG[208],0
1215: 52 F8    MOV   A,[X-8]
1217: 01 FE    ADD   A,254
1219: 53 63    MOV   [__r1],A
121B: 52 F7    MOV   A,[X-9]
121D: 09 FF    ADC   A,255
121F: 53 64    MOV   [__r0],A
1221: 51 63    MOV   A,[__r1]
1223: 54 F8    MOV   [X-8],A
1225: 51 64    MOV   A,[__r0]
1227: 54 F7    MOV   [X-9],A
1229: 60 D4    MOV   REG[212],A
122B: 3E 63    MVI   A,[__r1]
122D: 53 64    MOV   [__r0],A
122F: 3E 63    MVI   A,[__r1]
1231: 16 63 02 SUB   [__r1],2
1234: 53 61    MOV   [__r3],A
1236: 51 64    MOV   A,[__r0]
1238: 53 62    MOV   [__r2],A
123A: 50 00    MOV   A,0
123C: 08       PUSH  A
123D: 08       PUSH  A
123E: 51 62    MOV   A,[__r2]
1240: 08       PUSH  A
1241: 51 61    MOV   A,[__r3]
1243: 08       PUSH  A
1244: 94 04    CALL  _tsprintf_hexadecimal
1246: 38 F4    ADD   SP,244
1248: 62 D0 00 MOV   REG[208],0
124B: 51 63    MOV   A,[__r1]
124D: 54 01    MOV   [X+1],A
124F: 51 64    MOV   A,[__r0]
1251: 54 00    MOV   [X+0],A
(0103) 				break;
1253: 80 EC    JMP   0x1340
(0104) 			case 'c':		/* LN^[ */
(0105) 				size = tsprintf_char(va_arg(arg,H),buff);
1255: 52 FB    MOV   A,[X-5]
1257: 08       PUSH  A
1258: 52 FC    MOV   A,[X-4]
125A: 08       PUSH  A
125B: 62 D0 00 MOV   REG[208],0
125E: 52 F8    MOV   A,[X-8]
1260: 01 FE    ADD   A,254
1262: 53 63    MOV   [__r1],A
1264: 52 F7    MOV   A,[X-9]
1266: 09 FF    ADC   A,255
1268: 53 64    MOV   [__r0],A
126A: 51 63    MOV   A,[__r1]
126C: 54 F8    MOV   [X-8],A
126E: 51 64    MOV   A,[__r0]
1270: 54 F7    MOV   [X-9],A
1272: 60 D4    MOV   REG[212],A
1274: 3E 63    MVI   A,[__r1]
1276: 53 64    MOV   [__r0],A
1278: 3E 63    MVI   A,[__r1]
127A: 53 63    MOV   [__r1],A
127C: 51 64    MOV   A,[__r0]
127E: 08       PUSH  A
127F: 51 63    MOV   A,[__r1]
1281: 08       PUSH  A
1282: 95 BD    CALL  _tsprintf_char
1284: 38 FC    ADD   SP,252
1286: 62 D0 00 MOV   REG[208],0
1289: 51 63    MOV   A,[__r1]
128B: 54 01    MOV   [X+1],A
128D: 51 64    MOV   A,[__r0]
128F: 54 00    MOV   [X+0],A
(0106) 				break;
1291: 80 AE    JMP   0x1340
(0107) 			case 's':		/* ASCIIZ */
(0108) 				size = tsprintf_string(va_arg(arg,char*),buff);
1293: 52 FB    MOV   A,[X-5]
1295: 08       PUSH  A
1296: 52 FC    MOV   A,[X-4]
1298: 08       PUSH  A
1299: 62 D0 00 MOV   REG[208],0
129C: 52 F8    MOV   A,[X-8]
129E: 01 FE    ADD   A,254
12A0: 53 63    MOV   [__r1],A
12A2: 52 F7    MOV   A,[X-9]
12A4: 09 FF    ADC   A,255
12A6: 53 64    MOV   [__r0],A
12A8: 51 63    MOV   A,[__r1]
12AA: 54 F8    MOV   [X-8],A
12AC: 51 64    MOV   A,[__r0]
12AE: 54 F7    MOV   [X-9],A
12B0: 60 D4    MOV   REG[212],A
12B2: 3E 63    MVI   A,[__r1]
12B4: 53 64    MOV   [__r0],A
12B6: 3E 63    MVI   A,[__r1]
12B8: 53 63    MOV   [__r1],A
12BA: 51 64    MOV   A,[__r0]
12BC: 08       PUSH  A
12BD: 51 63    MOV   A,[__r1]
12BF: 08       PUSH  A
12C0: 95 9C    CALL  _tsprintf_string
12C2: 38 FC    ADD   SP,252
12C4: 62 D0 00 MOV   REG[208],0
12C7: 51 63    MOV   A,[__r1]
12C9: 54 01    MOV   [X+1],A
12CB: 51 64    MOV   A,[__r0]
12CD: 54 00    MOV   [X+0],A
(0109) 				break;
12CF: 80 70    JMP   0x1340
(0110) 			case 'S':		/* const ASCIIZ */
(0111) 				size = tsprintf_cstring(va_arg(arg,const char*),buff);
12D1: 52 FB    MOV   A,[X-5]
12D3: 08       PUSH  A
12D4: 52 FC    MOV   A,[X-4]
12D6: 08       PUSH  A
12D7: 62 D0 00 MOV   REG[208],0
12DA: 52 F8    MOV   A,[X-8]
12DC: 01 FE    ADD   A,254
12DE: 53 63    MOV   [__r1],A
12E0: 52 F7    MOV   A,[X-9]
12E2: 09 FF    ADC   A,255
12E4: 53 64    MOV   [__r0],A
12E6: 51 63    MOV   A,[__r1]
12E8: 54 F8    MOV   [X-8],A
12EA: 51 64    MOV   A,[__r0]
12EC: 54 F7    MOV   [X-9],A
12EE: 60 D4    MOV   REG[212],A
12F0: 3E 63    MVI   A,[__r1]
12F2: 53 64    MOV   [__r0],A
12F4: 3E 63    MVI   A,[__r1]
12F6: 53 63    MOV   [__r1],A
12F8: 51 64    MOV   A,[__r0]
12FA: 08       PUSH  A
12FB: 51 63    MOV   A,[__r1]
12FD: 08       PUSH  A
12FE: 95 BC    CALL  _tsprintf_cstring
1300: 38 FC    ADD   SP,252
1302: 62 D0 00 MOV   REG[208],0
1305: 51 63    MOV   A,[__r1]
1307: 54 01    MOV   [X+1],A
1309: 51 64    MOV   A,[__r0]
130B: 54 00    MOV   [X+0],A
(0112) 				break;
130D: 80 32    JMP   0x1340
(0113) 			default:		/* Rg[R[hO */
(0114) 				/* %%(%) */
(0115) 				len++;
130F: 77 03    INC   [X+3]
1311: 0F 02 00 ADC   [X+2],0
(0116) 				*(buff++) = *fmt;
1314: 62 D0 00 MOV   REG[208],0
1317: 52 FC    MOV   A,[X-4]
1319: 53 63    MOV   [__r1],A
131B: 52 FB    MOV   A,[X-5]
131D: 53 64    MOV   [__r0],A
131F: 51 63    MOV   A,[__r1]
1321: 01 01    ADD   A,1
1323: 54 FC    MOV   [X-4],A
1325: 51 64    MOV   A,[__r0]
1327: 09 00    ADC   A,0
1329: 54 FB    MOV   [X-5],A
132B: 52 FA    MOV   A,[X-6]
132D: 53 61    MOV   [__r3],A
132F: 52 F9    MOV   A,[X-7]
1331: 10       PUSH  X
1332: 58 61    MOV   X,[__r3]
1334: 28       ROMX  
1335: 20       POP   X
1336: 53 62    MOV   [__r2],A
1338: 51 64    MOV   A,[__r0]
133A: 60 D5    MOV   REG[213],A
133C: 51 62    MOV   A,[__r2]
133E: 3F 63    MVI   [__r1],A
(0117) 				break;
(0118) 			}
(0119) 			len += size;
1340: 52 01    MOV   A,[X+1]
1342: 05 03    ADD   [X+3],A
1344: 52 00    MOV   A,[X+0]
1346: 0D 02    ADC   [X+2],A
(0120) 			buff += size;
1348: 52 01    MOV   A,[X+1]
134A: 03 FC    ADD   A,[X-4]
134C: 54 FC    MOV   [X-4],A
134E: 52 00    MOV   A,[X+0]
1350: 0B FB    ADC   A,[X-5]
1352: 54 FB    MOV   [X-5],A
(0121) 			fmt++;
1354: 77 FA    INC   [X-6]
1356: 0F F9 00 ADC   [X-7],0
(0122) 		} else {
1359: 80 42    JMP   0x139C
(0123) 			*(buff++) = *(fmt++);
135B: 62 D0 00 MOV   REG[208],0
135E: 52 FC    MOV   A,[X-4]
1360: 53 63    MOV   [__r1],A
1362: 52 FB    MOV   A,[X-5]
1364: 53 64    MOV   [__r0],A
1366: 51 63    MOV   A,[__r1]
1368: 01 01    ADD   A,1
136A: 54 FC    MOV   [X-4],A
136C: 51 64    MOV   A,[__r0]
136E: 09 00    ADC   A,0
1370: 54 FB    MOV   [X-5],A
1372: 52 FA    MOV   A,[X-6]
1374: 53 61    MOV   [__r3],A
1376: 52 F9    MOV   A,[X-7]
1378: 53 62    MOV   [__r2],A
137A: 51 61    MOV   A,[__r3]
137C: 01 01    ADD   A,1
137E: 54 FA    MOV   [X-6],A
1380: 51 62    MOV   A,[__r2]
1382: 09 00    ADC   A,0
1384: 54 F9    MOV   [X-7],A
1386: 51 62    MOV   A,[__r2]
1388: 10       PUSH  X
1389: 58 61    MOV   X,[__r3]
138B: 28       ROMX  
138C: 20       POP   X
138D: 53 62    MOV   [__r2],A
138F: 51 64    MOV   A,[__r0]
1391: 60 D5    MOV   REG[213],A
1393: 51 62    MOV   A,[__r2]
1395: 3F 63    MVI   [__r1],A
(0124) 			len++;
1397: 77 03    INC   [X+3]
1399: 0F 02 00 ADC   [X+2],0
139C: 62 D0 00 MOV   REG[208],0
139F: 52 FA    MOV   A,[X-6]
13A1: 53 63    MOV   [__r1],A
13A3: 52 F9    MOV   A,[X-7]
13A5: 10       PUSH  X
13A6: 58 63    MOV   X,[__r1]
13A8: 28       ROMX  
13A9: 20       POP   X
13AA: 39 00    CMP   A,0
13AC: BC 7E    JNZ   0x102B
(0125) 		}
(0126) 	}
(0127) 
(0128) 	*buff = '\0';		/* I[ */
13AE: 52 FC    MOV   A,[X-4]
13B0: 53 63    MOV   [__r1],A
13B2: 52 FB    MOV   A,[X-5]
13B4: 60 D5    MOV   REG[213],A
13B6: 50 00    MOV   A,0
13B8: 3F 63    MVI   [__r1],A
(0129) 
(0130) 	va_end(arg);
(0131) 	return (len);
13BA: 52 03    MOV   A,[X+3]
13BC: 53 63    MOV   [__r1],A
13BE: 52 02    MOV   A,[X+2]
13C0: 53 64    MOV   [__r0],A
13C2: 38 F4    ADD   SP,244
13C4: 20       POP   X
13C5: 7F       RET   
(0132) }
(0133) 
(0134) /** l => 10i
(0135)  * @param val f[^
(0136)  * @param buff f[^i[obt@|C^
(0137)  * @param zf 1:f[^0
(0138)  * @param wd w(0`9)
(0139)  * @return 
(0140)  */
(0141) static int tsprintf_decimal(signed long val,char* buff,int zf,int wd){
_tsprintf_decimal:
  tmp                  --> X+8
  minus                --> X+6
  i                    --> X+4
  ptmp                 --> X+2
  len                  --> X+0
  wd                   --> X-13
  zf                   --> X-11
  buff                 --> X-9
  val                  --> X-7
13C6: 10       PUSH  X
13C7: 4F       MOV   X,SP
13C8: 38 12    ADD   SP,18
(0142) 	int i;
(0143) 	char tmp[10];
(0144) 	char* ptmp = tmp + 9;
13CA: 62 D0 00 MOV   REG[208],0
13CD: 5A 63    MOV   [__r1],X
13CF: 06 63 11 ADD   [__r1],17
13D2: 51 63    MOV   A,[__r1]
13D4: 54 03    MOV   [X+3],A
13D6: 56 02 03 MOV   [X+2],3
(0145) 	int len = 0;
13D9: 56 01 00 MOV   [X+1],0
13DC: 56 00 00 MOV   [X+0],0
(0146) 	int minus = 0;
13DF: 56 07 00 MOV   [X+7],0
13E2: 56 06 00 MOV   [X+6],0
(0147) 				
(0148) 	if (!val){		/* wl0 */
13E5: 3D F9 00 CMP   [X-7],0
13E8: B0 36    JNZ   0x141F
13EA: 3D FA 00 CMP   [X-6],0
13ED: B0 31    JNZ   0x141F
13EF: 3D FB 00 CMP   [X-5],0
13F2: B0 2C    JNZ   0x141F
13F4: 3D FC 00 CMP   [X-4],0
13F7: B0 27    JNZ   0x141F
(0149) 		*(ptmp--) = '0';
13F9: 62 D0 00 MOV   REG[208],0
13FC: 52 03    MOV   A,[X+3]
13FE: 53 63    MOV   [__r1],A
1400: 52 02    MOV   A,[X+2]
1402: 53 64    MOV   [__r0],A
1404: 51 63    MOV   A,[__r1]
1406: 01 FF    ADD   A,255
1408: 54 03    MOV   [X+3],A
140A: 51 64    MOV   A,[__r0]
140C: 09 FF    ADC   A,255
140E: 54 02    MOV   [X+2],A
1410: 51 64    MOV   A,[__r0]
1412: 60 D5    MOV   REG[213],A
1414: 50 30    MOV   A,48
1416: 3F 63    MVI   [__r1],A
(0150) 		len++;
1418: 77 01    INC   [X+1]
141A: 0F 00 00 ADC   [X+0],0
(0151) 	} else {
141D: 80 D3    JMP   0x14F1
(0152) 		/* }CiXl2 */
(0153) 		if (val < 0){
141F: 52 FC    MOV   A,[X-4]
1421: 11 00    SUB   A,0
1423: 52 FB    MOV   A,[X-5]
1425: 19 00    SBB   A,0
1427: 52 FA    MOV   A,[X-6]
1429: 19 00    SBB   A,0
142B: 52 F9    MOV   A,[X-7]
142D: 31 80    XOR   A,128
142F: 19 80    SBB   A,128
1431: D0 AB    JNC   0x14DD
(0154) 			val = ~val;
1433: 52 F9    MOV   A,[X-7]
1435: 73       CPL   A
1436: 54 F9    MOV   [X-7],A
1438: 52 FA    MOV   A,[X-6]
143A: 73       CPL   A
143B: 54 FA    MOV   [X-6],A
143D: 52 FB    MOV   A,[X-5]
143F: 73       CPL   A
1440: 54 FB    MOV   [X-5],A
1442: 52 FC    MOV   A,[X-4]
1444: 73       CPL   A
1445: 54 FC    MOV   [X-4],A
(0155) 			val++;
1447: 07 FC 01 ADD   [X-4],1
144A: 0F FB 00 ADC   [X-5],0
144D: 0F FA 00 ADC   [X-6],0
1450: 0F F9 00 ADC   [X-7],0
(0156) 			minus = 1;
1453: 56 07 01 MOV   [X+7],1
1456: 56 06 00 MOV   [X+6],0
(0157) 		}
1459: 80 83    JMP   0x14DD
(0158) 		while (val){
(0159) 
(0160) 			/* obt@A_[t[ */
(0161) 			if (len >= 8){
145B: 52 01    MOV   A,[X+1]
145D: 11 08    SUB   A,8
145F: 52 00    MOV   A,[X+0]
1461: 31 80    XOR   A,128
1463: 19 80    SBB   A,128
1465: C0 03    JC    0x1469
(0162) 				break;
1467: 80 89    JMP   0x14F1
(0163) 			}
(0164) 	
(0165) 			*ptmp = (val % 10) + '0';
1469: 62 D0 00 MOV   REG[208],0
146C: 50 00    MOV   A,0
146E: 08       PUSH  A
146F: 08       PUSH  A
1470: 08       PUSH  A
1471: 50 0A    MOV   A,10
1473: 08       PUSH  A
1474: 52 F9    MOV   A,[X-7]
1476: 08       PUSH  A
1477: 52 FA    MOV   A,[X-6]
1479: 08       PUSH  A
147A: 52 FB    MOV   A,[X-5]
147C: 08       PUSH  A
147D: 52 FC    MOV   A,[X-4]
147F: 08       PUSH  A
1480: 7C 1C B0 LCALL __divmod_32X32_32
1483: 38 FC    ADD   SP,252
1485: 18       POP   A
1486: 53 61    MOV   [__r3],A
1488: 18       POP   A
1489: 53 62    MOV   [__r2],A
148B: 18       POP   A
148C: 53 63    MOV   [__r1],A
148E: 18       POP   A
148F: 53 64    MOV   [__r0],A
1491: 06 61 30 ADD   [__r3],48
1494: 0E 62 00 ADC   [__r2],0
1497: 0E 63 00 ADC   [__r1],0
149A: 0E 64 00 ADC   [__r0],0
149D: 51 61    MOV   A,[__r3]
149F: 53 64    MOV   [__r0],A
14A1: 52 03    MOV   A,[X+3]
14A3: 53 61    MOV   [__r3],A
14A5: 52 02    MOV   A,[X+2]
14A7: 60 D5    MOV   REG[213],A
14A9: 51 64    MOV   A,[__r0]
14AB: 3F 61    MVI   [__r3],A
(0166) 
(0167) 			val /= 10;
14AD: 50 00    MOV   A,0
14AF: 08       PUSH  A
14B0: 08       PUSH  A
14B1: 08       PUSH  A
14B2: 50 0A    MOV   A,10
14B4: 08       PUSH  A
14B5: 52 F9    MOV   A,[X-7]
14B7: 08       PUSH  A
14B8: 52 FA    MOV   A,[X-6]
14BA: 08       PUSH  A
14BB: 52 FB    MOV   A,[X-5]
14BD: 08       PUSH  A
14BE: 52 FC    MOV   A,[X-4]
14C0: 08       PUSH  A
14C1: 7C 1C B0 LCALL __divmod_32X32_32
14C4: 18       POP   A
14C5: 54 FC    MOV   [X-4],A
14C7: 18       POP   A
14C8: 54 FB    MOV   [X-5],A
14CA: 18       POP   A
14CB: 54 FA    MOV   [X-6],A
14CD: 18       POP   A
14CE: 54 F9    MOV   [X-7],A
14D0: 38 FC    ADD   SP,252
(0168) 			ptmp--;
14D2: 07 03 FF ADD   [X+3],255
14D5: 0F 02 FF ADC   [X+2],255
(0169) 			len++;
14D8: 77 01    INC   [X+1]
14DA: 0F 00 00 ADC   [X+0],0
14DD: 3D F9 00 CMP   [X-7],0
14E0: BF 7A    JNZ   0x145B
14E2: 3D FA 00 CMP   [X-6],0
14E5: BF 75    JNZ   0x145B
14E7: 3D FB 00 CMP   [X-5],0
14EA: BF 70    JNZ   0x145B
14EC: 3D FC 00 CMP   [X-4],0
14EF: BF 6B    JNZ   0x145B
(0170) 		}
(0171) 
(0172) 	}
(0173) 
(0174) 	/* A */
(0175) 	if (zf){
14F1: 3D F5 00 CMP   [X-11],0
14F4: B0 06    JNZ   0x14FB
14F6: 3D F6 00 CMP   [X-10],0
14F9: A0 7B    JZ    0x1575
(0176) 		if (minus){
14FB: 3D 06 00 CMP   [X+6],0
14FE: B0 06    JNZ   0x1505
1500: 3D 07 00 CMP   [X+7],0
1503: A0 2C    JZ    0x1530
(0177) 			wd--;
1505: 7B F4    DEC   [X-12]
1507: 1F F3 00 SBB   [X-13],0
(0178) 		}
150A: 80 25    JMP   0x1530
(0179) 		while (len < wd){
(0180) 			*(ptmp--) =  '0';
150C: 62 D0 00 MOV   REG[208],0
150F: 52 03    MOV   A,[X+3]
1511: 53 63    MOV   [__r1],A
1513: 52 02    MOV   A,[X+2]
1515: 53 64    MOV   [__r0],A
1517: 51 63    MOV   A,[__r1]
1519: 01 FF    ADD   A,255
151B: 54 03    MOV   [X+3],A
151D: 51 64    MOV   A,[__r0]
151F: 09 FF    ADC   A,255
1521: 54 02    MOV   [X+2],A
1523: 51 64    MOV   A,[__r0]
1525: 60 D5    MOV   REG[213],A
1527: 50 30    MOV   A,48
1529: 3F 63    MVI   [__r1],A
(0181) 			len++;
152B: 77 01    INC   [X+1]
152D: 0F 00 00 ADC   [X+0],0
1530: 52 01    MOV   A,[X+1]
1532: 13 F4    SUB   A,[X-12]
1534: 52 F3    MOV   A,[X-13]
1536: 31 80    XOR   A,128
1538: 62 D0 00 MOV   REG[208],0
153B: 53 60    MOV   [__rX],A
153D: 52 00    MOV   A,[X+0]
153F: 31 80    XOR   A,128
1541: 1A 60    SBB   A,[__rX]
1543: CF C8    JC    0x150C
(0182) 		}
(0183) 		if (minus){
1545: 3D 06 00 CMP   [X+6],0
1548: B0 06    JNZ   0x154F
154A: 3D 07 00 CMP   [X+7],0
154D: A0 90    JZ    0x15DE
(0184) 			*(ptmp--) = '-';
154F: 62 D0 00 MOV   REG[208],0
1552: 52 03    MOV   A,[X+3]
1554: 53 63    MOV   [__r1],A
1556: 52 02    MOV   A,[X+2]
1558: 53 64    MOV   [__r0],A
155A: 51 63    MOV   A,[__r1]
155C: 01 FF    ADD   A,255
155E: 54 03    MOV   [X+3],A
1560: 51 64    MOV   A,[__r0]
1562: 09 FF    ADC   A,255
1564: 54 02    MOV   [X+2],A
1566: 51 64    MOV   A,[__r0]
1568: 60 D5    MOV   REG[213],A
156A: 50 2D    MOV   A,45
156C: 3F 63    MVI   [__r1],A
(0185) 			len++;
156E: 77 01    INC   [X+1]
1570: 0F 00 00 ADC   [X+0],0
(0186) 		}
(0187) 	} else {
1573: 80 6A    JMP   0x15DE
(0188) 		if (minus){
1575: 3D 06 00 CMP   [X+6],0
1578: B0 06    JNZ   0x157F
157A: 3D 07 00 CMP   [X+7],0
157D: A0 4B    JZ    0x15C9
(0189) 			*(ptmp--) = '-';
157F: 62 D0 00 MOV   REG[208],0
1582: 52 03    MOV   A,[X+3]
1584: 53 63    MOV   [__r1],A
1586: 52 02    MOV   A,[X+2]
1588: 53 64    MOV   [__r0],A
158A: 51 63    MOV   A,[__r1]
158C: 01 FF    ADD   A,255
158E: 54 03    MOV   [X+3],A
1590: 51 64    MOV   A,[__r0]
1592: 09 FF    ADC   A,255
1594: 54 02    MOV   [X+2],A
1596: 51 64    MOV   A,[__r0]
1598: 60 D5    MOV   REG[213],A
159A: 50 2D    MOV   A,45
159C: 3F 63    MVI   [__r1],A
(0190) 			len++;
159E: 77 01    INC   [X+1]
15A0: 0F 00 00 ADC   [X+0],0
(0191) 		}
15A3: 80 25    JMP   0x15C9
(0192) 		while (len < wd){
(0193) 			*(ptmp--) =  ' ';
15A5: 62 D0 00 MOV   REG[208],0
15A8: 52 03    MOV   A,[X+3]
15AA: 53 63    MOV   [__r1],A
15AC: 52 02    MOV   A,[X+2]
15AE: 53 64    MOV   [__r0],A
15B0: 51 63    MOV   A,[__r1]
15B2: 01 FF    ADD   A,255
15B4: 54 03    MOV   [X+3],A
15B6: 51 64    MOV   A,[__r0]
15B8: 09 FF    ADC   A,255
15BA: 54 02    MOV   [X+2],A
15BC: 51 64    MOV   A,[__r0]
15BE: 60 D5    MOV   REG[213],A
15C0: 50 20    MOV   A,32
15C2: 3F 63    MVI   [__r1],A
(0194) 			len++;
15C4: 77 01    INC   [X+1]
15C6: 0F 00 00 ADC   [X+0],0
15C9: 52 01    MOV   A,[X+1]
15CB: 13 F4    SUB   A,[X-12]
15CD: 52 F3    MOV   A,[X-13]
15CF: 31 80    XOR   A,128
15D1: 62 D0 00 MOV   REG[208],0
15D4: 53 60    MOV   [__rX],A
15D6: 52 00    MOV   A,[X+0]
15D8: 31 80    XOR   A,128
15DA: 1A 60    SBB   A,[__rX]
15DC: CF C8    JC    0x15A5
(0195) 		}
(0196) 	}
(0197) 
(0198) 	/* obt@Rs[ */
(0199) 	for (i=0;i<len;i++){
15DE: 56 05 00 MOV   [X+5],0
15E1: 56 04 00 MOV   [X+4],0
15E4: 80 41    JMP   0x1626
(0200) 		*(buff++) = *(++ptmp);
15E6: 62 D0 00 MOV   REG[208],0
15E9: 52 F8    MOV   A,[X-8]
15EB: 53 63    MOV   [__r1],A
15ED: 52 F7    MOV   A,[X-9]
15EF: 53 64    MOV   [__r0],A
15F1: 51 63    MOV   A,[__r1]
15F3: 01 01    ADD   A,1
15F5: 54 F8    MOV   [X-8],A
15F7: 51 64    MOV   A,[__r0]
15F9: 09 00    ADC   A,0
15FB: 54 F7    MOV   [X-9],A
15FD: 52 03    MOV   A,[X+3]
15FF: 01 01    ADD   A,1
1601: 53 61    MOV   [__r3],A
1603: 52 02    MOV   A,[X+2]
1605: 09 00    ADC   A,0
1607: 53 62    MOV   [__r2],A
1609: 51 61    MOV   A,[__r3]
160B: 54 03    MOV   [X+3],A
160D: 51 62    MOV   A,[__r2]
160F: 54 02    MOV   [X+2],A
1611: 60 D4    MOV   REG[212],A
1613: 3E 61    MVI   A,[__r3]
1615: 7A 61    DEC   [__r3]
1617: 53 62    MOV   [__r2],A
1619: 51 64    MOV   A,[__r0]
161B: 60 D5    MOV   REG[213],A
161D: 51 62    MOV   A,[__r2]
161F: 3F 63    MVI   [__r1],A
1621: 77 05    INC   [X+5]
1623: 0F 04 00 ADC   [X+4],0
1626: 52 05    MOV   A,[X+5]
1628: 13 01    SUB   A,[X+1]
162A: 52 00    MOV   A,[X+0]
162C: 31 80    XOR   A,128
162E: 62 D0 00 MOV   REG[208],0
1631: 53 60    MOV   [__rX],A
1633: 52 04    MOV   A,[X+4]
1635: 31 80    XOR   A,128
1637: 1A 60    SBB   A,[__rX]
1639: CF AC    JC    0x15E6
(0201) 	}
(0202) 
(0203) 	return (len);
163B: 62 D0 00 MOV   REG[208],0
163E: 52 01    MOV   A,[X+1]
1640: 53 63    MOV   [__r1],A
1642: 52 00    MOV   A,[X+0]
1644: 53 64    MOV   [__r0],A
1646: 38 EE    ADD   SP,238
1648: 20       POP   X
1649: 7F       RET   
(0204) }
(0205) 
(0206) /** l => 16i
(0207)  * @param val f[^
(0208)  * @param buff f[^i[obt@|C^
(0209)  * @param capital 1 : 16ia`f'A'`'F'
(0210)  * @param zf 1:f[^0
(0211)  * @param wd w(0`9)
(0212)  * @return 
(0213)  */
(0214) static int tsprintf_hexadecimal(unsigned long val,char* buff,
(0215) 								int capital,int zf,int wd){
_tsprintf_hexadecimal:
  tmp                  --> X+7
  str_a                --> X+6
  i                    --> X+4
  ptmp                 --> X+2
  len                  --> X+0
  wd                   --> X-15
  zf                   --> X-13
  capital              --> X-11
  buff                 --> X-9
  val                  --> X-7
164A: 10       PUSH  X
164B: 4F       MOV   X,SP
164C: 38 13    ADD   SP,19
(0216) 	int i;
(0217) 	char tmp[10];
(0218) 	char* ptmp = tmp + 9;
164E: 62 D0 00 MOV   REG[208],0
1651: 5A 63    MOV   [__r1],X
1653: 06 63 10 ADD   [__r1],16
1656: 51 63    MOV   A,[__r1]
1658: 54 03    MOV   [X+3],A
165A: 56 02 03 MOV   [X+2],3
(0219) 	int len = 0;
165D: 56 01 00 MOV   [X+1],0
1660: 56 00 00 MOV   [X+0],0
(0220) 	char str_a;
(0221) 
(0222) 	/* A`F */
(0223) 	if (capital){
1663: 3D F5 00 CMP   [X-11],0
1666: B0 06    JNZ   0x166D
1668: 3D F6 00 CMP   [X-10],0
166B: A0 06    JZ    0x1672
(0224) 		str_a = 'A';
166D: 56 06 41 MOV   [X+6],65
(0225) 	} else {
1670: 80 04    JMP   0x1675
(0226) 		str_a = 'a';
1672: 56 06 61 MOV   [X+6],97
(0227) 	}
(0228) 	
(0229) 	if (!val){		/* wl0 */
1675: 3D F9 00 CMP   [X-7],0
1678: B0 EE    JNZ   0x1767
167A: 3D FA 00 CMP   [X-6],0
167D: B0 E9    JNZ   0x1767
167F: 3D FB 00 CMP   [X-5],0
1682: B0 E4    JNZ   0x1767
1684: 3D FC 00 CMP   [X-4],0
1687: B0 DF    JNZ   0x1767
(0230) 		*(ptmp--) = '0';
1689: 62 D0 00 MOV   REG[208],0
168C: 52 03    MOV   A,[X+3]
168E: 53 63    MOV   [__r1],A
1690: 52 02    MOV   A,[X+2]
1692: 53 64    MOV   [__r0],A
1694: 51 63    MOV   A,[__r1]
1696: 01 FF    ADD   A,255
1698: 54 03    MOV   [X+3],A
169A: 51 64    MOV   A,[__r0]
169C: 09 FF    ADC   A,255
169E: 54 02    MOV   [X+2],A
16A0: 51 64    MOV   A,[__r0]
16A2: 60 D5    MOV   REG[213],A
16A4: 50 30    MOV   A,48
16A6: 3F 63    MVI   [__r1],A
(0231) 		len++;
16A8: 77 01    INC   [X+1]
16AA: 0F 00 00 ADC   [X+0],0
(0232) 	} else {
16AD: 81 12    JMP   0x17C0
(0233) 		while (val){
(0234) 			/* obt@A_[t[ */
(0235) 			if (len >= 8){
16AF: 52 01    MOV   A,[X+1]
16B1: 11 08    SUB   A,8
16B3: 52 00    MOV   A,[X+0]
16B5: 31 80    XOR   A,128
16B7: 19 80    SBB   A,128
16B9: C0 03    JC    0x16BD
(0236) 				break;
16BB: 81 04    JMP   0x17C0
(0237) 			}
(0238) 
(0239) 			*ptmp = (val % 16);
16BD: 62 D0 00 MOV   REG[208],0
16C0: 52 FC    MOV   A,[X-4]
16C2: 21 0F    AND   A,15
16C4: 53 64    MOV   [__r0],A
16C6: 52 03    MOV   A,[X+3]
16C8: 53 61    MOV   [__r3],A
16CA: 52 02    MOV   A,[X+2]
16CC: 60 D5    MOV   REG[213],A
16CE: 51 64    MOV   A,[__r0]
16D0: 3F 61    MVI   [__r3],A
(0240) 			if (*ptmp > 9){
16D2: 52 03    MOV   A,[X+3]
16D4: 53 63    MOV   [__r1],A
16D6: 52 02    MOV   A,[X+2]
16D8: 60 D4    MOV   REG[212],A
16DA: 3E 63    MVI   A,[__r1]
16DC: 53 64    MOV   [__r0],A
16DE: 50 09    MOV   A,9
16E0: 3A 64    CMP   A,[__r0]
16E2: D0 26    JNC   0x1709
(0241) 				*ptmp += str_a - 10;
16E4: 62 D0 00 MOV   REG[208],0
16E7: 52 06    MOV   A,[X+6]
16E9: 11 0A    SUB   A,10
16EB: 53 64    MOV   [__r0],A
16ED: 52 03    MOV   A,[X+3]
16EF: 53 61    MOV   [__r3],A
16F1: 52 02    MOV   A,[X+2]
16F3: 60 D4    MOV   REG[212],A
16F5: 3E 61    MVI   A,[__r3]
16F7: 02 64    ADD   A,[__r0]
16F9: 53 64    MOV   [__r0],A
16FB: 52 03    MOV   A,[X+3]
16FD: 53 61    MOV   [__r3],A
16FF: 52 02    MOV   A,[X+2]
1701: 60 D5    MOV   REG[213],A
1703: 51 64    MOV   A,[__r0]
1705: 3F 61    MVI   [__r3],A
(0242) 			} else {
1707: 80 1F    JMP   0x1727
(0243) 				*ptmp += '0';
1709: 62 D0 00 MOV   REG[208],0
170C: 52 03    MOV   A,[X+3]
170E: 53 63    MOV   [__r1],A
1710: 52 02    MOV   A,[X+2]
1712: 60 D4    MOV   REG[212],A
1714: 3E 63    MVI   A,[__r1]
1716: 53 64    MOV   [__r0],A
1718: 06 64 30 ADD   [__r0],48
171B: 52 03    MOV   A,[X+3]
171D: 53 61    MOV   [__r3],A
171F: 52 02    MOV   A,[X+2]
1721: 60 D5    MOV   REG[213],A
1723: 51 64    MOV   A,[__r0]
1725: 3F 61    MVI   [__r3],A
(0244) 			}
(0245) 		
(0246) 			val >>= 4;		/* 16 */
1727: 62 D0 00 MOV   REG[208],0
172A: 52 F9    MOV   A,[X-7]
172C: 53 64    MOV   [__r0],A
172E: 52 FA    MOV   A,[X-6]
1730: 53 63    MOV   [__r1],A
1732: 52 FB    MOV   A,[X-5]
1734: 53 62    MOV   [__r2],A
1736: 52 FC    MOV   A,[X-4]
1738: 53 61    MOV   [__r3],A
173A: 50 04    MOV   A,4
173C: 70 FB    AND   F,251
173E: 62 D0 00 MOV   REG[208],0
1741: 6E 64    RRC   [__r0]
1743: 6E 63    RRC   [__r1]
1745: 6E 62    RRC   [__r2]
1747: 6E 61    RRC   [__r3]
1749: 78       DEC   A
174A: BF F1    JNZ   0x173C
174C: 51 64    MOV   A,[__r0]
174E: 54 F9    MOV   [X-7],A
1750: 51 63    MOV   A,[__r1]
1752: 54 FA    MOV   [X-6],A
1754: 51 62    MOV   A,[__r2]
1756: 54 FB    MOV   [X-5],A
1758: 51 61    MOV   A,[__r3]
175A: 54 FC    MOV   [X-4],A
(0247) 			ptmp--;
175C: 07 03 FF ADD   [X+3],255
175F: 0F 02 FF ADC   [X+2],255
(0248) 			len++;
1762: 77 01    INC   [X+1]
1764: 0F 00 00 ADC   [X+0],0
1767: 3D F9 00 CMP   [X-7],0
176A: BF 44    JNZ   0x16AF
176C: 3D FA 00 CMP   [X-6],0
176F: BF 3F    JNZ   0x16AF
1771: 3D FB 00 CMP   [X-5],0
1774: BF 3A    JNZ   0x16AF
1776: 3D FC 00 CMP   [X-4],0
1779: BF 35    JNZ   0x16AF
(0249) 		}
(0250) 	}
177B: 80 44    JMP   0x17C0
(0251) 	while (len < wd){
(0252) 		*(ptmp--) =  zf ? '0' : ' ';
177D: 62 D0 00 MOV   REG[208],0
1780: 52 03    MOV   A,[X+3]
1782: 53 63    MOV   [__r1],A
1784: 52 02    MOV   A,[X+2]
1786: 53 64    MOV   [__r0],A
1788: 51 63    MOV   A,[__r1]
178A: 01 FF    ADD   A,255
178C: 54 03    MOV   [X+3],A
178E: 51 64    MOV   A,[__r0]
1790: 09 FF    ADC   A,255
1792: 54 02    MOV   [X+2],A
1794: 3D F3 00 CMP   [X-13],0
1797: B0 06    JNZ   0x179E
1799: 3D F4 00 CMP   [X-12],0
179C: A0 09    JZ    0x17A6
179E: 56 12 30 MOV   [X+18],48
17A1: 56 11 00 MOV   [X+17],0
17A4: 80 07    JMP   0x17AC
17A6: 56 12 20 MOV   [X+18],32
17A9: 56 11 00 MOV   [X+17],0
17AC: 62 D0 00 MOV   REG[208],0
17AF: 52 12    MOV   A,[X+18]
17B1: 53 62    MOV   [__r2],A
17B3: 51 64    MOV   A,[__r0]
17B5: 60 D5    MOV   REG[213],A
17B7: 51 62    MOV   A,[__r2]
17B9: 3F 63    MVI   [__r1],A
(0253) 		len++;
17BB: 77 01    INC   [X+1]
17BD: 0F 00 00 ADC   [X+0],0
17C0: 52 01    MOV   A,[X+1]
17C2: 13 F2    SUB   A,[X-14]
17C4: 52 F1    MOV   A,[X-15]
17C6: 31 80    XOR   A,128
17C8: 62 D0 00 MOV   REG[208],0
17CB: 53 60    MOV   [__rX],A
17CD: 52 00    MOV   A,[X+0]
17CF: 31 80    XOR   A,128
17D1: 1A 60    SBB   A,[__rX]
17D3: CF A9    JC    0x177D
(0254) 	}
(0255) 		
(0256) 	for (i=0;i<len;i++){
17D5: 56 05 00 MOV   [X+5],0
17D8: 56 04 00 MOV   [X+4],0
17DB: 80 41    JMP   0x181D
(0257) 		*(buff++) = *(++ptmp);
17DD: 62 D0 00 MOV   REG[208],0
17E0: 52 F8    MOV   A,[X-8]
17E2: 53 63    MOV   [__r1],A
17E4: 52 F7    MOV   A,[X-9]
17E6: 53 64    MOV   [__r0],A
17E8: 51 63    MOV   A,[__r1]
17EA: 01 01    ADD   A,1
17EC: 54 F8    MOV   [X-8],A
17EE: 51 64    MOV   A,[__r0]
17F0: 09 00    ADC   A,0
17F2: 54 F7    MOV   [X-9],A
17F4: 52 03    MOV   A,[X+3]
17F6: 01 01    ADD   A,1
17F8: 53 61    MOV   [__r3],A
17FA: 52 02    MOV   A,[X+2]
17FC: 09 00    ADC   A,0
17FE: 53 62    MOV   [__r2],A
1800: 51 61    MOV   A,[__r3]
1802: 54 03    MOV   [X+3],A
1804: 51 62    MOV   A,[__r2]
1806: 54 02    MOV   [X+2],A
1808: 60 D4    MOV   REG[212],A
180A: 3E 61    MVI   A,[__r3]
180C: 7A 61    DEC   [__r3]
180E: 53 62    MOV   [__r2],A
1810: 51 64    MOV   A,[__r0]
1812: 60 D5    MOV   REG[213],A
1814: 51 62    MOV   A,[__r2]
1816: 3F 63    MVI   [__r1],A
1818: 77 05    INC   [X+5]
181A: 0F 04 00 ADC   [X+4],0
181D: 52 05    MOV   A,[X+5]
181F: 13 01    SUB   A,[X+1]
1821: 52 00    MOV   A,[X+0]
1823: 31 80    XOR   A,128
1825: 62 D0 00 MOV   REG[208],0
1828: 53 60    MOV   [__rX],A
182A: 52 04    MOV   A,[X+4]
182C: 31 80    XOR   A,128
182E: 1A 60    SBB   A,[__rX]
1830: CF AC    JC    0x17DD
(0258) 	}
(0259) 
(0260) 	return(len);
1832: 62 D0 00 MOV   REG[208],0
1835: 52 01    MOV   A,[X+1]
1837: 53 63    MOV   [__r1],A
1839: 52 00    MOV   A,[X+0]
183B: 53 64    MOV   [__r0],A
183D: 38 ED    ADD   SP,237
183F: 20       POP   X
1840: 7F       RET   
(0261) }
(0262) 
(0263) /** 1LN^\
(0264)  * @param ch f[^R[hl
(0265)  * @param buff f[^i[obt@|C^
(0266)  * @return 
(0267)  */
(0268) static int tsprintf_char(int ch,char* buff){
_tsprintf_char:
  buff                 --> X-7
  ch                   --> X-5
1841: 10       PUSH  X
1842: 4F       MOV   X,SP
(0269) 	*buff = (char)ch;
1843: 62 D0 00 MOV   REG[208],0
1846: 52 FC    MOV   A,[X-4]
1848: 53 64    MOV   [__r0],A
184A: 52 FA    MOV   A,[X-6]
184C: 53 61    MOV   [__r3],A
184E: 52 F9    MOV   A,[X-7]
1850: 60 D5    MOV   REG[213],A
1852: 51 64    MOV   A,[__r0]
1854: 3F 61    MVI   [__r3],A
(0270) 	return(1);
1856: 55 63 01 MOV   [__r1],1
1859: 55 64 00 MOV   [__r0],0
185C: 20       POP   X
185D: 7F       RET   
(0271) }
(0272) 
(0273) /** ASCIIZ\(RAMm)
(0274)  * @param str ASCIIZf[^|C^
(0275)  * @param buff f[^i[obt@|C^
(0276)  * @return 
(0277)  */
(0278) static int tsprintf_string(char* str,char* buff){
_tsprintf_string:
  count                --> X+0
  buff                 --> X-7
  str                  --> X-5
185E: 10       PUSH  X
185F: 4F       MOV   X,SP
1860: 38 02    ADD   SP,2
(0279) 	int count = 0;
1862: 56 01 00 MOV   [X+1],0
1865: 56 00 00 MOV   [X+0],0
1868: 80 36    JMP   0x189F
(0280) 	while(*str){
(0281) 		*(buff++) = *str;
186A: 62 D0 00 MOV   REG[208],0
186D: 52 FA    MOV   A,[X-6]
186F: 53 63    MOV   [__r1],A
1871: 52 F9    MOV   A,[X-7]
1873: 53 64    MOV   [__r0],A
1875: 51 63    MOV   A,[__r1]
1877: 01 01    ADD   A,1
1879: 54 FA    MOV   [X-6],A
187B: 51 64    MOV   A,[__r0]
187D: 09 00    ADC   A,0
187F: 54 F9    MOV   [X-7],A
1881: 52 FC    MOV   A,[X-4]
1883: 53 61    MOV   [__r3],A
1885: 52 FB    MOV   A,[X-5]
1887: 60 D4    MOV   REG[212],A
1889: 3E 61    MVI   A,[__r3]
188B: 53 62    MOV   [__r2],A
188D: 51 64    MOV   A,[__r0]
188F: 60 D5    MOV   REG[213],A
1891: 51 62    MOV   A,[__r2]
1893: 3F 63    MVI   [__r1],A
(0282) 		str++;
1895: 77 FC    INC   [X-4]
1897: 0F FB 00 ADC   [X-5],0
(0283) 		count++;
189A: 77 01    INC   [X+1]
189C: 0F 00 00 ADC   [X+0],0
189F: 62 D0 00 MOV   REG[208],0
18A2: 52 FC    MOV   A,[X-4]
18A4: 53 63    MOV   [__r1],A
18A6: 52 FB    MOV   A,[X-5]
18A8: 60 D4    MOV   REG[212],A
18AA: 3E 63    MVI   A,[__r1]
18AC: 39 00    CMP   A,0
18AE: BF BB    JNZ   0x186A
(0284) 	}
(0285) 	return(count);
18B0: 52 01    MOV   A,[X+1]
18B2: 53 63    MOV   [__r1],A
18B4: 52 00    MOV   A,[X+0]
18B6: 53 64    MOV   [__r0],A
18B8: 38 FE    ADD   SP,254
18BA: 20       POP   X
18BB: 7F       RET   
(0286) }
(0287) 
(0288) /** Const ASCIIZ\(ROMm)
(0289)  * @param str ASCIIZf[^|C^
(0290)  * @param buff f[^i[obt@|C^
(0291)  * @return 
(0292)  */
(0293) static int tsprintf_cstring(const char* str,char* buff){
_tsprintf_cstring:
  count                --> X+0
  buff                 --> X-7
  str                  --> X-5
18BC: 10       PUSH  X
18BD: 4F       MOV   X,SP
18BE: 38 02    ADD   SP,2
(0294) 	int count = 0;
18C0: 56 01 00 MOV   [X+1],0
18C3: 56 00 00 MOV   [X+0],0
18C6: 80 37    JMP   0x18FE
(0295) 	while(*str){
(0296) 		*(buff++) = *str;
18C8: 62 D0 00 MOV   REG[208],0
18CB: 52 FA    MOV   A,[X-6]
18CD: 53 63    MOV   [__r1],A
18CF: 52 F9    MOV   A,[X-7]
18D1: 53 64    MOV   [__r0],A
18D3: 51 63    MOV   A,[__r1]
18D5: 01 01    ADD   A,1
18D7: 54 FA    MOV   [X-6],A
18D9: 51 64    MOV   A,[__r0]
18DB: 09 00    ADC   A,0
18DD: 54 F9    MOV   [X-7],A
18DF: 52 FC    MOV   A,[X-4]
18E1: 53 61    MOV   [__r3],A
18E3: 52 FB    MOV   A,[X-5]
18E5: 10       PUSH  X
18E6: 58 61    MOV   X,[__r3]
18E8: 28       ROMX  
18E9: 20       POP   X
18EA: 53 62    MOV   [__r2],A
18EC: 51 64    MOV   A,[__r0]
18EE: 60 D5    MOV   REG[213],A
18F0: 51 62    MOV   A,[__r2]
18F2: 3F 63    MVI   [__r1],A
(0297) 		str++;
18F4: 77 FC    INC   [X-4]
18F6: 0F FB 00 ADC   [X-5],0
(0298) 		count++;
18F9: 77 01    INC   [X+1]
18FB: 0F 00 00 ADC   [X+0],0
18FE: 62 D0 00 MOV   REG[208],0
1901: 52 FC    MOV   A,[X-4]
1903: 53 63    MOV   [__r1],A
1905: 52 FB    MOV   A,[X-5]
1907: 10       PUSH  X
1908: 58 63    MOV   X,[__r1]
190A: 28       ROMX  
190B: 20       POP   X
190C: 39 00    CMP   A,0
190E: BF B9    JNZ   0x18C8
(0299) 	}
(0300) 	return(count);
1910: 52 01    MOV   A,[X+1]
1912: 53 63    MOV   [__r1],A
1914: 52 00    MOV   A,[X+0]
1916: 53 64    MOV   [__r0],A
1918: 38 FE    ADD   SP,254
191A: 20       POP   X
191B: 7F       RET   

FILE: .\tstring.c
(0001) /*
(0002) 	Rg[ string.c
(0003) 	Copyright(C)2002 Yasuhiro ISHII
(0004) 	All rights reserved.
(0005) 	Ver 0.04
(0006) 	0.02            : tstrlen
(0007) 	0.03            : SearchFirstPosC
(0008) 	0.04 2005/06/11 : X
(0009) 
(0010) */
(0011) 
(0012) #include "tstring.h"
(0013) 
(0014) void TrimStringLeft(unsigned char* );
(0015) void TrimStringRight(unsigned char* );
(0016) void tstrcpy(char* ,const char* );
(0017) void tstrncpy(char* ,const char* ,int );
(0018) char tstrcmp(const char* ,const char* );
(0019) int SearchFirstPos(const char* ,char );
(0020) int tstrlen(char* );
(0021) 
(0022) // g~O(n_)
(0023) // (0x20)
(0024) void TrimStringLeft(unsigned char* buffer){
_TrimStringLeft:
  i                    --> X+1
  j                    --> X+0
  buffer               --> X-5
191C: 10       PUSH  X
191D: 4F       MOV   X,SP
191E: 38 02    ADD   SP,2
(0025) 	unsigned char i,j;
(0026) 	i=j=0;
1920: 56 00 00 MOV   [X+0],0
1923: 56 01 00 MOV   [X+1],0
1926: 80 03    JMP   0x192A
(0027) 	while(buffer[i] == 0x20){
(0028) 		i++;
1928: 77 01    INC   [X+1]
192A: 62 D0 00 MOV   REG[208],0
192D: 52 01    MOV   A,[X+1]
192F: 53 63    MOV   [__r1],A
1931: 55 64 00 MOV   [__r0],0
1934: 52 FC    MOV   A,[X-4]
1936: 04 63    ADD   [__r1],A
1938: 52 FB    MOV   A,[X-5]
193A: 0C 64    ADC   [__r0],A
193C: 51 64    MOV   A,[__r0]
193E: 60 D4    MOV   REG[212],A
1940: 3E 63    MVI   A,[__r1]
1942: 39 20    CMP   A,32
1944: AF E3    JZ    0x1928
1946: 80 40    JMP   0x1987
(0029) 	}
(0030) 	while (buffer[i+j]){
(0031) 		buffer[j]=buffer[i+j];
1948: 62 D0 00 MOV   REG[208],0
194B: 52 00    MOV   A,[X+0]
194D: 53 63    MOV   [__r1],A
194F: 55 64 00 MOV   [__r0],0
1952: 52 01    MOV   A,[X+1]
1954: 55 62 00 MOV   [__r2],0
1957: 02 63    ADD   A,[__r1]
1959: 53 63    MOV   [__r1],A
195B: 50 00    MOV   A,0
195D: 0A 64    ADC   A,[__r0]
195F: 53 64    MOV   [__r0],A
1961: 52 FC    MOV   A,[X-4]
1963: 04 63    ADD   [__r1],A
1965: 52 FB    MOV   A,[X-5]
1967: 0C 64    ADC   [__r0],A
1969: 51 64    MOV   A,[__r0]
196B: 60 D4    MOV   REG[212],A
196D: 3E 63    MVI   A,[__r1]
196F: 53 64    MOV   [__r0],A
1971: 52 00    MOV   A,[X+0]
1973: 53 61    MOV   [__r3],A
1975: 52 FC    MOV   A,[X-4]
1977: 04 61    ADD   [__r3],A
1979: 52 FB    MOV   A,[X-5]
197B: 0C 62    ADC   [__r2],A
197D: 51 62    MOV   A,[__r2]
197F: 60 D5    MOV   REG[213],A
1981: 51 64    MOV   A,[__r0]
1983: 3F 61    MVI   [__r3],A
(0032) 		j++;
1985: 77 00    INC   [X+0]
1987: 62 D0 00 MOV   REG[208],0
198A: 52 00    MOV   A,[X+0]
198C: 53 63    MOV   [__r1],A
198E: 55 64 00 MOV   [__r0],0
1991: 52 01    MOV   A,[X+1]
1993: 02 63    ADD   A,[__r1]
1995: 53 63    MOV   [__r1],A
1997: 50 00    MOV   A,0
1999: 0A 64    ADC   A,[__r0]
199B: 53 64    MOV   [__r0],A
199D: 52 FC    MOV   A,[X-4]
199F: 04 63    ADD   [__r1],A
19A1: 52 FB    MOV   A,[X-5]
19A3: 0C 64    ADC   [__r0],A
19A5: 51 64    MOV   A,[__r0]
19A7: 60 D4    MOV   REG[212],A
19A9: 3E 63    MVI   A,[__r1]
19AB: 39 00    CMP   A,0
19AD: BF 9A    JNZ   0x1948
(0033) 	}
(0034) 	buffer[j] = 0;
19AF: 52 00    MOV   A,[X+0]
19B1: 53 63    MOV   [__r1],A
19B3: 55 64 00 MOV   [__r0],0
19B6: 52 FC    MOV   A,[X-4]
19B8: 04 63    ADD   [__r1],A
19BA: 52 FB    MOV   A,[X-5]
19BC: 0C 64    ADC   [__r0],A
19BE: 51 64    MOV   A,[__r0]
19C0: 60 D5    MOV   REG[213],A
19C2: 50 00    MOV   A,0
19C4: 3F 63    MVI   [__r1],A
(0035) }
19C6: 38 FE    ADD   SP,254
19C8: 20       POP   X
19C9: 7F       RET   
(0036) 
(0037) // g~O(I_)
(0038) // (0x20)
(0039) void TrimStringRight(unsigned char* buffer){
_TrimStringRight:
  i                    --> X+0
  buffer               --> X-5
19CA: 10       PUSH  X
19CB: 4F       MOV   X,SP
19CC: 38 01    ADD   SP,1
(0040)     unsigned char i;
(0041) 	i=0;
19CE: 56 00 00 MOV   [X+0],0
(0042)     while(buffer[i++]);
19D1: 62 D0 00 MOV   REG[208],0
19D4: 52 00    MOV   A,[X+0]
19D6: 53 63    MOV   [__r1],A
19D8: 55 64 00 MOV   [__r0],0
19DB: 01 01    ADD   A,1
19DD: 54 00    MOV   [X+0],A
19DF: 52 FC    MOV   A,[X-4]
19E1: 04 63    ADD   [__r1],A
19E3: 52 FB    MOV   A,[X-5]
19E5: 0C 64    ADC   [__r0],A
19E7: 51 64    MOV   A,[__r0]
19E9: 60 D4    MOV   REG[212],A
19EB: 3E 63    MVI   A,[__r1]
19ED: 39 00    CMP   A,0
19EF: BF E1    JNZ   0x19D1
(0043)     i-=2;
19F1: 52 00    MOV   A,[X+0]
19F3: 11 02    SUB   A,2
19F5: 54 00    MOV   [X+0],A
(0044)     while(buffer[i--] == 0x20);
19F7: 62 D0 00 MOV   REG[208],0
19FA: 52 00    MOV   A,[X+0]
19FC: 53 63    MOV   [__r1],A
19FE: 55 64 00 MOV   [__r0],0
1A01: 11 01    SUB   A,1
1A03: 54 00    MOV   [X+0],A
1A05: 52 FC    MOV   A,[X-4]
1A07: 04 63    ADD   [__r1],A
1A09: 52 FB    MOV   A,[X-5]
1A0B: 0C 64    ADC   [__r0],A
1A0D: 51 64    MOV   A,[__r0]
1A0F: 60 D4    MOV   REG[212],A
1A11: 3E 63    MVI   A,[__r1]
1A13: 39 20    CMP   A,32
1A15: AF E1    JZ    0x19F7
(0045)     buffer[i+2]=0x00;
1A17: 52 00    MOV   A,[X+0]
1A19: 53 63    MOV   [__r1],A
1A1B: 55 64 00 MOV   [__r0],0
1A1E: 52 FC    MOV   A,[X-4]
1A20: 04 63    ADD   [__r1],A
1A22: 52 FB    MOV   A,[X-5]
1A24: 0C 64    ADC   [__r0],A
1A26: 06 63 02 ADD   [__r1],2
1A29: 0E 64 00 ADC   [__r0],0
1A2C: 51 64    MOV   A,[__r0]
1A2E: 60 D5    MOV   REG[213],A
1A30: 50 00    MOV   A,0
1A32: 3F 63    MVI   [__r1],A
(0046) }
1A34: 38 FF    ADD   SP,255
1A36: 20       POP   X
1A37: 7F       RET   
(0047) 
(0048) // strcpyRp`
(0049) // Al
(0050) void tstrcpy(char* dst,const char* src){
_tstrcpy:
  src                  --> X-7
  dst                  --> X-5
1A38: 10       PUSH  X
1A39: 4F       MOV   X,SP
1A3A: 80 3D    JMP   0x1A78
(0051)     while(*src){
(0052) 		*dst++ = *src++;
1A3C: 62 D0 00 MOV   REG[208],0
1A3F: 52 FC    MOV   A,[X-4]
1A41: 53 63    MOV   [__r1],A
1A43: 52 FB    MOV   A,[X-5]
1A45: 53 64    MOV   [__r0],A
1A47: 51 63    MOV   A,[__r1]
1A49: 01 01    ADD   A,1
1A4B: 54 FC    MOV   [X-4],A
1A4D: 51 64    MOV   A,[__r0]
1A4F: 09 00    ADC   A,0
1A51: 54 FB    MOV   [X-5],A
1A53: 52 FA    MOV   A,[X-6]
1A55: 53 61    MOV   [__r3],A
1A57: 52 F9    MOV   A,[X-7]
1A59: 53 62    MOV   [__r2],A
1A5B: 51 61    MOV   A,[__r3]
1A5D: 01 01    ADD   A,1
1A5F: 54 FA    MOV   [X-6],A
1A61: 51 62    MOV   A,[__r2]
1A63: 09 00    ADC   A,0
1A65: 54 F9    MOV   [X-7],A
1A67: 51 62    MOV   A,[__r2]
1A69: 10       PUSH  X
1A6A: 58 61    MOV   X,[__r3]
1A6C: 28       ROMX  
1A6D: 20       POP   X
1A6E: 53 62    MOV   [__r2],A
1A70: 51 64    MOV   A,[__r0]
1A72: 60 D5    MOV   REG[213],A
1A74: 51 62    MOV   A,[__r2]
1A76: 3F 63    MVI   [__r1],A
1A78: 62 D0 00 MOV   REG[208],0
1A7B: 52 FA    MOV   A,[X-6]
1A7D: 53 63    MOV   [__r1],A
1A7F: 52 F9    MOV   A,[X-7]
1A81: 10       PUSH  X
1A82: 58 63    MOV   X,[__r1]
1A84: 28       ROMX  
1A85: 20       POP   X
1A86: 39 00    CMP   A,0
1A88: BF B3    JNZ   0x1A3C
(0053)     }
(0054)     *dst=*src;
1A8A: 52 FA    MOV   A,[X-6]
1A8C: 53 63    MOV   [__r1],A
1A8E: 52 F9    MOV   A,[X-7]
1A90: 10       PUSH  X
1A91: 58 63    MOV   X,[__r1]
1A93: 28       ROMX  
1A94: 20       POP   X
1A95: 53 64    MOV   [__r0],A
1A97: 52 FC    MOV   A,[X-4]
1A99: 53 61    MOV   [__r3],A
1A9B: 52 FB    MOV   A,[X-5]
1A9D: 60 D5    MOV   REG[213],A
1A9F: 51 64    MOV   A,[__r0]
1AA1: 3F 61    MVI   [__r3],A
(0055) }
1AA3: 20       POP   X
1AA4: 7F       RET   
(0056) 
(0057) 
(0058) // strncpyRp`
(0059) // Al
(0060) void tstrncpy(char* dst,const char* src,int count){
_tstrncpy:
  i                    --> X+0
  count                --> X-9
  src                  --> X-7
  dst                  --> X-5
1AA5: 10       PUSH  X
1AA6: 4F       MOV   X,SP
1AA7: 38 02    ADD   SP,2
(0061)     int i;
(0062)     i=0;
1AA9: 56 01 00 MOV   [X+1],0
1AAC: 56 00 00 MOV   [X+0],0
(0063)     if (count){
1AAF: 3D F7 00 CMP   [X-9],0
1AB2: B0 06    JNZ   0x1AB9
1AB4: 3D F8 00 CMP   [X-8],0
1AB7: A0 8B    JZ    0x1B43
1AB9: 80 3D    JMP   0x1AF7
(0064) 		while(*src && i < count - 1){
(0065) 			*dst++ = *src++;
1ABB: 62 D0 00 MOV   REG[208],0
1ABE: 52 FC    MOV   A,[X-4]
1AC0: 53 63    MOV   [__r1],A
1AC2: 52 FB    MOV   A,[X-5]
1AC4: 53 64    MOV   [__r0],A
1AC6: 51 63    MOV   A,[__r1]
1AC8: 01 01    ADD   A,1
1ACA: 54 FC    MOV   [X-4],A
1ACC: 51 64    MOV   A,[__r0]
1ACE: 09 00    ADC   A,0
1AD0: 54 FB    MOV   [X-5],A
1AD2: 52 FA    MOV   A,[X-6]
1AD4: 53 61    MOV   [__r3],A
1AD6: 52 F9    MOV   A,[X-7]
1AD8: 53 62    MOV   [__r2],A
1ADA: 51 61    MOV   A,[__r3]
1ADC: 01 01    ADD   A,1
1ADE: 54 FA    MOV   [X-6],A
1AE0: 51 62    MOV   A,[__r2]
1AE2: 09 00    ADC   A,0
1AE4: 54 F9    MOV   [X-7],A
1AE6: 51 62    MOV   A,[__r2]
1AE8: 10       PUSH  X
1AE9: 58 61    MOV   X,[__r3]
1AEB: 28       ROMX  
1AEC: 20       POP   X
1AED: 53 62    MOV   [__r2],A
1AEF: 51 64    MOV   A,[__r0]
1AF1: 60 D5    MOV   REG[213],A
1AF3: 51 62    MOV   A,[__r2]
1AF5: 3F 63    MVI   [__r1],A
1AF7: 62 D0 00 MOV   REG[208],0
1AFA: 52 FA    MOV   A,[X-6]
1AFC: 53 63    MOV   [__r1],A
1AFE: 52 F9    MOV   A,[X-7]
1B00: 10       PUSH  X
1B01: 58 63    MOV   X,[__r1]
1B03: 28       ROMX  
1B04: 20       POP   X
1B05: 39 00    CMP   A,0
1B07: A0 1F    JZ    0x1B27
1B09: 52 F8    MOV   A,[X-8]
1B0B: 11 01    SUB   A,1
1B0D: 53 63    MOV   [__r1],A
1B0F: 52 F7    MOV   A,[X-9]
1B11: 19 00    SBB   A,0
1B13: 53 64    MOV   [__r0],A
1B15: 52 01    MOV   A,[X+1]
1B17: 12 63    SUB   A,[__r1]
1B19: 51 64    MOV   A,[__r0]
1B1B: 31 80    XOR   A,128
1B1D: 53 60    MOV   [__rX],A
1B1F: 52 00    MOV   A,[X+0]
1B21: 31 80    XOR   A,128
1B23: 1A 60    SBB   A,[__rX]
1B25: CF 95    JC    0x1ABB
(0066) 		}
(0067) 		*dst=*src;
1B27: 62 D0 00 MOV   REG[208],0
1B2A: 52 FA    MOV   A,[X-6]
1B2C: 53 63    MOV   [__r1],A
1B2E: 52 F9    MOV   A,[X-7]
1B30: 10       PUSH  X
1B31: 58 63    MOV   X,[__r1]
1B33: 28       ROMX  
1B34: 20       POP   X
1B35: 53 64    MOV   [__r0],A
1B37: 52 FC    MOV   A,[X-4]
1B39: 53 61    MOV   [__r3],A
1B3B: 52 FB    MOV   A,[X-5]
1B3D: 60 D5    MOV   REG[213],A
1B3F: 51 64    MOV   A,[__r0]
1B41: 3F 61    MVI   [__r3],A
(0068)     }
(0069) }
1B43: 38 FE    ADD   SP,254
1B45: 20       POP   X
1B46: 7F       RET   
(0070) 
(0071) // string compare
(0072) // lWstrcmp
(0073) // l : string1string2 : 0
(0074) //          string1string2 : 1
(0075) char tstrcmp(const char* string1,const char* string2){
_tstrcmp:
  string2              --> X-7
  string1              --> X-5
1B47: 10       PUSH  X
1B48: 4F       MOV   X,SP
1B49: 80 44    JMP   0x1B8E
(0076)     while(*string1 | *string2){
(0077) 		if (*string1++ != *string2++){
1B4B: 62 D0 00 MOV   REG[208],0
1B4E: 52 FC    MOV   A,[X-4]
1B50: 53 63    MOV   [__r1],A
1B52: 52 FB    MOV   A,[X-5]
1B54: 53 64    MOV   [__r0],A
1B56: 51 63    MOV   A,[__r1]
1B58: 01 01    ADD   A,1
1B5A: 54 FC    MOV   [X-4],A
1B5C: 51 64    MOV   A,[__r0]
1B5E: 09 00    ADC   A,0
1B60: 54 FB    MOV   [X-5],A
1B62: 52 FA    MOV   A,[X-6]
1B64: 53 61    MOV   [__r3],A
1B66: 52 F9    MOV   A,[X-7]
1B68: 53 62    MOV   [__r2],A
1B6A: 51 61    MOV   A,[__r3]
1B6C: 01 01    ADD   A,1
1B6E: 54 FA    MOV   [X-6],A
1B70: 51 62    MOV   A,[__r2]
1B72: 09 00    ADC   A,0
1B74: 54 F9    MOV   [X-7],A
1B76: 51 62    MOV   A,[__r2]
1B78: 10       PUSH  X
1B79: 58 61    MOV   X,[__r3]
1B7B: 28       ROMX  
1B7C: 20       POP   X
1B7D: 53 62    MOV   [__r2],A
1B7F: 51 64    MOV   A,[__r0]
1B81: 10       PUSH  X
1B82: 58 63    MOV   X,[__r1]
1B84: 28       ROMX  
1B85: 20       POP   X
1B86: 3A 62    CMP   A,[__r2]
1B88: A0 05    JZ    0x1B8E
(0078) 		    return 1;
1B8A: 50 01    MOV   A,1
1B8C: 80 24    JMP   0x1BB1
1B8E: 62 D0 00 MOV   REG[208],0
1B91: 52 FA    MOV   A,[X-6]
1B93: 53 63    MOV   [__r1],A
1B95: 52 F9    MOV   A,[X-7]
1B97: 10       PUSH  X
1B98: 58 63    MOV   X,[__r1]
1B9A: 28       ROMX  
1B9B: 20       POP   X
1B9C: 53 64    MOV   [__r0],A
1B9E: 52 FC    MOV   A,[X-4]
1BA0: 53 61    MOV   [__r3],A
1BA2: 52 FB    MOV   A,[X-5]
1BA4: 10       PUSH  X
1BA5: 58 61    MOV   X,[__r3]
1BA7: 28       ROMX  
1BA8: 20       POP   X
1BA9: 2A 64    OR    A,[__r0]
1BAB: 39 00    CMP   A,0
1BAD: BF 9D    JNZ   0x1B4B
(0079) 		}
(0080)     }
(0081)     return(0);
1BAF: 50 00    MOV   A,0
1BB1: 20       POP   X
1BB2: 7F       RET   
(0082) }
(0083) 
(0084) // 2wchar^f[^
(0085) // l : |WV
(0086) //          AA -1 
(0087) int SearchFirstPos(const char* buffer,char c){
_SearchFirstPos:
  i                    --> X+0
  c                    --> X-6
  buffer               --> X-5
1BB3: 10       PUSH  X
1BB4: 4F       MOV   X,SP
1BB5: 38 04    ADD   SP,4
(0088)     int i;
(0089)     i = 0;
1BB7: 56 01 00 MOV   [X+1],0
1BBA: 56 00 00 MOV   [X+0],0
1BBD: 80 0B    JMP   0x1BC9
(0090)     while((*buffer != c) && (*buffer)){
(0091) 		buffer++;
1BBF: 77 FC    INC   [X-4]
1BC1: 0F FB 00 ADC   [X-5],0
(0092) 		i++;
1BC4: 77 01    INC   [X+1]
1BC6: 0F 00 00 ADC   [X+0],0
1BC9: 62 D0 00 MOV   REG[208],0
1BCC: 52 FC    MOV   A,[X-4]
1BCE: 53 63    MOV   [__r1],A
1BD0: 52 FB    MOV   A,[X-5]
1BD2: 10       PUSH  X
1BD3: 58 63    MOV   X,[__r1]
1BD5: 28       ROMX  
1BD6: 20       POP   X
1BD7: 53 63    MOV   [__r1],A
1BD9: 55 64 00 MOV   [__r0],0
1BDC: 52 FA    MOV   A,[X-6]
1BDE: 53 61    MOV   [__r3],A
1BE0: 55 62 00 MOV   [__r2],0
1BE3: 50 00    MOV   A,0
1BE5: 3A 62    CMP   A,[__r2]
1BE7: B0 07    JNZ   0x1BEF
1BE9: 51 63    MOV   A,[__r1]
1BEB: 3A 61    CMP   A,[__r3]
1BED: A0 0E    JZ    0x1BFC
1BEF: 62 D0 00 MOV   REG[208],0
1BF2: 3C 64 00 CMP   [__r0],0
1BF5: BF C9    JNZ   0x1BBF
1BF7: 3C 63 00 CMP   [__r1],0
1BFA: BF C4    JNZ   0x1BBF
(0093)     }
(0094)     return (*buffer ? i+1 : -1);
1BFC: 62 D0 00 MOV   REG[208],0
1BFF: 52 FC    MOV   A,[X-4]
1C01: 53 63    MOV   [__r1],A
1C03: 52 FB    MOV   A,[X-5]
1C05: 10       PUSH  X
1C06: 58 63    MOV   X,[__r1]
1C08: 28       ROMX  
1C09: 20       POP   X
1C0A: 39 00    CMP   A,0
1C0C: A0 0F    JZ    0x1C1C
1C0E: 52 01    MOV   A,[X+1]
1C10: 01 01    ADD   A,1
1C12: 54 03    MOV   [X+3],A
1C14: 52 00    MOV   A,[X+0]
1C16: 09 00    ADC   A,0
1C18: 54 02    MOV   [X+2],A
1C1A: 80 07    JMP   0x1C22
1C1C: 56 03 FF MOV   [X+3],255
1C1F: 56 02 FF MOV   [X+2],255
1C22: 62 D0 00 MOV   REG[208],0
1C25: 52 03    MOV   A,[X+3]
1C27: 53 63    MOV   [__r1],A
1C29: 52 02    MOV   A,[X+2]
1C2B: 53 64    MOV   [__r0],A
1C2D: 38 FC    ADD   SP,252
1C2F: 20       POP   X
1C30: 7F       RET   
(0095) }
(0096) 
(0097) 
(0098) /*
(0099) 	
(0100)      : 
(0101)     l : w
(0102) */
(0103) int tstrlen(char* ucpStr){
_tstrlen:
  len                  --> X+0
  ucpStr               --> X-5
1C31: 10       PUSH  X
1C32: 4F       MOV   X,SP
1C33: 38 02    ADD   SP,2
(0104) 	int len = 0;
1C35: 56 01 00 MOV   [X+1],0
1C38: 56 00 00 MOV   [X+0],0
1C3B: 80 06    JMP   0x1C42
(0105) 
(0106) 	while(*(ucpStr++)){
(0107) 		len++;
1C3D: 77 01    INC   [X+1]
1C3F: 0F 00 00 ADC   [X+0],0
1C42: 62 D0 00 MOV   REG[208],0
1C45: 52 FC    MOV   A,[X-4]
1C47: 53 63    MOV   [__r1],A
1C49: 52 FB    MOV   A,[X-5]
1C4B: 53 64    MOV   [__r0],A
1C4D: 51 63    MOV   A,[__r1]
1C4F: 01 01    ADD   A,1
1C51: 54 FC    MOV   [X-4],A
1C53: 51 64    MOV   A,[__r0]
1C55: 09 00    ADC   A,0
1C57: 54 FB    MOV   [X-5],A
1C59: 51 64    MOV   A,[__r0]
1C5B: 60 D4    MOV   REG[212],A
1C5D: 3E 63    MVI   A,[__r1]
1C5F: 39 00    CMP   A,0
1C61: BF DB    JNZ   0x1C3D
(0108) 	}
(0109) 
(0110) 	return(len);
1C63: 52 01    MOV   A,[X+1]
1C65: 53 63    MOV   [__r1],A
1C67: 52 00    MOV   A,[X+0]
1C69: 53 64    MOV   [__r0],A
1C6B: 38 FE    ADD   SP,254
1C6D: 20       POP   X
1C6E: 7F       RET   

FILE: lib\usbuartint.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: USBUARTInt.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/10/20 at 16:08:45
                                   (0005) ;;  Generated by PSoC Designer ver 4.3  b1884 : 23 June, 2006
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: USBFS User Module software implementation file
                                   (0008) ;;               for the CY8C24090 and CY7C64215 PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress Semiconductor 2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "USBUART.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name reference for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    USBUART_EP1_ISR
                                   (0044) export   _USBUART_EP1_ISR
                                   (0045) export    USBUART_EP2_ISR
                                   (0046) export   _USBUART_EP2_ISR
                                   (0047) export    USBUART_EP3_ISR
                                   (0048) export   _USBUART_EP3_ISR
                                   (0049) export    USBUART_EP4_ISR
                                   (0050) export   _USBUART_EP4_ISR
                                   (0051) export    USBUART_RESET_ISR
                                   (0052) export   _USBUART_RESET_ISR
                                   (0053) export    USBUART_SOF_ISR
                                   (0054) export   _USBUART_SOF_ISR
                                   (0055) export    USBUART_WAKEUP_ISR
                                   (0056) export   _USBUART_WAKEUP_ISR
                                   (0057) 
                                   (0058) 
                                   (0059) AREA InterruptRAM (RAM, REL, CON)
                                   (0060) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0061) ;---------------------------------------------------
                                   (0062) ; Insert your custom declarations below this banner
                                   (0063) ;---------------------------------------------------
                                   (0064) 
                                   (0065) ;------------------------
                                   (0066) ; Includes
                                   (0067) ;------------------------
                                   (0068) 
                                   (0069) 	
                                   (0070) ;------------------------
                                   (0071) ;  Constant Definitions
                                   (0072) ;------------------------
                                   (0073) 
                                   (0074) 
                                   (0075) ;------------------------
                                   (0076) ; Variable Allocation
                                   (0077) ;------------------------
                                   (0078) 
                                   (0079) 
                                   (0080) ;---------------------------------------------------
                                   (0081) ; Insert your custom declarations above this banner
                                   (0082) ;---------------------------------------------------
                                   (0083) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0084) 
                                   (0085) AREA text (ROM, REL)
                                   (0086) 
                                   (0087) 
                                   (0088)  USBUART_EP1_ISR:
                                   (0089) _USBUART_EP1_ISR:
                                   (0090) 
1C6F: 55 27 01 MOV   [39],1        (0091)    mov  [USBUART_EndpointAPIStatus + 1], EVENT_PENDING    
                                   (0092)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0093)    ;---------------------------------------------------
                                   (0094)    ; Insert your custom code below this banner
                                   (0095)    ;---------------------------------------------------
                                   (0096)    ;   NOTE: interrupt service routines must preserve
                                   (0097)    ;   the values of the A and X CPU registers.
                                   (0098) 
                                   (0099)    ;---------------------------------------------------
                                   (0100)    ; Insert your custom code above this banner
                                   (0101)    ;---------------------------------------------------
                                   (0102)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0103) 
1C72: 7E       RETI                (0104)    reti
                                   (0105) 
                                   (0106)  USBUART_EP2_ISR:
                                   (0107) _USBUART_EP2_ISR:
                                   (0108) 
1C73: 55 28 01 MOV   [40],1        (0109)    mov  [USBUART_EndpointAPIStatus + 2], EVENT_PENDING    
                                   (0110)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0111)    ;---------------------------------------------------
                                   (0112)    ; Insert your custom code below this banner
                                   (0113)    ;---------------------------------------------------
                                   (0114)    ;   NOTE: interrupt service routines must preserve
                                   (0115)    ;   the values of the A and X CPU registers.
                                   (0116) 
                                   (0117)    ;---------------------------------------------------
                                   (0118)    ; Insert your custom code above this banner
                                   (0119)    ;---------------------------------------------------
                                   (0120)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0121) 
1C76: 7E       RETI                (0122)    reti
                                   (0123) 
                                   (0124)  USBUART_EP3_ISR:
                                   (0125) _USBUART_EP3_ISR:
                                   (0126) 
1C77: 55 29 01 MOV   [41],1        (0127)    mov  [USBUART_EndpointAPIStatus + 3], EVENT_PENDING    
                                   (0128)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                   (0129)    ;---------------------------------------------------
                                   (0130)    ; Insert your custom code below this banner
                                   (0131)    ;---------------------------------------------------
                                   (0132)    ;   NOTE: interrupt service routines must preserve
                                   (0133)    ;   the values of the A and X CPU registers.
                                   (0134) 
                                   (0135)    ;---------------------------------------------------
                                   (0136)    ; Insert your custom code above this banner
                                   (0137)    ;---------------------------------------------------
                                   (0138)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0139) 
1C7A: 7E       RETI                (0140)    reti
                                   (0141) 
                                   (0142)  USBUART_EP4_ISR:
                                   (0143) _USBUART_EP4_ISR:
                                   (0144) 
1C7B: 55 2A 01 MOV   [42],1        (0145)    mov  [USBUART_EndpointAPIStatus + 4], EVENT_PENDING    
                                   (0146)    ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
                                   (0147)    ;---------------------------------------------------
                                   (0148)    ; Insert your custom code below this banner
                                   (0149)    ;---------------------------------------------------
                                   (0150)    ;   NOTE: interrupt service routines must preserve
                                   (0151)    ;   the values of the A and X CPU registers.
                                   (0152) 
                                   (0153)    ;---------------------------------------------------
                                   (0154)    ; Insert your custom code above this banner
                                   (0155)    ;---------------------------------------------------
                                   (0156)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0157) 
1C7E: 7E       RETI                (0158)    reti
                                   (0159) 
                                   (0160)  USBUART_RESET_ISR:
                                   (0161) _USBUART_RESET_ISR:
1C7F: 10       PUSH  X             (0162)    push    X
1C80: 55 01 00 MOV   [1],0         (0163)    mov     [USBUART_Configuration], 0
1C83: 55 02 00 MOV   [2],0         (0164)    mov     [USBUART_DeviceStatus], 0
1C86: 55 03 00 MOV   [3],0         (0165)    mov     [USBUART_InterfaceSetting], 0
1C89: 55 05 00 MOV   [5],0         (0166)    mov     [USBUART_EndpointStatus], 0
1C8C: 55 0B 00 MOV   [11],0        (0167)    mov     [USBUART_TransferType], 0
1C8F: 55 22 00 MOV   [34],0        (0168)    mov     [USBUART_fDataPending], 0
1C92: 62 56 03 MOV   REG[86],3     (0169)    mov     reg[USBUART_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
1C95: 62 C4 00 MOV   REG[196],0    (0170)    mov     reg[USBUART_EP1MODE], 0
1C98: 62 C5 00 MOV   REG[197],0    (0171)    mov     reg[USBUART_EP2MODE], 0
1C9B: 62 C6 00 MOV   REG[198],0    (0172)    mov     reg[USBUART_EP3MODE], 0
1C9E: 62 C7 00 MOV   REG[199],0    (0173)    mov     reg[USBUART_EP4MODE], 0
1CA1: 57 04    MOV   X,4           (0174)    mov     X, USB_MAX_EP_NUMBER        ; Set up loop to clear all of the endpoint data items
                                   (0175) .loop:
1CA3: 56 1D 00 MOV   [X+29],0      (0176)    mov     [X + USBUART_EPDataToggle], 0  ; Or in the toggle
1CA6: 79       DEC   X             (0177)    dec     X                           ; Are we done?
1CA7: BF FB    JNZ   0x1CA3        (0178)    jnz     .loop                       ; Jump to do another endpoint    
                                   (0179) 
1CA9: 62 4A 80 MOV   REG[74],128   (0180)    mov     reg[USBUART_ADDR], USB_ADDR_ENABLE ; Enable Address 0
                                   (0181) 
                                   (0182)    ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
                                   (0183)    ;---------------------------------------------------
                                   (0184)    ; Insert your custom code below this banner
                                   (0185)    ;---------------------------------------------------
                                   (0186)    ;   NOTE: interrupt service routines must preserve
                                   (0187)    ;   the values of the A and X CPU registers.
                                   (0188) 
                                   (0189)    ;---------------------------------------------------
                                   (0190)    ; Insert your custom code above this banner
                                   (0191)    ;---------------------------------------------------
                                   (0192)    ;@PSoC_UserCode_END@ (Do not change this line.)
1CAC: 20       POP   X             (0193)    pop X
1CAD: 7E       RETI                (0194)    reti
                                   (0195) 
                                   (0196)  USBUART_SOF_ISR:
                                   (0197) _USBUART_SOF_ISR:
                                   (0198) 
                                   (0199)    ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
                                   (0200)    ;---------------------------------------------------
                                   (0201)    ; Insert your custom code below this banner
                                   (0202)    ;---------------------------------------------------
                                   (0203)    ;   NOTE: interrupt service routines must preserve
                                   (0204)    ;   the values of the A and X CPU registers.
                                   (0205) 
                                   (0206)    ;---------------------------------------------------
                                   (0207)    ; Insert your custom code above this banner
                                   (0208)    ;---------------------------------------------------
                                   (0209)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0210) 
1CAE: 7E       RETI                (0211)    reti
                                   (0212) 
                                   (0213)  USBUART_WAKEUP_ISR:
                                   (0214) _USBUART_WAKEUP_ISR:
                                   (0215) 
                                   (0216)    ;@PSoC_UserCode_BODY_7@ (Do not change this line.)
                                   (0217)    ;---------------------------------------------------
                                   (0218)    ; Insert your custom code below this banner
                                   (0219)    ;---------------------------------------------------
                                   (0220)    ;   NOTE: interrupt service routines must preserve
                                   (0221)    ;   the values of the A and X CPU registers.
                                   (0222) 
                                   (0223)    ;---------------------------------------------------
                                   (0224)    ; Insert your custom code above this banner
                                   (0225)    ;---------------------------------------------------
                                   (0226)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0227) 
                                   (0228)    reti

FILE: <library>
_USBUART_WAKEUP_ISR:
USBUART_WAKEUP_ISR:
1CAF: 7E       RETI  
__divmod_32X32_32:
1CB0: 10       PUSH  X
1CB1: 4F       MOV   X,SP
1CB2: 38 01    ADD   SP,1
1CB4: 50 00    MOV   A,0
1CB6: 3D F9 80 CMP   [X-7],128
1CB9: C0 06    JC    0x1CC0
1CBB: 7C 1D 50 LCALL __i_div32_not_util
1CBE: 50 C0    MOV   A,192
1CC0: 3D F5 80 CMP   [X-11],128
1CC3: C0 0C    JC    0x1CD0
1CC5: 10       PUSH  X
1CC6: 4B       SWAP  A,X
1CC7: 11 04    SUB   A,4
1CC9: 4B       SWAP  A,X
1CCA: 7C 1D 50 LCALL __i_div32_not_util
1CCD: 31 80    XOR   A,128
1CCF: 20       POP   X
1CD0: 08       PUSH  A
1CD1: 7C 1C ED LCALL __i_div32_block_util
1CD4: 18       POP   A
1CD5: 6A       RLC   A
1CD6: D0 04    JNC   0x1CDB
1CD8: 7C 1D 50 LCALL __i_div32_not_util
1CDB: 6A       RLC   A
1CDC: D0 08    JNC   0x1CE5
1CDE: 4B       SWAP  A,X
1CDF: 11 04    SUB   A,4
1CE1: 4B       SWAP  A,X
1CE2: 7C 1D 50 LCALL __i_div32_not_util
1CE5: 38 FF    ADD   SP,255
1CE7: 20       POP   X
1CE8: 70 3F    AND   F,63
1CEA: 71 C0    OR    F,192
1CEC: 7F       RET   
__i_div32_block_util:
1CED: 5D D0    MOV   A,REG[208]
1CEF: 08       PUSH  A
1CF0: 62 D0 00 MOV   REG[208],0
1CF3: 51 64    MOV   A,[__r0]
1CF5: 08       PUSH  A
1CF6: 50 00    MOV   A,0
1CF8: 53 64    MOV   [__r0],A
1CFA: 53 60    MOV   [__rX],A
1CFC: 53 5F    MOV   [__rY],A
1CFE: 53 5E    MOV   [__rZ],A
1D00: 56 00 20 MOV   [X+0],32
1D03: 66 FC    ASL   [X-4]
1D05: 6C FB    RLC   [X-5]
1D07: 6C FA    RLC   [X-6]
1D09: 6C F9    RLC   [X-7]
1D0B: 6B 5E    RLC   [__rZ]
1D0D: 6B 5F    RLC   [__rY]
1D0F: 6B 60    RLC   [__rX]
1D11: 6B 64    RLC   [__r0]
1D13: 51 5E    MOV   A,[__rZ]
1D15: 1B F8    SBB   A,[X-8]
1D17: 51 5F    MOV   A,[__rY]
1D19: 1B F7    SBB   A,[X-9]
1D1B: 51 60    MOV   A,[__rX]
1D1D: 1B F6    SBB   A,[X-10]
1D1F: 51 64    MOV   A,[__r0]
1D21: 1B F5    SBB   A,[X-11]
1D23: C0 11    JC    0x1D35
1D25: 53 64    MOV   [__r0],A
1D27: 52 F8    MOV   A,[X-8]
1D29: 14 5E    SUB   [__rZ],A
1D2B: 52 F7    MOV   A,[X-9]
1D2D: 1C 5F    SBB   [__rY],A
1D2F: 52 F6    MOV   A,[X-10]
1D31: 1C 60    SBB   [__rX],A
1D33: 77 FC    INC   [X-4]
1D35: 7B 00    DEC   [X+0]
1D37: BF CB    JNZ   0x1D03
1D39: 51 5E    MOV   A,[__rZ]
1D3B: 54 F8    MOV   [X-8],A
1D3D: 51 5F    MOV   A,[__rY]
1D3F: 54 F7    MOV   [X-9],A
1D41: 51 60    MOV   A,[__rX]
1D43: 54 F6    MOV   [X-10],A
1D45: 51 64    MOV   A,[__r0]
1D47: 54 F5    MOV   [X-11],A
1D49: 18       POP   A
1D4A: 53 64    MOV   [__r0],A
1D4C: 18       POP   A
1D4D: 60 D0    MOV   REG[208],A
1D4F: 7F       RET   
__i_div32_not_util:
1D50: 37 FC FF XOR   [X-4],255
1D53: 77 FC    INC   [X-4]
1D55: 37 FB FF XOR   [X-5],255
1D58: 0F FB 00 ADC   [X-5],0
1D5B: 37 FA FF XOR   [X-6],255
1D5E: 0F FA 00 ADC   [X-6],0
1D61: 37 F9 FF XOR   [X-7],255
1D64: 0F F9 00 ADC   [X-7],0
1D67: 7F       RET   
__icall:
1D68: 53 60    MOV   [__rX],A
1D6A: 51 64    MOV   A,[__r0]
1D6C: 08       PUSH  A
1D6D: 51 63    MOV   A,[__r1]
1D6F: 08       PUSH  A
1D70: 51 60    MOV   A,[__rX]
1D72: 7F       RET   
--------------------------------------------------------------------------------


PSoC Designer Version: 4.3.1884.0

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.09
ICCM8C version V1.65
